[{"title":"Promise使用","date":"2022-11-15T12:32:16.000Z","path":"2022/11/15/Promise使用/","text":"Promise使用Promise对象方法 Promise.resolve 方法返回一个新的Promise实例，该实例的状态为 fulfilled Promise.resolve(&#39;success&#39;) 等价于 new Promise(resolve =&gt; resolve(&#39;success&#39;)) Promise.reject 方法返回一个新的Promise实例，该实例的状态为 rejected Promise.reject(&#39;error&#39;) 等价于 new Promise(reject =&gt; reject(&#39;error&#39;)) Promise.all 用于将多个Promise实例，包装成一个新的Promise实例 1const p = Promise.all([p1,p2,p3]) p 的状态由p1,p2,p3决定，分两种情况 p1,p2,p3状态都变为fulfilled，p状态才会变成fulfilled，此时p1,p2,p3的返回值组成一个数组，传递给p的回调函数。 只要p1,p2,p3中有一个为rejected，p的状态就变成rejected，此时第一个被rejected的实例的返回值，传递给p的回调函数。 Promise.race 用于将多个Promise实例，包装成一个新的Promise实例 1const p = Promise.race([p1,p2,p3]) 只要p1,p2,p3中有一个实例率先改变状态，p的状态就跟着改变，率先改变状态实例的返回值，传递给p的回调函数。 Promise.allSetteled 用于将多个Promise实例，包装成一个新的Promise实例用来确定一组异步操作是否都结束了（不管成功或失败），只走then方法 123const p = Promise.allSetteled([p1,p2,p3]).then(result=&gt;&#123; result.filter(item=&gt; item.status === &apos;fulfilled&apos;)&#125;) Promise.any 用于将多个Promise实例，包装成一个新的Promise实例 1const p = Promise.all([p1,p2,p3]) p 的状态由p1,p2,p3决定，分两种情况 只要p1,p2,p3中有一个为fulfilled，p的状态就变成fulfilled，此时第一个被fulfilled的实例的返回值，传递给p的回调函数。 p1,p2,p3状态都变为rejected，p状态才会变成rejected。 Promise.finally 1234const p = new Promise((resolve,reject) =&gt; resolve(&apos;success&apos;))p.then(res=&gt;&#123;&#125;) .catch(err=&gt;&#123;&#125;) .finally(()=&gt;&#123;&#125;) finally最终肯定会执行的。","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"flutter02-dart","date":"2022-11-14T14:00:34.000Z","path":"2022/11/14/flutter02-dart/","text":"dart基础dart的变量与常量 var 声明变量的可以修改 Final 和 Const final只能在初始化时赋值一次，后续值不可以修改。 const同时也是‘final’，只是更加严格，它是编译时常量，也就是说它在非运行时就可以得到这个值。即：1234567int getNum()&#123; return 1;&#125;void main()&#123; final a = getNum(); // 1 const b = getNum(); // 报错，这个不能在运行之前得到值；&#125; 内置类型 number（num, int, double）数字int和double都是num的子类型 12345678var a = 1;// equal toint a = 1;double a2 = 1.1;num a3 = 1 a3 = 1.1 string 字符串 12345678910111213141516var str = &apos;hello&apos;;// equal toString str = &apos;hello&apos;;// &apos;&apos;&apos;定义可以换行的字符串系列String strs = &apos;&apos;&apos; hello world dart string&apos;&apos;&apos;;// 字符串表达式 直接用 $strsString newStr = &apos;this is $strs&apos;// 通过提供一个r前缀可以创建一个“原始raw”字符串var str = &apos;in a raw string, even \\n isnt special.&apos;; // 输出两行var str = r&apos;in a raw string, even \\n isnt special.&apos;; // 会将\\n输出 boolean 1bool isTrue = true; // isTrue must be true or false list（also known as arrays） 123var arr = [10,20,30];// equal toList arr = [10,20,30]; 列表常用操作 读、写：arr[0]— 增：arr.add(40) // [10,20,30,40] 删：arr.remove(10) or arr.removeAt(0) indexOf // 同js用法 forEach12345const List arr = [1, 2, 3, 40];void fun(a) &#123; print(a);&#125;;arr.forEach(fun); map由键值组成的对象，也叫字典类型。每个键只能出现一次。12345Map user = &#123; &apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 18, &apos;hobby&apos;: [&apos;movie&apos;, &apos;run&apos;]&#125;; map常用操作 读、写：user[‘name’]— 增：user[‘sex’] = ‘男’ 删：user.remove(‘name’) forEach rune（for expressing Unicode characters in a string）用来表示utf-32字符集，dart字符串是utf-16的字符序列。 symbol 注意 dart只有 == 没有 === dart中没有隐式转换 声明的变量默认值为 null （js是undefined）","tags":[{"name":"flutter","slug":"flutter","permalink":"https://hanjinbao.cn/tags/flutter/"}]},{"title":"flutter01-布局构建","date":"2022-11-14T12:00:34.000Z","path":"2022/11/14/flutter01-布局构建/","text":"Flutter 中的布局在 Flutter 中，只需几步就可以在屏幕上显示文本、图标或图像。 布局一个可见widget1. 创建一个可见 widget 举个例子，创建一个 Text widget： 1Text(&apos;Hello World&apos;), 创建一个 Image widget 1234Image.asset( &apos;images/lake.jpg&apos;, fit: BoxFit.cover,), 创建一个 Icon widget 1234Icon( Icons.star, color: Colors.red[500],), 2. 将可见 widget 添加到布局 widget 所有布局 widgets 都具有以下任一项： - 一个 child 属性，如果它们只包含一个子项 —— 例如 Center 和 Container - 一个 children 属性，如果它们包含多个子项 —— 例如 Row、Column、ListView 和 Stack 将 Text widget 添加进 Center widget： 123const Center( child: Text(&apos;Hello World&apos;),), 3. 将布局 widget 添加到页面 一个 Flutter app 本身就是一个 widget，大多数 widgets 都有一个 build() 方法，在 app 的 build() 方法中实例化和返回一个 widget 会让它显示出来。 对于 Material app，你可以使用 Scaffold widget，它提供默认的 banner 背景颜色，还有用于添加抽屉、提示条和底部列表弹窗的 API。你可以将 Center widget 直接添加到主页 body 的属性中。 lib/main.dart (MyApp) 123456789101112131415161718class MyApp extends StatelessWidget &#123; const MyApp(&#123;super.key&#125;); @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Flutter layout demo&apos;, home: Scaffold( appBar: AppBar( title: const Text(&apos;Flutter layout demo&apos;), ), body: const Center( child: Text(&apos;Hello World&apos;), ), ), ); &#125;&#125; 横向或纵向布局多个 widgets 最常见的布局模式之一是垂直或水平 widgets。你可以使用 Row widget 水平排列 widgets，使用 Column widget 垂直排列 widgets。 要点： Row 和 Column 是两种最常用的布局模式。 Row 和 Column 每个都有一个子 widgets 列表。 一个子 widget 本身可以是 Row、Column 或其他复杂 widget。 可以指定 Row 或 Column 如何在垂直和水平方向上对齐其子项。 可以拉伸或限制特定的子 widgets。 可以指定子 widgets 如何占用 Row 或 Column 的可用空间。 提示： Row 和 Column 是水平和垂直布局的基本原始 widgets —— 这些低级 widgets 允许最大程度的自定义。 Flutter 还提供专门的、更高级别的 widgets，可能可以直接满足需求。例如，和 Row 相比你可能更喜欢 ListTile，这是一个易于使用的 widget，有属性可以设置头尾图标，最多可以显示 3 行文本；和 Column 相比你也可能更喜欢 ListView，这是一种类似于列的布局，但如果其内容太长导致可用空间不够容纳时会自动滚动。 对齐 widgets 你可以使用 mainAxisAlignment 和 crossAxisAlignment 属性控制行或列如何对齐其子项。对于一行来说，主轴水平延伸，交叉轴垂直延伸。对于一列来说，主轴垂直延伸，交叉轴水平延伸。 布局约束Flutter 的布局方式与 HTML 的布局差异相当大规则： 首先，上层 widget 向下层 widget 传递约束条件； 然后，下层 widget 向上层 widget 传递大小信息。 最后，上层 widget 决定下层 widget 的位置。","tags":[{"name":"flutter","slug":"flutter","permalink":"https://hanjinbao.cn/tags/flutter/"}]},{"title":"网络协议02-底层网络知识","date":"2022-11-13T05:39:50.000Z","path":"2022/11/13/网络协议02-底层网络知识/","text":"底层网络知识 我们见证了 IP 地址的诞生，或者说是整个操作系统的诞生。一旦机器有了 IP，就可以在网络的环境里和其他的机器展开沟通了。 从物理层到MAC层 物理层提供设备，即数据传输的通路，将多台设备连接起来。设备如网线，接线头，hub等。 数据链路层，即mac层，medium access controller，媒体访问控制，需要解决几个问题 谁先发谁后发 发给谁，谁接收 发送出现了错误，怎么办。 一个广播的网络里面接入了 N 台机器，我怎么知道每个 MAC 地址是谁呢？ 首先根据目标ip地址找到目标机器所在的局域网，然后依赖ARP协议吼一嗓子，ip地址是192.168.3.58的机器你的mac是多少？ 通过ip地址，求mac地址的协议。 arp协议。ARP协议的前提是先要知道目标机器的IP, 根据目标IP求MAC地址的协议 二层设备：交换机 一台 MAC1 电脑将一个包发送给另一台 MAC2 电脑，当这个包到达交换机的时候，一开始交换机也不知道 MAC2 的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1 是来自一个明确的口。以后有包的目的地址是 MAC1 的，直接发送到这个口就可以了。当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。当然，每个机器的 IP 地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。 小结 第一，MAC 层是用来解决多路访问的堵车问题的； 第二，ARP 是通过吼的方式来寻找目标 MAC 地址的，吼完之后记住一段时间，这个叫作缓存； 第三，交换机是有 MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。 我现在在公司的内网想要访问一个北京的外网ip， 首先把我自己的ip地址，mac地址，端口，外网的ip地址，端口，在内网吼一下，被公司网关收到，判断下这个ip是不是内网的， 不是的话，添加上公司自己的mac地址，然后往更上一层吼一下(某个区域电信的网关)，然后这个区域的电信网管判断下ip是不是我这一片的,再试再加上自己的mac地址，再层层往上吼，一直找到这个ip为止。","tags":[{"name":"网络","slug":"网络","permalink":"https://hanjinbao.cn/tags/网络/"}]},{"title":"网络协议01-通信协议综述","date":"2022-11-12T09:43:31.000Z","path":"2022/11/12/网络协议01-通信协议综述/","text":"通信协议综述《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类没法儿沟通，达不成“协议”，通天塔的计划就失败了。但是千年以后，有一种叫“程序猿”的物种，敲着一种这个群体通用的语言，连接着全世界所有的人，打造这互联网世界的通天塔。如今的世界，正是因为互联网，才连接在一起。 协议三要素 语法，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。 语义，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。 顺序，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。 查看IP地址 Windows 上是 ipconfig，在 Linux 上是 ifconfig。 如何配置 IP 地址？ 如果配置一个和谁都不搭边的地址呢？例如，旁边的机器都是 192.168.1.x，我非得配置一个 16.158.23.6，会出现什么现象呢？答：不会出现任何现象，就是包发不出去呗你看着它有自己的源 IP 地址 16.158.23.6，也有目标 IP 地址 192.168.1.6，但是包发不出去，这是因为 MAC 层还没填。 不在一个网段，会先发送至网关： 若没有网关，不发； 若配了网关，离开该局域网。 小结 IP 是地址，有定位功能；MAC 是身份证，无定位功能； CIDR 可以用来判断是不是本地人；(CIDR 无类型域间选路 将IP地址一分为二 分别为网络号和主机号) 10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。 IP 分公有的 IP 和私有的 IP。（私有IP只能被局域网的其他机器所访问。 共有IP能够被全世界的机器所访问。） 只要是在网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层。 第5层:应用层 第4层:传输层 第3层:网络层 第2层:链路层 第1层:物理层","tags":[{"name":"网络","slug":"网络","permalink":"https://hanjinbao.cn/tags/网络/"}]},{"title":"ES6","date":"2022-11-12T02:28:04.000Z","path":"2022/11/12/ES6/","text":"ES6-ES13一. 走入ES61.初识ES6 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 1997年：ECMAScript 1.0 1998年：ECMAScript 2.0 1999年：ECMAScript 3.0 2006年：ECMAScript 4.0 未通过 2009年：ECMAScript 5.0 2015年：ECMAScript 6.0 至今，版本号改用年号的形式。 2.let声明变量与const声明常量 let 不允许重复声明变量 123// 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉var num = 100var num = 200 123// 使用 let 重复声明变量的时候就会报错了let num = 100let num = 200 // 这里就会报错了 123// 使用 const 重复声明变量的时候就会报错const num = 100const num = 200 // 这里就会报错了 let 和 const 声明的变量不会在预解析的时候解析（也就是没有变量提升） 123// 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值console.log(num) // undefinedvar num = 100 123// 因为 let 不会进行预解析（变量提升），所以直接报错了console.log(num) let num = 100 123// 因为 const 不会进行预解析（变量提升），所以直接报错了console.log(num) const num = 100 let 和 const 声明的变量会被所有代码块限制作用范围 12345// var 声明的变量只有函数能限制其作用域，其他的不能限制if (true) &#123; var num = 100&#125;console.log(num) // 100 123456// let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）if (true) &#123; let num = 100 console.log(num) // 100&#125;console.log(num) // 报错 123456// const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）if (true) &#123; const num = 100 console.log(num) // 100&#125;console.log(num) // 报错 let 和 const 的区别 let 声明的变量的值可以改变，const 声明的变量的值不可以改变 123let num = 100num = 200console.log(num) // 200 12const num = 100num = 200 // 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量） let 声明的时候可以不赋值，const 声明的时候必须赋值 123let numnum = 100console.log(num) // 100 1const num // 这里就会报错了，因为 const 声明的时候必须赋值 3.解构赋值 解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式 3-1 解构对象 快速的从对象中获取成员 12345678910// ES5 的方法想得到对象中的成员const obj = &#123; name: 'miller', age: 100, gender: '男'&#125;let name = obj.namelet age = obj.agelet gender = obj.gender 1234567891011// 解构赋值的方式从对象中获取成员const obj = &#123; name: 'miller', age: 100, gender: '男'&#125;// 前面的 &#123;&#125; 表示我要从 obj 这个对象中获取成员了// name age gender 都得是 obj 中有的成员// obj 必须是一个对象let &#123; name, age, gender &#125; = obj 3-2 解构数组 快速的从数组中获取成员 12345// ES5 的方式从数组中获取成员const arr = ['miller', 'tiechui', 'gangdan']let a = arr[0]let b = arr[1]let c = arr[2] 1234567// 使用解构赋值的方式从数组中获取成员const arr = ['miller', 'tiechui', 'gangdan']// 前面的 [] 表示要从 arr 这个数组中获取成员了// a b c 分别对应这数组中的索引 0 1 2// arr 必须是一个数组let [a, b, c] = arr 4. 模版字符串 ES5 中我们表示字符串的时候使用 &#39;&#39; 或者 &quot;&quot; 在 ES6 中，我们还有一个东西可以表示字符串，就是 （反引号） 12let str = `hello world`console.log(typeof str) // string 和单引号、双引号的区别 反引号可以换行书写 123456// 这个单引号或者双引号不能换行，换行就会报错了let str = 'hello world' // 下面这个就报错了let str2 = 'hello world' 123456let str = ` hello world`console.log(str) // 是可以使用的 反引号可以直接在字符串里面拼接变量 12345678// ES5 需要字符串拼接变量的时候let num = 100let str = 'hello' + num + 'world' + numconsole.log(str) // hello100world100// 直接写在字符串里面不好使let str2 = 'hellonumworldnum'console.log(str2) // hellonumworldnum 1234// 模版字符串拼接变量let num = 100let str = `hello$&#123;num&#125;world$&#123;num&#125;`console.log(str) // hello100world100 在 里面的 ${} 就是用来书写变量的位置 5.字符串扩展5-1 includes函数判断字符串中是否存在指定字符 12345let myname = \"miller\"console.log(myname.includes(\"e\")) //trueconsole.log(myname.startsWith(\"k\")) //trueconsole.log(myname.endsWith(\"n\")) //true 5-2 repeat函数repeat()方法返回一个新字符串,表示将原字符串重复n次。 12345678let myname = \"miller\"console.log(myname.repeat(3)) //millermillermillerconsole.log(myname.repeat(0)) //\"\" console.log(myname.repeat(3.5)) //millermillermillerconsole.log(myname.repeat(\"3\"))//millermillermiller 6.数值扩展6-1 二进制和八进制表示法1234let count1 = 100let count2 = 0x100let count3 = 0o100let count4 = 0b100 6-2 isFinite与isNaN方法减少全局性方法，使得语言逐步模块化 1234let num1 = Number.isFinite(100) //truelet num2 = Number.isFinite(100/0) //falselet num3 = Number.isFinite(Infinity) // falselet num4 = Number.isFinite(\"100\") //false 1234let num1 = Number.isNaN(100) // falselet num2 = Number.isNaN(NaN) //truelet num3 = Number.isNaN(\"miller\") //falselet num4 = Number.isNaN(\"100\") // false 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 6-3 isInteger方法用来判断一个数值是否为整数。 1234let num1 = Number.isInteger(100) // truelet num2 = Number.isInteger(100.0) //truelet num3 = Number.isInteger(\"miller\") //falselet num4 = Number.isInteger(\"100\") // false 6-4 极小常量Number.EPSILON它表示 1 与大于 1 的最小浮点数之间的差。2.220446049250313e-16 123456function isEqual(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON&#125;console.log(isEqual(0.1+0.2,0.3)) //trueconsole.log(0.1+0.2===0.3) //false 6-5 Math.trunc将小数部分抹掉,返回一个整数。 1234console.log(Math.trunc(1.2)) //1console.log(Math.trunc(1.8))// 1console.log(Math.trunc(-1.8)) //-1console.log(Math.trunc(-1.2))//-1 6-6 Math.signMath.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 12345Math.sign(-100) // -1Math.sign(100) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(\"miller\") // NaN 7.数组扩展7-1 扩展运算符1234let arr1 = [1,2,3]let arr2 = [4,5,6]console.log([...arr1,...arr2]) 7-2 Array.from将类数组对象转换为真正数组 12345678function test()&#123; console.log(Array.from(arguments))&#125;test(1,2,3)let oli = document.querySelectorAll(\"li\")console.log(Array.from(oli)) 7-3 Array.of将一组值转化为数组,即新建数组 12345let arr1 = Array(3)console.log(arr1)// [,,]let arr2 = Array.of(3)console.log(arr2)// [3] 7-4. find方法1)该方法主要应用于查找第一个符合条件的数组元素 2)它的参数是一个回调函数。在回调函数中可以写你要查找元素的条件,当条件成立为true时,返回该元素。如果没有符合条件的元素,返回值为undefined 123456789let arr = [11,12,13,14,15]let res1 = arr.find(function(item)&#123; return item&gt;13&#125;)let res2 = arr.findIndex(function(item)&#123; return item&gt;13&#125;)console.log(res1) //14console.log(res2) //3 7-5. fill方法使用自己想要的参数替换原数组内容,但是会改变原来的数组 1234let arr1 = new Array(3).fill(\"miller\")let arr2 = ['a', 'b', 'c'].fill(\"miller\", 1, 2)console.log(arr1)//['miller', 'miller', 'miller']console.log(arr2)// ['a', 'miller', 'c'] 7-6 flat与flatMap方法按照一个可指定的深度递归遍历数组,并将所有元素与遍历到的子数组中的元素合并为一个新数组返回 12345678910var obj = [&#123; name: \"A\", list: [\"鞍山\", \"安庆\", \"安阳\"] &#125;, &#123; name: \"B\", list: [\"北京\", \"保定\", \"包头\"] &#125;]console.log(obj.flatMap(item =&gt; item.list)) 8.对象扩展8-1 对象简写12345678910let name =\"moduleA\"let obj = &#123; name, test1()&#123; &#125;, test2()&#123; &#125;&#125; 8-2 属性名表达式12345678910let name =\"moduleA\"let obj = &#123; name, [name+\"test1\"]()&#123; &#125;, [name+\"test2\"]()&#123; &#125;&#125; 8-3 Object.assignObject.assign(target, object1，object2)的第一个参数是目标对象，后面可以跟一个或多个源对象作为参数。 target：参数合并后存放的对象 object1：参数1 object2：参数2 12345678910111213const obj1 = &#123; name: \"miller\"&#125;;const obj2 = &#123; name:\"tiechui\"&#125;;const obj3 = &#123; age:100&#125;;Object.assign(obj1, obj2, obj3);//obj1 &#123;name: 'tiechui', age: 100&#125; 8-4 Object.is方法判断两个值是否是相同的值 12345console.log(NaN===NaN) //falseconsole.log(+0===-0) //trueconsole.log(Object.is(NaN,NaN)) //trueconsole.log(Object.is(+0,-0)) //false 9.函数扩展9-1 箭头函数 箭头函数是 ES6 里面一个简写函数的语法方式 重点： 箭头函数只能简写函数表达式，不能简写声明式函数 12345function fn() &#123;&#125; // 不能简写const fun = function () &#123;&#125; // 可以简写const obj = &#123; fn: function () &#123;&#125; // 可以简写&#125; 语法： (函数的行参) =&gt; { 函数体内要执行的代码 } 123456789const fn = function (a, b) &#123; console.log(a) console.log(b)&#125;// 可以使用箭头函数写成const fun = (a, b) =&gt; &#123; console.log(a) console.log(b)&#125; 12345678910111213const obj = &#123; fn: function (a, b) &#123; console.log(a) console.log(b) &#125;&#125;// 可以使用箭头函数写成const obj2 = &#123; fn: (a, b) =&gt; &#123; console.log(a) console.log(b) &#125;&#125; 9-2 箭头函数的特殊性 箭头函数内部没有 this，箭头函数的 this 是上下文的 this 12345678910111213141516// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的// 因为这里的 this 是 window// 所以箭头函数内部的 this 就是 windowconst obj = &#123; fn: function () &#123; console.log(this) &#125;, // 这个位置是箭头函数的上一行，但是不能打印出 this fun: () =&gt; &#123; // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置 console.log(this) &#125;&#125;obj.fn()obj.fun() 按照我们之前的 this 指向来判断，两个都应该指向 obj 但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window 箭头函数内部没有 arguments 这个参数集合 12345678910const obj = &#123; fn: function () &#123; console.log(arguments) &#125;, fun: () =&gt; &#123; console.log(arguments) &#125;&#125;obj.fn(1, 2, 3) // 会打印一个伪数组 [1, 2, 3]obj.fun(1, 2, 3) // 会直接报错 函数的行参只有一个的时候可以不写 () 其余情况必须写 1234567891011const obj = &#123; fn: () =&gt; &#123; console.log('没有参数，必须写小括号') &#125;, fn2: a =&gt; &#123; console.log('一个行参，可以不写小括号') &#125;, fn3: (a, b) =&gt; &#123; console.log('两个或两个以上参数，必须写小括号') &#125;&#125; 函数体只有一行代码的时候，可以不写 {} ，并且会自动 return 123456789const obj = &#123; fn: a =&gt; &#123; return a + 10 &#125;, fun: a =&gt; a + 10&#125;console.log(fn(10)) // 20console.log(fun(10)) // 20 9-3 函数传递参数的时候的默认值 我们在定义函数的时候，有的时候需要一个默认值出现 就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数 123456function fn(a) &#123; a = a || 10 console.log(a)&#125;fn() // 不传递参数的时候，函数内部的 a 就是 10fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 在 ES6 中我们可以直接把默认值写在函数的行参位置 12345function fn(a = 10) &#123; console.log(a)&#125;fn() // 不传递参数的时候，函数内部的 a 就是 10fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 这个默认值的方式箭头函数也可以使用 12345const fn = (a = 10) =&gt; &#123; console.log(a)&#125;fn() // 不传递参数的时候，函数内部的 a 就是 10fn(20) // 传递了参数 20 的时候，函数内部的 a 就是 20 注意： 箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写 （） 10.Symbol ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 使用Symbol作为对象属性名 123456let name = Symbol()let age = Symbol()var obj =&#123; [name]:\"miller\", [age]:100&#125; Symbol()函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。这主要是为了在控制台显示，比较容易区分。 1234567let name = Symbol(\"name\")let age = Symbol(\"age\")var obj =&#123; [name]:\"miller\", [age]:100&#125;console.log(obj) 遍历问题 123456789101112131415let keys = &#123; name:Symbol(\"name\"), age:Symbol(\"age\")&#125;var obj =&#123; [keys.name]:\"miller\", [keys.age]:100, a:1, b:2, c:3&#125;Reflect.ownKeys(obj).forEach(item=&gt;&#123; console.log(item,obj[item])&#125;) Symbol.for()可以重新使用同一个 Symbol 值 123456var obj =&#123; [Symbol.for(\"name\")]:\"miller\", [Symbol.for(\"age\")]:100&#125;console.log(obj[Symbol.for(\"name\")]) 11.Iterator迭代器 Iterator 的作用有三个： 一是为各种数据结构，提供一个统一的、简便的访问接口； 二是使得数据结构的成员能够按某种次序排列； 三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of循环 12345let arr = [\"miller\", \"tiechui\", \"gangdaner\"]for(let i of arr)&#123; console.log(i)&#125; 123456789101112131415Iterator 的遍历过程是这样的。（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。let i = arr[Symbol.iterator]()console.log(i.next())console.log(i.next())console.log(i.next())console.log(i.next()) ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。 原生默认具备 Iterator 接口的数据结构如下。 Array Set Map String arguments 对象 NodeList 对象 如何对于对象进行for fo遍历？ 12345678910111213141516171819202122232425262728293031323334353637383940let obj = &#123; 0: \"miller\", 1: \"tiechui\", 2: \"gangdaner\", length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;for (let i of obj) &#123; console.log(i)&#125;let obj2 = &#123; data: ['miller', 'tiechui', \"gangdaner\"], [Symbol.iterator]() &#123; // let _this = this let index = 0; return &#123; next: () =&gt; &#123; if (index &lt; this.data.length) &#123; return &#123; value: this.data[index++], done: false &#125; &#125; else &#123; return &#123; value: undefined, done: true &#125; &#125; &#125; &#125; &#125;&#125;;for (let i of obj2) &#123; console.log(i)&#125; 12.Set结构 它类似于数组，但成员的值都是唯一的，没有重复的值。 12-1 初识Set12345678let s1 = new Set([1, 2, 3, 2, 3])console.log(s1)let s2 = new Set()s2.add(1)s2.add(2)s2.add(3)console.log(s2) 12-2 实例的属性和方法 size：返回Set实例的成员总数。 Set.prototype.add(value)：添加某个value。 Set.prototype.delete(value)：删除某个value，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 12-3 遍历 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：遍历每个成员 12-4 复杂数据结构去重1234567891011121314151617181920212223function uni(arr) &#123; let res = new Set() return arr.filter(item =&gt; &#123; let id = JSON.stringify(item) if (res.has(id)) &#123; return false &#125; else &#123; res.add(id) return true &#125; &#125;)&#125;var arr = [1, 2, 3, \"data\", &#123; name: \"miller\"&#125;, &#123; name: \"miller\"&#125;, [1, 2], [3, 4], [3, 4] ]console.log(uni(arr)) 13.Map结构 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 13-1 初识Map1234567891011let m1 = new Map()m1.set(\"name\",\"miller\")m1.set(&#123;a:1&#125;,\"大连\")console.log(m1)let m2= new Map([ [\"name\",\"miller\"], [&#123;a:1&#125;,\"大连\"]])console.log(m2) 13-2 实例的属性和方法 size：返回 Map 结构的成员总数。 Map.prototype.set(key,value)：添加key对应得value，返回 Map 结构本身。 Map.prototype.get(key)：获取key对应的value Map.prototype.delete(key)：删除某个键（键名+键值） Map.prototype.has(key)：某个键是否在当前 Map 对象之中。 Map.prototype.clear()：清除所有成员，没有返回值。 13-3 遍历 Map.prototype.keys()：返回键名的遍历器。 Map.prototype.values()：返回键值的遍历器。 Map.prototype.entries()：返回所有成员的遍历器。 Map.prototype.forEach()：遍历 Map 的所有成员。 14.Proxy代理 Proxy如其名， 它的作用是在对象和和对象的属性值之间设置一个代理，获取该对象的值或者设置该对象的值， 以及实例化等等多种操作， 都会被拦截住， 经过这一层我们可以统一处理，我们可以认为它就是“代理器” 14-1.get方法123456let target = &#123;&#125;let proxy = new Proxy(target,&#123; get(target,prop)&#123; return target[prop] &#125;&#125;) 14-2.set方法123456789101112let target = &#123;&#125;let proxy = new Proxy(target,&#123; get(target,prop)&#123; return target[prop] &#125;, set(target,prop,value)&#123; if(prop===\"data\")&#123; box.innerHTML = value &#125; target[prop] = value; &#125;&#125;) 14-3.has方法1234567891011121314151617181920let target = &#123; _prop: \"内部数据\"&#125;let proxy = new Proxy(target, &#123; get(target, prop) &#123; return target[prop] &#125;, set(target, prop, value) &#123; if (prop === \"data\") &#123; box.innerHTML = value &#125; target[prop] = value; &#125;, has(target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;) 14-4.this问题1234567891011121314let target = new Set()const proxy = new Proxy(target, &#123; get(target, key) &#123; const value = target[key] // 遇到 Function 都手动绑定一下 this if (value instanceof Function) &#123; console.log(`访问$&#123;value&#125;方法了`) return value.bind(target) //不能 是 call apply &#125; return value &#125;&#125;)proxy.add(1) Proxy本质上属于元编程非破坏性数据劫持，在原对象的基础上进行了功能的衍生而又不影响原对象，符合松耦合高内聚的设计理念。 15.Reflect对象 Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。 15-1 代替Object的某些方法1234567const obj = &#123;&#125;;Reflect.defineProperty(obj, 'name', &#123; value: 'miller', writable: false, configurable:false&#125;); 15-2 修改某些Object方法返回结果1234567891011121314// 老写法try &#123; Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // fail&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; // success&#125; else &#123; // fail&#125; 15-3 命令式变为函数行为123456789101112const obj = &#123; name:\"miller\"&#125;;//老写法console.log(\"name\" in obj) //true//新写法console.log(Reflect.has(obj, 'name')) //true//老写法delete obj.name//新写法Reflect.deleteProperty(obj, \"name\") 15-4 配合Proxy1234567891011121314151617let target = new Set()const proxy = new Proxy(target, &#123; get(target, key) &#123; const value = Reflect.get(target,key) // 遇到 Function 都手动绑定一下 this if (value instanceof Function) &#123; console.log(`访问$&#123;value&#125;方法了`) return value.bind(target) //不能 是 call apply &#125; return value &#125;, set() &#123; return Reflect.set(...arguments) &#125;&#125;)proxy.add(1) 1234567891011121314151617let arr = [1, 2, 3]let proxy = new Proxy(arr, &#123; get(target, key) &#123; console.log('get', key) return Reflect.get(...arguments) &#125;, set(target, key, value) &#123; console.log('set', key, value) return Reflect.set(...arguments) &#125;&#125;)proxy.push(4)// 能够打印出很多内容// get push (寻找 proxy.push 方法)// get length (获取当前的 length)// set 3 4 (设置 proxy[3] = 4)// set length 4 (设置 proxy.length = 4) 16.Promise Promise 是异步编程的一种解决方案，比传统的解决方案回调函数, 更合理和更强大。ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象 。 指定回调函数方式更灵活易懂。 解决异步 回调地狱 的问题。 16-1 回调地狱 当一个回调函数嵌套一个回调函数的时候 就会出现一个嵌套结构 当嵌套的多了就会出现回调地狱的情况 比如我们发送三个 ajax 请求 第一个正常发送 第二个请求需要第一个请求的结果中的某一个值作为参数 第三个请求需要第二个请求的结果中的某一个值作为参数 1234567891011121314151617181920ajax(&#123; url: '我是第一个请求', success (res) &#123; // 现在发送第二个请求 ajax(&#123; url: '我是第二个请求'， data: &#123; a: res.a, b: res.b &#125;, success (res2) &#123; // 进行第三个请求 ajax(&#123; url: '我是第三个请求', data: &#123; a: res2.a, b: res2.b &#125;, success (res3) &#123; console.log(res3) &#125; &#125;) &#125; &#125;) &#125;&#125;) 回调地狱，其实就是回调函数嵌套过多导致的 当代码成为这个结构以后，已经没有维护的可能了 16-2 Promise使用 语法： 12345678new Promise(function (resolve, reject) &#123; // resolve 表示成功的回调 // reject 表示失败的回调&#125;).then(function (res) &#123; // 成功的函数&#125;).catch(function (err) &#123; // 失败的函数&#125;) 16-3 Promise 对象的状态Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。 123异步操作未完成（pending）异步操作成功（fulfilled）异步操作失败（rejected） 这三种的状态的变化途径只有两种。 12从“未完成”到“成功”从“未完成”到“失败” 一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 因此，Promise 的最终结果只有两种。 12异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。 image-20220902141409899 16-4 Promise.allPromise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); p的状态由p1,p2,p3 决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 16-5 Promise.racePromise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 17.Generator 函数 Generator 函数是 ES6 提供的一种异步编程解决方案 Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 17-1 基本语法123456789101112function *gen()&#123; console.log(1) yield; console.log(2) yield; console.log(3)&#125;let g = gen()g.next()g.next()g.next() yield(产出)表达式是暂停执行的标记，而next方法可以恢复执行。 123456789101112function *gen()&#123; yield 1; yield 2;&#125;let g = gen()let res1 = g.next()console.log(res1)let res2 = g.next()console.log(res2)let res3 = g.next()console.log(res3) image-20220917070836171 1234567891011function *gen()&#123; let res1 = yield; console.log(res1) let res2 = yield; console.log(res2)&#125;let g = gen()g.next(\"data-1\")g.next(\"data-2\")g.next(\"data-3\") image-20220917071219520 17-2 异步流程手动版本 1234567891011121314function *gen()&#123; let res1 = yield ajax(\"1.json\") console.log(res1) let res2 = yield ajax(\"2.json\") console.log(res2)&#125;let g = gen() g.next().value.then(data=&gt;&#123; g.next(data).value.then(data=&gt;&#123; g.next(data) &#125;)&#125;) 自动版本 1234567891011121314151617181920212223function* gen() &#123; let res1 = yield ajax(\"1.json\") console.log(res1) let res2 = yield ajax(\"2.json\") console.log(res2)&#125;function AutoRun(gen) &#123; let g = gen(); function next(data) &#123; let res = g.next(data); if (res.done) return res.value.then(function (data) &#123; next(data); &#125;); &#125; next();&#125;AutoRun(gen); 18. Class语法18-1 类的写法1234567891011class Person &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(this.name,this.age) &#125;&#125;let obj = new Person(\"miller\",100)console.log(obj) 18-2 getter与setter123456789101112131415class List&#123; constructor(ele)&#123; this.element = ele &#125; get html()&#123; return this.element.innerHTML &#125; set html(arr)&#123; this.element.innerHTML = arr.map(item=&gt;`&lt;li&gt;$&#123;item&#125;&lt;/li&gt;`).join(\"\") &#125;&#125;let obj = new List(document.querySelector(\"#list\"))obj.html = [\"aaa\",\"bbb\",\"cccc\"] 18-3 静态属性和静态方法123456789101112131415161718class Person &#123; static name = \"Person这个类\" constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(this.name,this.age) &#125; static eat()&#123; console.log(\"eat\") &#125;&#125;let obj = new Person(\"miller\",100)console.log(Person.name)Person.eat() 18-4 继承 ES6 规定，子类必须在constructor()方法中调用super()，否则就会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象。 123456789101112131415161718192021222324252627282930313233class Person &#123; static name = \"Person这个类\" constructor(name,age)&#123; this.name = name; this.age = age; &#125; say()&#123; console.log(this.name,this.age) &#125; static eat()&#123; console.log(\"eat\") &#125;&#125;class Student extends Person&#123; constructor(name,age,score)&#123; super(name,age) this.score = score &#125; say()&#123; super.say() console.log(this.score) &#125; static eat()&#123; super.eat(); console.log(\"student eat\") &#125;&#125;let obj = new Student(\"miller\",100,200)console.log(obj)obj.say()Student.eat() 19.模块化 JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。 CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用require()和module.exports，ES6 模块使用import和export。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 写法1： 123export default A1import a1 from \"./1.js\" 写法2： 1234567export &#123;A1,A2&#125;import &#123;A1,A2&#125; from \"./1.js\"import &#123;A1 as a1,A2 as a2&#125; from \"./1.js\"import * as obj from \"./1.js\" 12345678910111213export function A1()&#123; console.log(\"A1\")&#125;export function A2()&#123; console.log(\"A2\")&#125;import &#123;A1,A2&#125; from \"./1.js\"import &#123;A1 as a1,A2 as a2&#125; from \"./1.js\"import * as obj from \"./1.js\" 混合写法： 1234export &#123;A1&#125;export default A2import A2,&#123;A1&#125; from \"./1.js\" 二. ES7新特性1. 求幂运算符1Math.pow(3, 2) === 3 ** 2 // 9 2.数组的includes方法12[1, 2, NaN].includes(NaN) // true[1, 2, NaN].indexOf(NaN) // -1 如果仅仅查找数据是否在数组中，建议使用includes，如果是查找数据的索引位置，建议使用indexOf更好一些 三. ES8新特性1. async和await1-1.Asyncasync 函数，使得异步操作变得更加方便。 更好的语义。 返回值是 Promise。 1234async function test()&#123; &#125;test() 1-2.Awaitawait命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。 1234567891011async function test()&#123; var res1 = await ajax(\"http://localhost:3000/news1\") var res2 = await ajax(\"http://localhost:3000/news2\") return res2&#125;test().then(res=&gt;&#123; console.log(\"返回结果\",res)&#125;).catch(err=&gt;&#123; console.log(\"err\",err)&#125;) 1-3.错误处理123456try&#123; var res1 = await ajax(\"http://localhost:3000/news1\") var res2 = await ajax(\"http://localhost:3000/news2\")&#125;catch(err)&#123; console.log(\"err\",err)&#125; 2.对象方法扩展12345let obj = &#123; name:\"miller\", age:100&#125;console.log(Object.values(obj)) 12345let obj = &#123; name:\"miller\", age:100&#125;console.log(Object.entries(obj)) 12345let obj = &#123; name:\"miller\", age:100&#125;console.log(Object.getOwnPropertyDescriptors(obj)) 克隆对象 1234567891011121314151617181920212223242526let obj1 = &#123; name:\"miller\", age:100, location:&#123; provice:\"辽宁\", city:\"大连\" &#125;, //只设置city，防止破坏province get city()&#123; return this.location.city &#125;, set city(value)&#123; this.location.city = value &#125;, set nameset(value)&#123; this.name = value.substring(0,1).toUpperCase()+value.substring(1) &#125;, get nameset()&#123; return this.name &#125;&#125;console.log(Object.getOwnPropertyDescriptors(obj1))var obj2= &#123;&#125;//Object.assign(obj2,obj1)//无法克隆 get set方法Object.defineProperties(obj2,Object.getOwnPropertyDescriptors(obj1)) 3. 字符串填充 padStart()、padEnd()方法可以使得字符串达到固定长度，有两个参数，字符串目标长度和填充内容。 123456let str= \"miller\"console.log(str.padStart(10,\"x\"));//xxxxmillerconsole.log(str.padEnd(10,\"x\"));//millerxxxxconsole.log(str.padStart(5,\"x\"))//millerconsole.log(str.padEnd(5,\"x\"))//miller 4. 函数参数的末尾加逗号123456789101112function test( a, b, c,)&#123; console.log(a,b)&#125;test( 1, 2, 3,) 『末尾逗号』在添加新的参数、属性、元素时是有用的，你可以直接新加一行而不必给上一行再补充一个逗号，这样使版本控制工具的修改记录也更加整洁 四. ES9新特性1. 对象的剩余参数与扩展运算符1-1 对象的剩余参数123456789let obj = &#123; name:\"miller\", age:100, location:\"dalian\"&#125;let &#123;name,...other&#125; = objconsole.log(name) //millerconsole.log(other) //&#123;age: 100, location: 'dalian'&#125; 1-2 对象的扩展运算符123456789let obj1 = &#123; name:\"miller\"&#125;let obj2 = &#123; age:100&#125;console.log(&#123;...obj1,...obj2&#125;) 2.正则表达式命名捕获组JS正则表达式可以返回一个匹配的对象, 一个包含匹配字符串的类数组, 比如: 以 YYYY-MM-DD的格式解析日期， 这样的代码可读性很差, 并且在改变正则表达式的结构的时候很有可能就会改变匹配对象的索引 ES9允许使用命名捕获 ? , 在打开捕获括号后立即命名 12345let str = \"今天是2022-10-10\"let reg = /([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/glet res1 = reg.exec(str)console.log(res1) 12345let str = \"今天是2022-10-10\"let reg = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/glet res1 = reg.exec(str)console.log(res1) 3. Promise.finally() 无论是成功还是失败, 都运行同样的代码, 比如隐藏对话框, 关闭数据连接 1234567891011121314function ajax()&#123; return new Promise((resolve,reject)=&gt;&#123; reject(1111) &#125;)&#125;//showloadingajax().then(res=&gt;&#123;&#125;).catch(err=&gt;&#123;&#125;).finally(()=&gt;&#123; //hideloading console.log(\"finally\")&#125;) 4. 异步遍历器4-1 同步遍历器的问题123456789function* fn() &#123; yield 1111 yield 2222&#125;const syncI = fn();console.log(syncI.next())console.log(syncI.next())console.log(syncI.next()) ###### 12345678function* fn() &#123; yield new Promise(resolve=&gt;resolve(\"1111\")) yield new Promise(resolve=&gt;resolve(\"2222\"))&#125;const syncI = fn();syncI.next().value.then(res=&gt;&#123;console.log(res)&#125;)syncI.next().value.then(res=&gt;&#123;console.log(res)&#125;) value属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。 4-2 异步遍历器生成函数 Generator 函数返回一个同步遍历器，异步 Generator 函数的作用，是返回一个异步遍历器对象。在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。 1234567891011121314151617async function* fn() &#123; yield new Promise(resolve=&gt;resolve(\"1111\")) yield new Promise(resolve=&gt;resolve(\"2222\"))&#125;const asyncI = fn();asyncI.next().then(res=&gt;&#123; console.log(res) return asyncI.next()&#125;).then(res=&gt;&#123; console.log(res) return asyncI.next()&#125;) .then(res=&gt;&#123; console.log(res)&#125;) 4-3 for await of for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口。 123456async function test() &#123; for await (let i of asyncI) &#123; console.log(i) &#125;&#125;test() 4-4 案例改造123456789101112131415161718192021222324function timer(t) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(t) &#125;, t) &#125;) &#125;async function* fn() &#123; yield timer(1000)//任务1 yield timer(2000)//任务2 yield timer(3000)//任务3&#125;// 使用一下 for await ...ofasync function fn1() &#123; for await(const val of fn()) &#123; console.log(\"start\",Date.now()) console.log(val); console.log(\"end\",Date.now()) &#125;&#125;fn1(); 4-5 nodejs用法1234567891011121314151617181920212223242526// 传统写法function main(inputFilePath) &#123; const readStream = fs.createReadStream( inputFilePath, &#123; encoding: 'utf8', highWaterMark: 1024 &#125; ); readStream.on('data', (chunk) =&gt; &#123; console.log('&gt;&gt;&gt; '+chunk); &#125;); readStream.on('end', () =&gt; &#123; console.log('### DONE ###'); &#125;);&#125;// 异步遍历器写法async function main(inputFilePath) &#123; const readStream = fs.createReadStream( inputFilePath, &#123; encoding: 'utf8', highWaterMark: 1024 &#125; ); for await (const chunk of readStream) &#123; console.log('&gt;&gt;&gt; '+chunk); &#125; console.log('### DONE ###');&#125; 五.ES10新特性1. Object.fromEntries Object.fromEntries()方法允许你轻松地将键值对列表转换为对象 1234567const arr = [[\"name\", \"miller\"], [\"age\", 100]];console.log(Object.fromEntries(arr))//&#123;name: 'miller', age: 100&#125;const m = new Map()m.set(\"name\",\"tiechui\")m.set(\"age\",18)console.log(Object.fromEntries(m)) 用处 1234let str =\"name=miller&amp;age=100\"let searchParams = new URLSearchParams(str)console.log(Object.fromEntries(searchParams))//&#123;name: 'miller', age: '100'&#125; 2. trimStart() and trimEnd() trimStart()和trimEnd()方法在实现与trimLeft()和trimRight()相同。 12345let str = \" miller \"console.log(\"|\"+str.trimStart(str)+\"|\")console.log(\"|\"+str.trimEnd(str)+\"|\")console.log(\"|\"+str.trimLeft(str)+\"|\")console.log(\"|\"+str.trimRight(str)+\"|\") 3. Symbol 对象的 description 属性 为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。 12let s = Symbol(\"miller\")console.log(s.description) //miller 4. 可选的 catch1234567891011121314151617181920let pro1 = new Promise(function (resolve, reject) &#123; //执行器函数 setTimeout(() =&gt; &#123; resolve(\"成功的结果\") &#125;, 30000)&#125;)let pro2 = new Promise(function (resolve, reject) &#123; //执行器函数 setTimeout(() =&gt; &#123; reject() &#125;, 2000)&#125;)async function test() &#123; try &#123; await Promise.race([pro1, pro2]) &#125; catch &#123; console.log(\"不关心错误结果，网络超时\") &#125;&#125;test() 六. ES11新特性1. Promise.allSettled Promise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的 promise 结果。 12345678const promises = [ ajax('/200接口'), ajax('/401接口') ];Promise.allSettled(promises).then(results=&gt;&#123; // 过滤出成功的请求 results.filter(item =&gt;item.status === 'fulfilled'); 过滤出失败的请求 results.filter(item=&gt; item.status === 'rejected');&#125;) 2.module新增2-1 动态导入 import() 标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;button&gt;login&lt;/button&gt; &lt;script type=\"module\"&gt; let role1 = \"管理员\" let role2 = \"普通用户\" function login()&#123; return \"普通用户\" &#125; async function render(role)&#123; if(role===role1)&#123; let res1 = await import(\"./1.js\") console.log(res1.default) &#125;else&#123; let res2 = await import(\"./2.js\") console.log(res2.default) &#125; &#125; let obtn = document.querySelector(\"button\") obtn.onclick = function()&#123; let role = login() render(role) &#125; &lt;/script&gt;&lt;/body&gt; 2-2 import.metaimport.meta 会返回一个对象，有一个 url 属性，返回当前模块的url路径，只能在模块内部使用。 1234567891011&lt;script type=\"module\"&gt; import obj from './1.js'&lt;/script&gt;//1.jsconsole.log(import.meta)export default &#123; &#125; 2-3 export * as obj from ‘module’123456789101112131415161718192021//1.jsexport default &#123; name:'111111'&#125;export function test1()&#123; &#125;//2.jsexport default &#123; name:\"22222\"&#125;export function test2()&#123; &#125;export * as obj1 from './1.js'//html &lt;script type=\"module\"&gt; import * as obj from './2.js' console.log(obj) &lt;/script&gt; 3.字符串的matchAll方法 matchAll() 方法返回一个包含所有匹配正则表达式的结果的迭代器。可以使用 for…of 遍历，或者使用 展开运算符(…) 或者 Array.from 转换为数组. 123456789101112let str = `&lt;ul&gt;&lt;li&gt;1111&lt;/li&gt;&lt;li&gt;2222&lt;/li&gt;&lt;li&gt;3333&lt;/li&gt;&lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt;`let reg = /&lt;li&gt;(.*)&lt;\\/li&gt;/gconsole.log(str.match(reg)) //'&lt;li&gt;1111&lt;/li&gt;', '&lt;li&gt;2222&lt;/li&gt;', '&lt;li&gt;3333&lt;/li&gt;', '&lt;li&gt;4444&lt;/li&gt;' 1234567891011121314let str = `&lt;ul&gt;&lt;li&gt;1111&lt;/li&gt;&lt;li&gt;2222&lt;/li&gt;&lt;li&gt;3333&lt;/li&gt;&lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt;`let reg = /&lt;li&gt;(.*)&lt;\\/li&gt;/glet match = null;while(match = reg.exec(str))&#123; console.log(match[0]) console.log(match[1])&#125; 12345678910111213let str = `&lt;ul&gt;&lt;li&gt;1111&lt;/li&gt;&lt;li&gt;2222&lt;/li&gt;&lt;li&gt;3333&lt;/li&gt;&lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt;`let reg = /&lt;li&gt;(.*)&lt;\\/li&gt;/gfor(let i of str.matchAll(reg))&#123; console.log(i)&#125; 4. BigInt JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算。 12349007199254740992 //90071992547409929007199254740993 //9007199254740992Math.pow(2,53) === Math.pow(2,53)+1 为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。 123451234 // 普通整数1234n // BigInt// BigInt 的运算1n + 2n // 3n 5. globalThis globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 123456789101112131415161718192021222324252627//es6-shimvar getGlobal = function () &#123;// the only reliable means to get the global object is // Function('return this')() // However, this causes CSP violations in Chrome apps. if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;;var globals = getGlobal();if (!globals.Reflect) &#123;defineProperty(globals, ‘Reflect’, &#123;&#125;, true);&#125; 12345678910111213141516171819202122232425//以前var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;;let globals = getGlobal()if (globals.document) &#123; console.log(\"进行dom操作相关\")&#125; else &#123; console.log(\"不能进行dom操作\")&#125;//现在if (globalThis.document) &#123; console.log(\"进行dom操作相关\")&#125; else &#123; console.log(\"不能进行dom操作\")&#125; 6.空值合并运算符 空值合并运算符（??）是一个逻辑运算符。当左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数。 1234567let obj = &#123; name:\"miller\", introduction:0&#125;console.log(obj.introduction || \"这个人很懒\")console.log(obj.introduction ?? \"这个人很懒\") ??和 || 的区别是什么呢? 他们两个最大的区别就是 ’ ‘和 0，??的左侧 为 ’ ‘或者为 0 的时候，依然会返回左侧的值； || 会对左侧的数据进行boolean类型转换，所以’ ‘和 0 会被转换成false,返回右侧的值 7.可选链操作符 可选链前面的值如果是null或undefined，则不再执行后面的，之前返回可选链前面的值 12345678910let obj = &#123; name:\"miller\", introduction:0, // location:&#123; // city:\"dalian\" // &#125;&#125;console.log(obj &amp;&amp; obj.location &amp;&amp; obj.location.city)console.log(obj?.location?.city) 七. ES12新特性1. 逻辑赋值操作符逻辑赋值操作符 ??=、&amp;&amp;=、 ||= 12345678910111213let a = truelet b = false//a &amp;&amp;= b //falsea ||= b ; //trueconsole.log(a)let obj = &#123; name:\"miller\", &#125;obj.introduction = obj.introduction??\"很懒\"obj.introduction??=\"很懒\" 2.数字分隔符这个新特性是为了方便程序员看代码而出现的，如果数字比较大，那么看起来就不是那么一目了然 1const num= 123456789； 分隔符不仅可以分割十进制，也可以分割二净值或者十六净值的数据，非常好用。 123const number = 1_000_000_000_000;const binary = 0b1010_0101_1111_1101;const hex = 0xA1_B2_C3; 3. replaceAll 所有匹配都会被替代项替换。模式可以是字符串或正则表达式，而替换项可以是字符串或针对每次匹配执行的函数。并返回一个全新的字符串 1234const str = \"I wish to wish the wish you wish to wish, but if you wish the wish the witch wishes, I won't wish the wish you wish to wish. \";const newStr = str.replaceAll(\"wish\", \"miller\");console.log(newStr); 4.Promise.any只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。 5. WeakRef 在一般情况下，对象的引用是强引用的，这意味着只要持有对象的引用，它就不会被垃圾回收。只有当该对象没有任何的强引用时，垃圾回收才会销毁该对象并且回收该对象所占的内存空间。 而 WeakRef 允许您保留对另一个对象的弱引用，而不会阻止被弱引用对象被垃圾回收。 12let target = &#123;&#125;;let wr = new WeakRef(target); WeakRef 实例对象有一个deref()方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回undefined。 1234567let target = &#123;&#125;;let wr = new WeakRef(target);let obj = wr.deref();if (obj) &#123; // target 未被垃圾回收机制清除 // ...&#125; 12345678910111213let like = new WeakRef(document.getElementById(\"like\"))let mymap = new WeakMap()mymap.set(like.deref(), &#123; click: 0&#125;)like.deref().onclick = function () &#123; let times = mymap.get(like.deref()) times.click++&#125;setTimeout(() =&gt; &#123; document.body.removeChild(like.deref())&#125;, 2000) 6. FinalizationRegistry 清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。 首先，新建一个注册表实例。 123const registry = new FinalizationRegistry(data =&gt; &#123; // ....&#125;); 12registry.register(obj, \"some value\");registry.unregister(obj); 12345678910111213141516171819202122let like = new WeakRef(document.getElementById(\"like\"))let mymap = new WeakMap()mymap.set(like.deref(), &#123; click: 0&#125;)like.deref().onclick = function () &#123; let times = mymap.get(like.deref()) times.click++&#125;setTimeout(() =&gt; &#123; // registry.register(document.getElementById(\"like\"), mymap.get(like.deref())); registry.register(like.deref(), mymap.get(like.deref())); document.body.removeChild(like.deref())&#125;, 2000)const registry = new FinalizationRegistry(data =&gt; &#123; // .... console.log(\"被销毁了\", data)&#125;); 八.ES13新特性1. 私有属性和方法12345678910111213class Cache&#123; #obj =&#123;&#125; get(key)&#123; return this.#obj[key] &#125;set(key,value)&#123; this.#obj[key] =value&#125;&#125;let cache = new Cache()cache.set(\"name\",\"miller\") 2.静态成员的私有属性和方法 我们还可以给类定义静态成员和静态私有函数。类的静态方法可以使用this关键字访问其他的私有或者公有静态成员， 123456789101112131415161718192021 class Cache&#123; static #count = 0; static getCount()&#123; return this.#count &#125; #obj =&#123;&#125; get(key)&#123; return this.#obj[key] &#125; set(key,value)&#123; this.#obj[key] =value &#125;&#125;let cache = new Cache()cache.set(\"name\",\"miller\")console.log(Cache.getCount()) 3.静态代码块 ES13允许在类中通过static关键字定义一系列静态代码块，这些代码块只会在类被创造的时候执行一次。这其实有点像一些其他的如C#和Java等面向对象的编程语言的静态构造函数的用法。 一个类可以定义任意多的静态代码块，这些代码块会和穿插在它们之间的静态成员变量一起按照定义的顺序在类初始化的时候执行一次。我们还可以使用super关键字来访问父类的属性。 12345678910111213 class Cache&#123; static obj = new Map() static &#123; this.obj.set(\"name\",\"miller\") this.obj.set(\"age\",100) &#125; static&#123; console.log(this.obj) &#125;&#125;console.log(Cache.obj) 4. 使用in来判断某个对象是否拥有某个私有属性1234567891011121314151617class Cache &#123; #obj = &#123;&#125; get(key) &#123; return this.#obj[key] &#125; set(key, value) &#123; this.#obj[key] = value &#125; hasObj()&#123; return #obj in this &#125;&#125;let cache = new Cache()console.log(cache.hasObj()) 5.支持在最外层写await 顶层await只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的require()是同步加载，如果有顶层await，就没法处理加载了。 12345678910111213&lt;script type=\"module\"&gt; function ajax() &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"data-1111\"); &#125;, 1000); &#125;)&#125;let res = await ajax();console.log(res)&lt;/script&gt; 6. at函数来索引元素123456789let arr = [\"miller\",\"tiechui\",\"gangdan\",\"xiaoming\"]console.log(arr[1])console.log(arr[arr.length-1]) //变丑了console.log(arr[arr.length-2]) //变丑了console.log(arr.at(1))console.log(arr.at(-1))console.log(arr.at(-2)) 7. 正则匹配的开始和结束索引123456let str = \"今天是2022-11-10\"let reg = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/d//execlet res = reg.exec(str)console.log(res) image-20220927105243515 8.findLast()和findLastIndex()函数123456789101112131415let arr = [11,12,13,14,15]// let res = arr.find(function(value)&#123;// return value % 2 === 0// &#125;)// let res = arr.findIndex(function(value)&#123;// return value % 2 === 0// &#125;)// let res = arr.findLast(function(value)&#123;// return value % 2 === 0// &#125;)let res = arr.findLastIndex(function(value)&#123; return value % 2 === 0&#125;)console.log(res) 9.Error对象的Cause属性 Error对象多了一个cause属性来指明错误出现的原因。这个属性可以帮助我们为错误添加更多的上下文信息，从而帮助使用者们更好地定位错误。 123456789101112131415function getData()&#123; try&#123; console.log(miller) &#125; catch(e)&#123; throw new Error('New error 1111111',&#123;cause:\"这是因为,,,,,,,,,\"&#125;); &#125;&#125;try&#123; getData()&#125;catch(e)&#123; console.log(e.cause)&#125;","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"requestAnimationFrame","date":"2022-11-11T09:17:51.000Z","path":"2022/11/11/requestAnimationFrame/","text":"requestAnimationFrame requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘，让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。 在运行过程中，window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行 注意： 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()。","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"字符集与字符编码","date":"2022-11-05T02:47:04.000Z","path":"2022/11/05/字符集与字符编码/","text":"字符集与编码系列 字符集：要想在计算机中显示文字，必须把文字都收集起来放在一个表中，这个表叫字符集（Charset）。 码表：字符集中的每个文字，都分配一个数字号码，这叫码表（Code chart）。比如中文 ‘霸’字，在码表中对应的码是38712（十进制），或者9738（十六进制）。 编码方式：有了码表，就需要确定哪些文字用几个字节表示，以及如果有多个字节代表一个字，字节的读取顺序，这些就是字符编码方式（Encoding）。 虽然为了严谨起见，上面我把字符集和码表分开说明，但实际上很多字符集也给每个字符分配了一个码（Code Point），所以很多人经常也把字符集叫做码表、码表叫做字符集。","tags":[]},{"title":"技术管理-如何保持判断力","date":"2022-10-27T12:42:42.000Z","path":"2022/10/27/技术管理-如何保持判断力/","text":"如何保持判断力作为一个技术管理者，即技术应用者，要评估的维度主要是以下三个方面： 第一个维度是结果评估。即，你要回答“要不要做”，希望拿到什么结果，你要从哪几个维度去衡量结果，从哪几个技术指标去验收成果。 第二个维度是可行性评估。可行性有两层含义：一是“能不能做”，二是“值不值得”。 能不能和值不值得，是两码事。不懂技术的管理者一般问的都是“能不能做”，而有经验的技术管理者和资深工程师，考虑的是“值不值得”。 第三个评估维度，即风险评估。技术风险评估，也叫技术风险判断力。即，有哪些技术风险需要未雨绸缪，考虑该技术方案带来最大损失的可能性和边界，以及在什么情形下会发生。这项评估工作很考验技术管理者的技术经验和风险意识，而且需要借助全团队的技术力量来做出准确判断。","tags":[]},{"title":"Git","date":"2021-11-10T06:46:34.000Z","path":"2021/11/10/Git/","text":"一. 走入Git1.Git介绍 Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 版本控制 版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 团队协作 从单兵作战转换为团队开发。 2.Git对比SVN SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己的代码推送到中央服务器。集中式版本控制系统是必须联网才能工作。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上，可以离线工作。 3.Git安装 https://git-scm.com/ 下载好以后，直接双击进行安装就行 一直下一步就可以，安装再默认路径就行 安装完毕后检测一下安装是否成功 打开 cmd 窗口，输入指令检查 12# 检测 git 是否安装$ git --version 出现版本号，说明安装成功 安装完毕，接下来我们就可以开始使用了 二.Git常用命令1.设置用户签名 签名的作用就是用来标识用户，以区分不同的开发人员。 12 git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" 2.初始化本地库 我们希望一个文件夹被 git 管理的话，那么就要在一个文件夹下进行 git 初始化 找到一个希望被 git 管理的文件夹 在文件夹内单击鼠标右键，点开 Git Bash Here 输入指令 12# git 初始化的指令$ git init 然后文件夹内会多一个 .git 的文件夹（这个文件夹是一个隐藏文件夹） 这个时候，我的这个 git_demo 文件夹就被 git 管理了 git 不光管理这一个文件夹，包括所有的子文件夹和子文件都会被管理 注意： 只有当一个文件夹被 git 管理以后，我们才可以使用 git 的功能去做版本管理 也就是说，我们必须要把我们电脑中的某一个文件夹授权给 git git 才能对这个文件夹里面的内容进行各种操作 而 git init 就是在进行这个授权的操作 3.Git工作区、暂存区和版本库 image-20220907112424167 托管平台 局域网(内网) gitlab 公网（外网） gitlab github gitee 码云 4.git add 我们要放入暂存区，要使用 git add 指令 把单独一个文件放在暂存区 12# 把文件夹下的 index.txt 文本放在暂存区$ git add index.txt 把单独一个文件夹放在暂存区（暂存区不能存放空文件夹） 12# 把文件夹下的 ceshi文件夹 放在暂存区$ git add ceshi/ 把所有文件都放在暂存区 12345# 把文件夹下所有的内容都放在暂存区$ git add --all# git add --all 有一个简单的写法$ git add . 全部存放的时候使用上面两个指令哪个都行 5.git commit12# 把暂存区的内容放到历史区$ git commit -m \"我是第一个版本\" 我们使用 git log 这个指令查看版本信息 12# 查看当前历史区版本信息$ git log 我们使用 git reset --hard 版本编号 进行历史回退 123456# 回退到上一次提交的版本$ git reset --hard HEAD^# 回退到上上次提交的版本$ git reset --hard HEAD^^$ git reset --hard HEAD~2 6.git revert 与 git reset image-20220908075826032 git reset 是回滚到对应的commit-id，相当于是删除了commit-id以后的所有的提交，并且不会产生新的commit-id记录，如果要推送到远程服务器的话，需要强制推送-f git revert 是反做撤销其中的commit-id，然后重新生成一个commit-id。本身不会对其他的提交commit-id产生影响，如果要推送到远程服务器的话，就是普通的操作git push就好了 三. Git 分支1.初识分支 git 分支，就是我们自己把我们的整个文件夹分成一个一个独立的区域 比如我在开发 登录 功能的时候，可以放在 login 分支下进行开发 开发 列表 功能的时候，可以放在 list 分支下进行开发 大家互不干扰，每一个功能都是一个独立的功能分支 这样开发就会好很多 git 在初始化的时候，会自动生成一个分支，叫做 master 是表示主要分支的意思 我们就可以自己开辟出很多独立分支 2.创建分支 开辟一个分支使用 git branch 分支名称 指令 12# 开辟一个 login 分支$ git branch login 查看一下当前分支情况 12# 查看当前分支情况$ git branch 会看到，当前有两个分支了 一个是 master，一个是 login 前面有个 * 号，并且有高亮显示的，表示你当前所处的分支 3.切换分支 我们对 登录 功能的开发要移动到 login 分支去完成 我们切换所处分支使用 git checkout 分支名称 12# 切换到 login 分支$ git checkout login 然后我们在整个分支上进行 登录 功能的开发 开发完毕以后，我们就在当前分支上进行提交 提交以后我们进行分支切换 发现 master 上面还是最初始的状态 而 login 分支上有我们新写的 登录 功能的代码 我们按照分支把所有功能都开发完毕了以后 只要把所有代码都合并到 master 主分支上就行了 4.合并分支 git 的合并分支，只能是把别的分支的内容合并到自己的分支上 使用的指令是 git merge 12345# 切换到 master 分支$ git checkout master# 把 login 的内容合并到自己的分支$ git merge login 这个时候，我们刚才在 login 上开发的东西就都来到了 master 主分支上 如果是有多个分支的话，那么所有的最后都合并到 master 分支上的时候 我们的主分支上就有完整网站的所有页面 各个分支上都是单独的页面和功能 5.删除分支 这个时候我们开辟的分支就没有什么用了，就可以删除分支了 先切换到别的分支 使用指令 git branch -d 分支名称 来删除 12345# 先切换到别的分支$ git checkout master# 删除 login 分支$ git branch -d login 四.远程仓库 我们的所有内容已经全部保留在了本地历史区 理论上是不会丢失了 但是如果把文件夹删除了，还是没有了 所以我们要使用 git 把我们所有的内容推送到 github 上面保存起来 那么就本地文件夹就算删除了，那么远程上面还有一份，还可以拿回来使用 所以我们现在就要把本地内容推送到远程 这个时候我们接需要一个 github 的账号了 先去 github官网 注册一个账号 1.创建一个远程仓库 有了 github 账号以后 我们就登录 github 网站，开辟一个远程仓库 github 的远程也是以一个仓库一个仓库的形式来保存代码 我们可以在一个 github 上保存很多的项目 只要一个项目一个仓库就可以了 按照下面步骤开辟仓库 先点击新建仓库 2.添加仓库地址 接下来，要使用 git 上传代码了 我们先要告诉 git 上传到哪里 也就是给 git 添加一个上传的地址 我们还是来到我们的项目文件夹 使用 git remote add origin 仓库地址 来添加 123# 在项目文件夹下打开 git base# 添加仓库地址$ git remote add origin ********************* remote：远程的意思 add：添加的意思 origin：是一个变量名（就是指代后面一长串的地址） 3.git push 上传到哪里的地址我们已经添加好了 接下来就是上传内容了 上传要保证 历史区 里面有内容 上传的过程会把 历史区 里面所有的内容上传到远端 我们使用 git push 指令来上传 1234# 上传内容$ git push -u origin master# 表示把内容上传到 origin 这个地址# master 是上传到远程的 master 分支 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 第二次上传 第二次上传的时候，因为有刚才的记录，就不需要再写 origin 和 master 了 会默认传递到 origin 这个地址的 master 分支上 除非你要传递到别的分支上的时候再进行书写 12# 第二次上传$ git push 到这里，就完成了一次 git 推送 这个时候本地的文件夹就真的可以删除了 因为远程有一份我们的内容，本地的删除了，可以直接把远程的拉回来就行 4.git clone git 克隆是指把远程仓库里面的内容克隆一份到本地 可以克隆别人的 公开 的仓库，也可以克隆自己的仓库 克隆别人的仓库，我们只能拿下来用，修改后不能从新上传 克隆自己的仓库，我们修改后还可以再次上传更新 输入克隆指令 git clone 仓库地址 12# 直接克隆仓库$ git clone ************* 5.git pull 当人家的代码更新以后，你想获得最新的代码 我们不需要从新克隆 只要拉取一次代码就可以了 直接在项目文件夹里面使用指令下拉 12# 拉取远程最新代码$ git pull 这样一来，你本地的仓库就可远程的仓库同步了 五.VScode集成GitVSCode内置版本控制机制，并自带对Git和Github的支持，你也可以安装插件以支持其他控制软件，如SVN(需要先安装 SVN )等。 初始化 可视化界面管理项目 六. gitignore 在一些项目中，我们不想让本地仓库的所有文件都上传到远程仓库中，而是有选择的上传，比如：一些依赖文件（node_modules下的依赖）、bin 目录下的文件、测试文件等。一方面将一些依赖、测试文件都上传到远程传输量很大，另一方面，一些文件对于你这边是可用的，在另一个人那可能就不可用了，比如：本地配置文件。 空行不匹配任何文件； 如果本地仓库文件已被跟踪，那么即使在 .gitignore 中设置了忽略，也不起作用。 .gitignore 文件也会被上传的到远程仓库，所以，同一个仓库的人可以使用同一个.gitignore 文件。 1234567891011121314151617181920212223242526# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.# dependencies# #开头的便是注释# 忽略文件和目录/node_modules/.pnp.pnp.js# testing/coverage# production/build# misc.DS_Store.env.local.env.development.local.env.test.local.env.production.local# 使用通配符npm-debug.log*yarn-debug.log*yarn-error.log*","tags":[{"name":"git","slug":"git","permalink":"https://hanjinbao.cn/tags/git/"}]},{"title":"HTTP Cache","date":"2020-07-12T12:32:58.000Z","path":"2020/07/12/HTTP-Cache/","text":"简析强制缓存和协商缓存背景介绍 浏览器和服务器进行交互的过程， 时间开销的瓶颈往往出现在数据的传输的过程之中。 这个场景类似介于 A城 到 B城 之间只有一座 “通道” ， 每次想从A城 到 B城 ，必须按照人数交付高昂的路费， 那么如果要减少这种高昂的路费开销的话， 核心思想就是尽可能的减少通过这座 “通道” 的次数又或者减少通过这座通道的“人数”。基于这种理念，在 http协议的基础上， 提出了一种协议缓存， 这种协议缓存又可以细分为 强制缓存 和 协商缓存 两种，分别对应上述减少过桥次数和减少过桥人数的理念。 http缓存机制简介强制缓存 强制缓存的思想是，在浏览器内置数据库中缓存每次请求中 “可以被缓存” （受到一些关键字的管控）的静态资源如 image, css, js 文件， 当第二次请求被缓存过的资源时候，会通过校验两个字段 Expires 和 Cache-Control 的max-age字段（注意，Expires 是 http1.0 的产物， Cache-Control 则是 http1.1 的产物。 两者同时存在， 或者只存在其中之一， 都可以触发强制缓存） 当满足字段约束的情况下， 浏览器就不会向服务器发送请求而是直接从服务器返回数据， 同时其状态码为 200 当不满足字段约束的情况下， 浏览器则会向服务器正常发送请求 强制缓存主要取决于两个字段 Expires 和 Cache-Control 中的 max-age 字段， 在两个响应头都存在的情况下， Cache-Control 中的 max-age 字段字段优先级会稍微高一点， 当 Cache-Control 中的 max-age 字段校验成功，会直接返回浏览器内置数据库的缓存， 失效时才会将决策权传递给 Expires 字段判断。 这样设计的原因，大概是因为 Expires 字段在设计时存在了这么一个缺陷——Expires字段返回的是服务器的时间， 而非客户端的本机时间。 当存在时差， 或者客户修改本地时间的情况下 Expires 字段会存在失效的可能性，比如 当同一时刻下的服务器时间为 2022/4/26 06:00:00 客户端时间为 2022/4/26 12:00:00 过期时间为两个小时之后， 则服务器会返回 2022/4/26 08:00:00 这个时间对应的值。由于浏览器运行在客户环境下，对于客户而言， 这个缓存已经过期了，虽然缓存确实有效， 但是对于浏览器而言这个缓存确确实实是 “过期了”， 这会导致强制缓存永远不会生效！ 那么为了解决这个问题， http 1.1 协议中添加了 Cache-Control 中的 max-age， 他是一个相对值， 即客户端获取到这个文件多少秒后失效， 其判别权力全权交由浏览器， 这会相对更准确些。 协商缓存 协商缓存主要由 ETag 和 Last-Modified 两个字段来实现 ETag 是一个用于映射 web 资源的映射 token，这个 token 应该满足唯一对应到一 个web服务器上的静态资源（具体实现通常是提取文件相关信息进行hash和base64编码等操作） Last-Modified 则通常是文件最后更新的日期时间戳 （通过上述两个字段就可以判断当前文件是否是最新的数据） 与上述两个字段配对的分别是 If-None-Match 和 If-Modified-Since 这两个字段 浏览器首次向服务器请求数据 A， 服务器正常返回数据，同时在响应头中放入 ETag 和 Last-Modified 两个新字段。 当浏览器第二次向服务器请求数据 A 时， 浏览器会自动地在请求头附上 If-None-Match 和 If-Modified-Since 两个字段（分别对应的是 ETag 和 Last-Modified 的值，两两相等）， 然后由服务器端进行校验， 校验通过的话（表明数据有效）， 服务器会直接返回 状态码 304 ，且不携带响应体的报文段， 这相当于告诉浏览器：当前缓存有效， 可以直接使用！ 校验失败则会和首次请求一样， 返回状态码为200且携带数据响应体的报文段， 同时这个响应头会带上新的ETag 和Last-Modified， 为下一次协商缓存做好铺垫 。 注意， 在不用框架的情况下， 协商缓存需要由后端开发人员手动实现，因此 ETag 和 Last-Modified 两个字段的优先级取决于开发者， 但是 Last-Modified 这个字段可以记录的时间戳精确度是有一定限制的，如果连续多次数据更新在精确度范围外， 会产生精确度丢失， 因此通常会让ETag 的优先级高于 Last-Modified 字段（类似于Cache-control中max-age一样， 属于是后续改进协议的一个新字段， 因此优先级一般会高点） 强制缓存 + 协商缓存 默认情况下， 浏览器会优先考量强制缓存的情况， 当强制缓存生效的情况下， 请求并不会到达服务器， 因此也就不会触发协商缓存。 当强制缓存失效的时候， 浏览器便会将请求传递到服务器， 于是服务器又会开始校验 If-Modified-Since 和 If-None-math 两个字段， 重复上述协商缓存的一个执行流程 乍一看，两者并存的情况， 有点像是两个协议的简单叠加，此时的协商缓存更像是强制缓存的兜底策略， 很可能协商缓存很长一段时间都不会生效（强制缓存过期时间设置过长的情况下）， 因为强制缓存的优先级是要高于协商缓存的。 当然这并不是我们想看到的， 比方说当后端数据确实变更了， 而此时的浏览器由于使用了强制缓存，则会出现数据不一致的情况， 因此在这里引入了请求头中的两个字段 no-cache， 当使用了 no-cache 字段的时候， 浏览器将不再使用强制缓存， 而是直接去请求服务器， 这个时候就会用到协商缓存了（顺带一提的是， 还有一个 no-store 字段， 用了这个字段浏览器则不会在使用缓存的数据也不缓存数据，即强制缓存和协商缓存都失效了） 缓存机制之间的一些区别 强制缓存在缓存有效的情况下不会去请求服务器， 其数据来源则是浏览缓存的本地磁盘。而协商缓存会向服务器请求，但是在协商缓存成功的情况下， 服务器只会返回一个不带响应体的报文，结合开头的背景来说 强制缓存选择“减少过桥次数”的策略， 而协商缓存则是采用 ‘减少过桥人数’的策略 强制缓存在浏览器强制刷新的情况下不会生效， 而协商缓存则不受影响。（调试代码测试时候，要注意） 强制缓存返回的报文状态码为 200， 协商缓存返回的报文状态码为 304 （前端使用fetch请求的情况， 协商缓存的 状态码304 会转成 200） 强制缓存发生在浏览器端， 协商缓存发生在服务器端 使用小结 强制缓存和协商缓存需要具体条件下来用 强制缓存存在一个瓶颈， 当浏览器用户强刷新时，浏览器会直接跳过强制缓存， 这点不注意很容易会被忽视掉。 强制缓存不适合 SPA 应用的入口文件， 因为重新部署后， 用户如果没有强制刷新， 则无法在第一时间内看到新的网页内容。 作为一个前端开发者可以通过设置请求头中的 no-cache 和 no-store 字段选择使用协商缓存或者不使用缓存！！！","tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://hanjinbao.cn/tags/浏览器/"},{"name":"缓存","slug":"缓存","permalink":"https://hanjinbao.cn/tags/缓存/"}]},{"title":"标签marquee","date":"2018-04-10T08:36:59.000Z","path":"2018/04/10/标签marquee/","text":"HTML marquee 元素 （用来插入一段滚动的文字。你可以使用它的属性控制当文本到达容器边缘发生的事情。） 使用marquee标记不仅可以移动文字，也可以移动图片，表格等. 语法： 1&lt;marquee&gt;...&lt;/marquee&gt; 说明：在标记之间添加要进行滚动的内容。 重要属性： 滚动方向direction（设置 marquee 内文本滚动的方向。可选值有 left, right, up and down。如果未指定值，默认值为 left。） + 语法： 1&lt;marquee direction=&quot;滚动方向&quot;&gt;...&lt;/marquee&gt; 滚动方式behavior（scroll:循环滚动，默认效果； slide:只滚动一次就停止； alternate:来回交替进行滚动） + 语法： 1&lt;marquee behavior=&quot;滚动方式&quot;&gt;...&lt;/marquee&gt; 滚动速度scrollamount（设置每次滚动时移动的长度（以像素为单位）。默认值为 6。） + 语法： 1&lt;marquee scrollamount=&quot;5&quot;&gt;...&lt;/marquee&gt; 滚动延迟scrolldelay（设置每次滚动时的时间间隔（以毫秒为单位）。默认值为 85。请注意， 除非指定 truespeed 值，否则将忽略任何小于 60 的值，并改为使用 60。） +语法： 1&lt;marquee scrolldelay=&quot;100&quot;&gt;...&lt;/marquee&gt; 滚动循环loop（设置 marquee 滚动的次数。如果未指定值，默认值为 −1，表示 marquee 将连续滚动.） + 语法： 1&lt;marquee loop=&quot;2&quot;&gt;...&lt;/marquee&gt; 滚动范围width、height 滚动背景颜色bgcolor 空白空间hspace、vspace eg12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; charset=utf-8&quot; /&gt; &lt;title&gt;marquee&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;marquee direction=&quot;up&quot; behavior=&quot;alternate&quot; scrollamount=&quot;5&quot; scrolldelay=&quot;0&quot; loop=&quot;-1&quot; width=&quot;1000&quot; height=&quot;50&quot; bgcolor=&quot;#0099FF&quot; hspace=&quot;10&quot; vspace=&quot;10&quot;&gt; up:Marquee对齐方式; scroll:设置滚动的方式; scrollamount:设置每次滚动时移动的长度（以像素为单位）。默认值为 6; &lt;/marquee&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ### 官方建议不使用 — &lt;marquee&gt; 元素已经 过时，请不要再使用。尽管一些浏览器仍然支持它，但它不是必须的。此外，使用这个元素基本上是你可以对你的用户做最糟糕的事情之一，所以请不要这样做。","tags":[{"name":"html","slug":"html","permalink":"https://hanjinbao.cn/tags/html/"}]},{"title":"数组filter方法","date":"2018-04-07T02:30:29.000Z","path":"2018/04/07/数组filter方法/","text":"JavaScript Array filter() 方法定义和用法 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意： filter() 不会对空数组进行检测。 注意： filter() 不会改变原始数组。 语法 1array.filter(function(value,index,arr), thisValue) eg 1234567var arr = [ &#123; id: 1, text: &apos;aa&apos;, done: true &#125;, &#123; id: 2, text: &apos;bb&apos;, done: false &#125;]console.log(arr.filter(function (item) &#123; return item.done;&#125;)) 返回一个新数组，打印的值 [{ id: 1, text: ‘aa’, done: true }] 新数组中的值为return true的value。return后面判断结果，取布尔值，true的话就添入新的filter数组中，false的话，不会添进filter的数组中 兼容性 兼容主流浏览器，其中IE9/IE9+","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"vue-11","date":"2018-03-15T12:12:31.000Z","path":"2018/03/15/vue-11/","text":"路由简单路由实现： 引入vue-router，如果是在脚手架中，引入VueRouter之后，需要通过Vue.use来注册插件 123import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router) 创建router路由器 1new Router(options) 创建路由表并配置在路由器中 1234567var routes = [ &#123;path,component&#125;//path为路径，component为路径对应的路由组件]new Router(&#123; routes&#125;) 在根实例里注入router,目的是为了让所有的组件里都能通过this.$router、this.$route来使用路由的相关功能api 123456new Vue(&#123;el: &apos;#app&apos;,router,template: &apos;&lt;App/&gt;&apos;,components: &#123; App &#125;&#125;) 利用router-view来指定路由切换的位置 使用router-link来创建切换的工具，会渲染成a标签，添加to属性来设置要更改的path信息，且会根据当前路由的变化为a标签添加对应的router-link-active/router-link-exact-active（完全匹配成功）类名 123456&lt;router-link to=&quot;main&quot;&gt;main&lt;/router-link&gt;&lt;router-link to=&quot;news&quot;&gt;news&lt;/router-link&gt;.router-link-active&#123; color:red;&#125; 多级路由:在创建路由表的时候，可以为每一个路由对象创建children属性，值为数组，在这个里面又可以配置一些路由对象来使用多级路由，注意：一级路由path前加’/‘ 1234567const routes = [ &#123;path:&apos;/main&apos;,component:AppMain&#125;, &#123;path:&apos;/news&apos;,component:AppNews,children:[ &#123;path:&apos;inside&apos;,component:AppNewsInside&#125;, &#123;path:&apos;outside&apos;,component:AppNewsOutside&#125; ]&#125;,] 二级路由组件的切换位置依然由router-view来指定（指定在父级路由组件的模板中） 1234&lt;router-link to=&apos;inside&apos;&gt;inside&lt;/router-link&gt;&lt;router-link to=&apos;outside&apos;&gt;outside&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 默认路由和重定向：当我们进入应用，默认像显示某一个路由组件，或者当我们进入某一级路由组件的时候想默认显示其某一个子路由组件，我们可以配置默认路由：1&#123;path:&apos;&apos;,component:Main&#125; 当我们需要进入之后进行重定向到其他路由的时候，或者当url与路由表不匹配的时候：123&#123;path:&apos;&apos;,redirect:&apos;/main&apos;&#125;///...放在最下面&#123;path:&apos;**&apos;,redirect:&apos;/main&apos;&#125;, 命名路由我们可以给路由对象配置name属性，这样的话，我们在跳转的时候直接写name:main就会快速的找到此name属性对应的路由，不需要写大量的urlpath路径了 动态路由匹配有的时候我们需要在路由跳转的时候跟上参数，路由传参的参数主要有两种：路径参数、queryString参数 路由参数需要在路由表里设置 1&#123;path:&apos;/user/:id&apos;,component:User&#125; 上面的代码就是给User路由配置接收id的参数，多个参数继续在后面设置 在组件中可以通过this.$route.params来使用 queryString参数不需要在路由表设置接收，直接设置？后面的内容，在路由组件中通过this.$route.query接收 router-link 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 标签，可以通过配置 tag 属性生成别的标签.。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。 router-link的to属性，默认写的是path（路由的路径），可以通过设置一个对象，来匹配更多1:to=&apos;&#123;name:&quot;detail&quot;,params:&#123;id:_new.id&#125;,query:&#123;content:_new.content&#125;&#125;&apos; name是要跳转的路由的名字，也可以写path来指定路径，但是用path的时候就不能使用params传参，params是传路径参数，query传queryString参数 replace属性可以控制router-link的跳转不被记录\\ active-class属性可以控制路径切换的时候对应的router-link渲染的dom添加的类名 编程式导航有的时候需要在跳转前进行一些动作，router-link直接跳转，需要在方法里使用$router的方法 router.push = router-link:torouter.replace = router-link:to.replacerouter.go() = window.history.go 路由模式路由有两种模式：hash、history，默认会使用hash模式，但是如果url里不想出现丑陋hash值，在new VueRouter的时候配置mode值为history来改变路由模式，本质使用H5的histroy.pushState方法来更改url，不会引起刷新，但是需要后端进行路由的配置 路由钩子在某些情况下，当路由跳转前或跳转后、进入、离开某一个路由前、后，需要做某些操作，就可以使用路由钩子来监听路由的变化 全局路由钩子：123456789101112router.beforeEach((to, from, next) =&gt; &#123; //会在任意路由跳转前执行，next一定要记着执行，不然路由不能跳转了 console.log(&apos;beforeEach&apos;) console.log(to,from) // next()&#125;)//router.afterEach((to, from) =&gt; &#123; //会在任意路由跳转后执行 console.log(&apos;afterEach&apos;)&#125;) 单个路由钩子：只有beforeEnter，在进入前执行，to参数就是当前路由123456789routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ] 路由组件钩子：123456789101112131415beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建&#125;,beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this`&#125;,beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this`&#125; 命名视图有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。123&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置（带上 s）：123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default: Foo,//默认的，没有name的router-view a: Bar, b: Baz &#125; &#125; ]&#125;) prop将路由与组件解耦在组件中接收路由参数需要this.$route.params.id,代码冗余，现在可以在路由表里配置props：true1&#123;path:&apos;detail/:id&apos;,component:AppNewsDetail,name:&apos;detail&apos;,props:true&#125; 在路由自己中可以通过props接收id参数去使用了 props:[‘id’]","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-10","date":"2018-01-30T11:16:51.000Z","path":"2018/01/30/vue-10/","text":"钩子函数、vue-cli脚手架组件的生命周期每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁 生命周期图示 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载ね，只是一个空壳，无法访问到数据和真实的dom，一般不做操作 挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情… 当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿 当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom 当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等 组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以 vue-cli脚手架现在使用前端工程化开发项目是主流的趋势，也就是说，我们需要使用一些工具来搭建vue的开发环境，一般情况下我们使用webpack来搭建，在这里我们直接使用vue官方提供的，基于webpack的脚手架工具：vue-cli 安装方法： 123456789# 全局安装 vue-clinpm install --global vue-cli# 创建一个基于 webpack 模板的新项目vue init webpack my-project//init之后可以定义模板的类型# 安装依赖，走你cd my-projectnpm installnpm run dev 模板类型： simple 对应的是一个超级简单的html文件 webpack 在配置的时候可以选择是否需要vue-router 注意的是，模板创建的时候会询问使用需要使用ESLINT来标准化我们的代码 在脚手架中，开发目录是src文件夹，build负责打包的，config是负责配置（内置服务器的端口、proxy代理），static是静态目录，test是测试 src中main.js是入口文件，在里面创建了一个根实例，根实例的模板就是根组件App的模板，其他的组件都在根组件里面进行嵌套实现。 每一个组件都是一个单文件组件，这种文件会被webpack利用vue-loader的工具进行编译 template部分负责写组件的模板内容，script中创建组件。style里写组件的样式 assets目录也是静态目录，在这个目标中的文件我们使用相对路径引入,而static目录中的文件使用绝对地址来引入 在style上添加scoped能使这个style里的样式只作用于当前的组件，不加scoped就是全局样式 习惯于在App.vue根组件的style里写全局样式，而每个组件的style最好都是局部的 配置sass编译环境 vue-cli没有内置sass编译，我们需要自己修改配置 下载对应工具：node-sass(4.0.0) sass-loader 在build目录下的webpack.base.conf.js中的module.rule里添加如下配置 1234&#123; test: /\\.scss$/, loader:&apos;style-loader!css-loader!sass-loader&apos;&#125; 在需要使用scss代码的组件的style标签中添加 lang=’scss’","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-9","date":"2018-01-18T01:13:55.000Z","path":"2018/01/18/vue-9/","text":"slot-transition-渲染函数和jsxslotvue里提供了一种将父组件的内容和子组件的模板整合的方法：内容分发，通过slot插槽来实现 匿名插槽123&lt;aaa&gt;abc&lt;/aaa&gt;template:&quot;&lt;h1&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/h1&gt;&quot; 在父组件中使用子组件的时候，在子组件标签内部写的内容，在子组件的模板中可以通过来使用 具名插槽 父组件在子组件标签内写的多个内容我们可以给其设置slot属性来命名，在子组件的模板通过通过使用带有name属性的slot标签来放置对应的slot，当slot不存在的时候，slot标签内写的内容就出现12345&lt;my-button&gt;提交&lt;/my-button&gt;&lt;my-button&gt;重置&lt;/my-button&gt;&lt;my-button&gt;&lt;/my-button&gt;template:&quot;&lt;button&gt;&lt;slot&gt;按钮&lt;/slot&gt;&lt;/button&gt;&quot; transitionVue提供了transition组件来帮助我们实现过渡效果，依据就是在控制元素显示隐藏的时候为dom在指定的时刻添加上对应的类名 而我们只要在这些类名里写上对应的css样式 在进入/离开的过渡中，会有 6 个 class 切换(v代表的是transition的name属性的值)。 v-enter：定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。 v-enter-active：定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效 (于此同时 v-enter 被删除)，在 transition/animation 完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。 v-leave-active：定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效 (于此同时 v-leave 被删除)，在 transition/animation 完成之后移除。 className 如果有多个元素需要用transition-group包裹，并且需要有key值做标记 animate.css: 引入animate.css之后，按照下面的写法：12345&lt;transition leave-active-class=&quot;animated fadeOut&quot; enter-active-class=&quot;animated slideInLeft&quot;&gt; &lt;p v-if=&quot;isShow&quot; class=&quot;box&quot;&gt;&lt;/p&gt;&lt;/transition&gt; 渲染函数和jsx在vue中我们可以不用template来指定组件的模板，而是用render函数来创建虚拟dom结构，用这种方法优点就是性能高，缺点就是使用成本高，代码可读性较低，可以使用jsx来在render函数中创建，这样既提高了性能，又减少了成本 但是，我们在使用了vue-cli脚手架之后，因为脚手架中有对template标签转换虚拟dom的处理，所以，不需要使用jsx，我们也能高效的转换为createElement形式","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-8","date":"2017-10-24T12:43:04.000Z","path":"2017/10/24/vue-8/","text":"组件间通信prop 传递数据组件实例的作用域是孤立的,父组件不能直接使用子组件的数据，子组件也不能直接使用父组件的数据 父组件在模板中使用子组件的时候可以给子组件传递数据 1&lt;bbb money=&quot;2&quot;&gt;&lt;/bbb&gt; 子组件需要通过props属性来接收后才能使用 12&apos;bbb&apos;:&#123; props:[&apos;money&apos;] 如果父组件传递属性给子组件的时候键名有’-‘，子组件接收的时候写成小驼峰的模式123&lt;bbb clothes-logo=&apos;amani&apos; clothes-price=&quot;16.58&quot;&gt;&lt;/bbb&gt;////props:[&apos;clothesLogo&apos;,&apos;clothesPrice&apos;] 我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件 单向数据流Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。 另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。 在两种情况下，我们很容易忍不住想去修改 prop 中数据： Prop 作为初始值传入后，子组件想把它当作局部数据来用； Prop 作为原始数据传入，由子组件处理成其它数据输出。对这两种情况，正确的应对方式是： 定义一个局部变量，并用 prop 的值初始化它：1234567891011props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125;//定义一个计算属性，处理 prop 的值并返回：props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 prop验证我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用 验证主要分为：类型验证、必传验证、默认值设置、自定义验证 1234567891011121314151617181920212223242526props:&#123; //类型验证: str:String, strs:[String,Number], //必传验证 num:&#123; type:Number, required:true &#125;, //默认数据 bool:&#123; type:Boolean, // default:true, default:function()&#123; return true &#125; &#125;, //自定义验证函数 nums:&#123; type:Number, validator: function (value) &#123; return value %2 == 0 &#125; &#125;&#125; 当父组件传递数据给子组件的时候，子组件不接收，这个数据就会挂载在子组件的模板的根节点上","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"时间戳——>时间","date":"2017-09-10T03:55:12.000Z","path":"2017/09/10/时间戳——-时间/","text":"时间戳- 时间戳 --&gt; 日期 yyyy-mm-dd hh:mm:ss 1234567891011function formatDate(ns)&#123; if(ns==0 || isNaN(ns)) &#123; return &apos;&apos; &#125; var date = new Date(parseInt(ns) * 1000); Y = date.getFullYear() + &apos;-&apos;; M = (date.getMonth()+1 &lt; 10 ? &apos;0&apos;+(date.getMonth()+1) : date.getMonth()+1) + &apos;-&apos;; D = (date.getDate() &lt; 10 ? &apos;0&apos;+ date.getDate() : date.getDate())+ &apos; &apos;; h = (date.getHours() &lt; 10 ? &apos;0&apos;+ date.getHours() : date.getHours()) + &apos;:&apos;; m = (date.getMinutes() &lt; 10 ? &apos;0&apos;+ date.getMinutes() : date.getMinutes()) + &apos;:&apos;; s = (date.getSeconds() &lt; 10 ? &apos;0&apos;+ date.getSeconds() : date.getSeconds()); return Y+M+D+h+m+s;&#125; + 如果 ns是13位数，那么就不用 *1000 。","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"vue-7","date":"2017-08-20T04:04:09.000Z","path":"2017/08/20/vue-7/","text":"虚拟dom以及组件化虚拟dom频繁且复杂的dom操作通常是前端性能瓶颈的产生点，Vue提供了虚拟dom的解决办法 虚拟的DOM的核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作。这句话，也许过于抽象，却基本概况了虚拟DOM的设计思想 (1) 提供一种方便的工具，使得开发效率得到保证(2) 保证最小化的DOM操作，使得执行效率得到保证 也就是说，虚拟dom的框架/工具都是这么做的： 根据现有的真实dom来生成一个完整的虚拟dom树结构 当数据变化，或者说是页面需要重新渲染的时候，会重新生成一个新的完整的虚拟dom 拿新的虚拟dom来和旧的虚拟dom做对比（使用diff算法），。得到需要更新的地方之后，更新内容 这样的话，就能大量减少真实dom的操作,提高性能 组件化模块化就是将系统功能分离成独立的功能部分的方法，一般指的是单个的某一种东西，例如js、css 而组件化针对的是页面中的整个完整的功能模块划分，组件是一个html、css、js、image等外链资源，这些部分组成的一个聚合体 优点：代码复用，便于维护 划分组件的原则：复用率高的，独立性强的 组件应该拥有的特性：可组合，可重用，可测试，可维护 组件在vue中，我们通过Vue.extend来创建Vue的子类，这个东西其实就是组件 也就是说Vue实例和组件的实例有差别但是差别不带，因为毕竟一个是父类一个是子类 一般的应用，会拥有一个根实例，在根实例里面都是一个一个的组件 因为组件是要嵌入到实例或者父组件里的，也就是说，组件可以互相嵌套，而且，所有的组件最外层必须有一个根实例，所以组件分为：全局组件和局部组件 全局组件在任意的实例、父级组件中都能使用，局部组件只能在创建自己的父级组件或者实例中使用 组件通过不同的注册方法成为全局、局部组件 创建组件：1Vue.extend(options) 全局注册：1234var App = Vue.extend(&#123; template:&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;&#125;)Vue.component(&apos;my-app&apos;,App) 简便写法：1234// 创建组件构造器和注册组件合并一起 Vue.component(&apos;hello&apos;,&#123;//Vue会自动的将此对象给Vue.extend template:&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot; &#125;) 组件通过template来确定自己的模板,template里的模板必须有根节点，标签必须闭合 组件的属性挂载通过：data方法来返回一个对象作为组件的属性，这样做的目的是为了每一个组件实例都拥有独立的data属性 局部注册： 123456new Vue(&#123; el:&quot;#app&quot;, components:&#123; &apos;my-app&apos;:App &#125;&#125;) 简便写法： 123456data:&#123;&#125;,components:&#123; &apos;hello&apos;:&#123; template:&quot;&lt;h1&gt;asdasdasdasdasdas&lt;/h1&gt;&quot; &#125;&#125; 在实例或者组件中注册另一个组件，这个时候，被注册的组件只能在注册它的实例或组件的模板中使用，一个组件可以被多个组件或实例注册 注意浏览器规则因为vue在解析模板的时候会根据某些html的规则，例如，在table里只能放tr,td,th..，如果放入组件不会解析 这个时候我们可以放入tr使用is方式来标识这个tr其实是组件 123&lt;table id=&quot;app&quot;&gt; &lt;tr is=&quot;hello&quot;&gt;&lt;/tr&gt;&lt;/table&gt; template我们可以在html的某个地方通过template标签来定义组件的模板，在组件的template属性中通过选择器指定对应的template标签内容就可以了,注意，需要给template标签加id来指定12345678&lt;template id=&quot;my-hello&quot;&gt; &lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;p&gt;hahahah&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;//组件中template:&quot;#my-hello&quot; is切换在实例、组件的模板中的某一个标签上，可以通过is属性来指定为另一个目标的组件，这个时候我们一般会使用component标签来占位、设置is属性来指定目标组件12345678910&lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;//组件中data:&#123; type:&apos;aaa&apos;&#125;,components:&#123; &apos;aaa&apos;:&#123;template:&quot;&lt;h1&gt;AAAAAAAAAAAAA&lt;/h1&gt;&quot;&#125;, &apos;bbb&apos;:&#123;template:&quot;&lt;h1&gt;BBBBBBBBBBBBB&lt;/h1&gt;&quot;&#125;&#125; 组件嵌套应用中划分的组件可能会很多，为了更好的实现代码复用，所以必然会存在组件的嵌套关系 组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-6","date":"2017-08-09T13:06:56.000Z","path":"2017/08/09/vue-6/","text":"mixin 这个方式 还未深入了解 在Vue中，我们可以通过定义多个mixin来实现代码抽离复用，便于维护，提升页面的逻辑性 要注意的是：data属性不要使用mixin，因为从逻辑上来说，每一个实例、组件的数据都应该是独立的 一个mixin其实就是一个纯粹的对象，上面挂载着抽离出来的配置，在某一个实例中，通过mixins选项（数组）导入后，此实例就拥有导入的mixin的配置 且导入的配置不会覆盖原有的，而是合并到一起","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-5","date":"2017-07-23T09:29:45.000Z","path":"2017/07/23/vue-5/","text":"过滤器 条件渲染过滤器vue中可以设置filter(过滤器)来实现数据格式化，双花括号插值和 v-bind 表达式中使用 vue1.0的有默认的过滤器，但是在2.0的时候全部给去掉了 所以在vue中如果想要使用过滤器就需要自定义 自定义的方法有两种：全局定义和局部定义，全局定义的过滤器在任意的实例、组件中都可以使用，局部定义就是在实例、组件中定义，只能在这个实例或组件中使用 全局定义 Vue.filter(name,handler) name是过滤器的名字，handler是数据格式化处理函数，接收的第一个参数就是要处理的数据，返回什么数据，格式化的结果就是什么 在模板中通过 | (管道符) 来使用,在过滤器名字后面加（）来传参，参数会在handler函数中第二个及后面的形参来接收 123456&lt;p&gt;&#123;&#123;msg | firstUpper(3,2)&#125;&#125;&lt;/p&gt;Vue.filter(&apos;firstUpper&apos;,function (value,num=1,num2) &#123; console.log(num2) return value.substr(0,num).toUpperCase()+value.substr(num).toLowerCase()&#125;) 局部定义 在实例、组件的配置项中设置 filters，键名为过滤器名，值为handler 123456filters:&#123; firstUpper:function (value,num=1,num2) &#123; console.log(num2) return value.substr(0,num).toUpperCase()+value.substr(num).toLowerCase() &#125;&#125; 注意： 过滤器只能在mustache插值、v-bind里使用，其他的指令等地方都不能用 条件渲染在Vue中可以使用v-if来控制模板里元素的显示和隐藏，值为true就显示，为false就隐藏 v-if控制的是是否渲染这个节点 当我们需要控制一组元素显示隐藏的时候，可以用template标签将其包裹，将指令设置在template上，等等vm渲染这一组元素的时候，不会渲染template 当有else分支逻辑的时候，可以给该元素加上v-else指令来控制，v-else会根据上面的那个v-if来控制，效果与v-if相反，注意，一定要紧挨着 还有v-else-if指令可以实现多分支逻辑 1234567891011121314151617&lt;input type=&quot;text&quot; v-model=&quot;mode&quot;&gt; &lt;template v-if=&quot;mode==&apos;A&apos;&quot;&gt; &lt;h1&gt;1.title&lt;/h1&gt; &lt;p&gt;我的第一个P标签&lt;/p&gt; &lt;/template&gt; &lt;template v-else-if=&quot;mode==&apos;B&apos;&quot;&gt; &lt;h1&gt;2.title&lt;/h1&gt; &lt;p&gt;我的第二个P标签&lt;/p&gt; &lt;/template&gt; &lt;template v-else-if=&quot;mode==&apos;C&apos;&quot;&gt; &lt;h1&gt;3.title&lt;/h1&gt; &lt;p&gt;我的第三个P标签&lt;/p&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;p&gt;不好意思，输入有误&lt;/p&gt; &lt;/template&gt; 需要注意的另一个地方是：Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这样确实能使Vue变得更快，性能更高，但是有的时候我们需要让实例去更新dom而不是复用，就需要给dom加上不同的key属性，因为vue在判断到底渲染什么的时候，包括哪些dom可以复用，都会参考key值，如果dom表现基本一致，符合复用的条件，但是key值不同，依然不会复用 Vue还提供了v-show指令，用法和v-if基本一样，控制的是元素的css中display属性，从而控制元素的显示和隐藏 ， 不能和v-else配合使用,且不能使用在template标签上，因为template不会渲染，再更改它的css属性也不会渲染，不会生效 v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-4","date":"2017-06-13T01:19:45.000Z","path":"2017/06/13/vue-4/","text":"计算属性、监听计算属性、监听有的时候我们需要在模板中使用数据a，这个时候就需要用到表达式，但是有的地方我们需要对a数据进行一些简单的处理后才能使用，那么我们就会在表达式中写一些js逻辑运算 123&lt;div id=&quot;example&quot;&gt;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/div&gt; 这样我们的维护就会非常困难，也不便于阅读 那め我们就可以在methods里设置一个方法，在模板的表达式中使用这个方法 1234567&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;// 在组件中methods: &#123;reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;&#125; 但是这个时候，只要vm中有数据变化，这个变化的数据可能和我们关注的数据无关，但是vm都会重新渲染模板，这个时候表达式中的方法就会重新执行，大大的影响性能 这个时候其实我们可以使用监听器里完成： 在vm实例中设置watch属性，在里面通过键值对来设置一些监听，键名为数据名，值可以是一个函数，这个函数在数据改变之后才会执行，两个参数分别是性格前的值和更改后的值 123a: function (val, oldVal) &#123; console.log(&apos;new: %s, old: %s&apos;, val, oldVal)&#125; 值还可以是一个方法名字，当数据改变的时候这个方法会执行 当数据为object的时候，object的键值对改变不会被监听到（数组的push等方法可以）,这个时候需要设置深度监听： 123456c: &#123; deep:true, handler:function (val, oldVal) &#123; console.log(&apos;new: %s, old: %s&apos;, val, oldVal) &#125;&#125;, 监听的handler函数前面的这几种写法都是在数据变化的时候才会执行，初始化的时候不会执行，但是如果设置immediate为true就可以了 123456num:&#123; immediate:true, handler:function(val)&#123; this.nums = val*2 &#125;&#125; 我们在回到上面的问题，用监听器加上immediate属性就可以做到该效果，但是大家可以看到的是逻辑稍稍有点复杂 watch还可以通过实例对象直接使用:vm.$watch，返回一个取消监听的函数，这个函数执行之后会取消监听 我们一般都会用到一个叫计算属性的东西来解决： 计算属性就是在实例配置项中通过computed来为vm设置一个新的数据，而这个新数据会拥有一个依赖（一条已经存在的数据），当依赖发送变化的时候，新数据也会发送变化 与方法的方式相比，它性能更高，计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 与watch相比，写起来简单，逻辑性更清晰，watch一般多用于，根据数据的变化而执行某些动作，而至于这些动作是在干什么其实无所谓，而计算属性更有针对性，根据数据变化而更改另一个数据 计算属性也拥有getter和setter，默认写的是getter，设置setter执行可以当此计算属性数据更改的时候去做其他的一些事情，相当于watch这个计算属性 xm:{ get:function(){//getter 当依赖改变后设置值的时候 return this.xing+&apos;丶&apos;+this.ming }, set:function(val){//setter 当自身改变后执行 this.xing = val.split(&apos;丶&apos;)[0] this.ming = val.split(&apos;丶&apos;)[1] } }","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-3","date":"2017-06-08T02:44:56.000Z","path":"2017/06/08/vue-3/","text":"vue 数据改变 重新渲染问题 当无关数据进行改变时，Vue根元素内部还会渲染解决办法：watch监听、计算属性 123456789101112131415161718192021222324例：button @click=&quot;a++&quot; button&#123;&#123;a&#125;&#125;&#123;&#123;ab()&#125;&#125;input type=&quot;text&quot; v-model=&quot;message&quot; name=&quot;&quot;&#123;&#123;message&#125;&#125;data: &#123; a: 1, b: null, message: &apos;&apos; &#125;, methods: &#123; ab: function()&#123; return this.a*2 + 1; &#125; &#125;, watch: &#123; a: function(val,oldval)&#123; console.log(&apos;watch&apos;); this.b = val*2 + 1; &#125; &#125; 当点击button a的值变化，会打印‘watch’,但是当无关数据message改变时，同样会触发ab();这样肯定不是我们想要的，所以可以用watch监听 a的变化，在函数中进行一些操作，这样就不会影响了。这样做有个小弊端，就是我们需要定义一个变量名‘b’来接受，如果要改变名字 需要改2处地方，当然这个因素基本可以忽略。 Vue给了我们最完美的方法，就是通过计算属性computed来进行操作","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-2","date":"2017-06-05T05:12:14.000Z","path":"2017/06/05/vue-2/","text":"vue 指令、模板语法v-for这是一个指令，只要有v-的就是指令（directive 操作dom ） 在vue中可以通过v-for来循环数据的通知循环dom，语法是item in/of items，接收第二个参数是索引 (item,index) of items,还可以循环键值对，第一个参数是value，第二个是key，第三个依然是索引 v-on在vue中还有v-on来为dom绑定事件，在v-on：后面加上要绑定的事件类型，值里可以执行一些简单javascript表达式：++ – = … 可以将一些方法设置在methods里，这样就可以在v-on:click的值里直接写方法名字可以，默认会在方法中传入事件对象，当写方法的时候加了()就可以传参，这个时候如果需要事件对象，那就主动传入$event v-on绑定的事件可以是任意事件,v-on:可以缩写为@ 为什么在 HTML 中监听事件? 你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。 模板语法在vue中，我们使用mustache插值 花括号 来将数据渲染在模板中 使用v-once指令可以控制只能插入一次值，当数据变化的时候，模板对应的视图不更新 使用v-html指令可以解析html格式的数据 在html标签属性里不能使用mustache插值，这个时候给元素添加动态属性的时候使用v-bind来绑定属性，可以缩写成: 在使用v-bind绑定class和内联样式的时候，vue做了一些优化，可以使用对象语法和数组的语法来控制 防止表达式闪烁： v-cloak 给模板内的元素添加v-cloak属性后，元素在vue没有加载完的时候就有这个属性，当vue加载完成后这个属性就消失了，所以我们可以给这个属性设置css样式为隐藏 v-text/v-html v-text会指定将模板内元素的textContent属性替换为指令值所代表的数据，也可以用于防止闪烁 v-html可以解析标签，更改元素的innerHTML，性能比v-text较差 v-pre 跳过元素和其子元素的编译过程，可以用来显示mustache","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"vue-1","date":"2017-05-17T07:58:49.000Z","path":"2017/05/17/vue-1/","text":"Vue的介绍、性能与AngularJS的对比Vue的很多api、特性都与angularJS相似，其实是因为Vue在开发的时候借鉴了很多AngularJS中的特点，而AngularJS中固有的缺点，在Vue中已经解决，也就是青出于蓝而胜于蓝，Vue的学习成本比AngularJS低很多，因为复杂性就低 AngularJS是强主张的，而Vue更灵活 Vue的数据流是单向的，数据流行更清晰 Angular里指令可以是操作dom的，也可以封装一段结构逻辑代码，例如：广告展示模块 Vue中的指令只是操作dom的，用组件来分离结构逻辑 AngularJS的性能比不上Vue Vue的使用Vue不支持IE8，因为使用了ES5的很多特性 可以直接通过script标签来引入vue.js，有开发版本和生产版本，开发版本一般我们在开发项目的时候引入，当最后开发完成上线的时候引入生产版本，开发版本没有压缩的，并且有很多提示，而生产版本全部删掉了 在Vue中提供了一个脚手架（命令行工具）可以帮我们快速的搭建基于webpack的开发环境… Vue的实例每一个应用都有一个根实例，在根实例里我们通过组件嵌套来实现大型的应用 也就是说组件不一定是必须的，但是实例是必须要有的 在实例化实例的时候我们可以传入一个；配置项，在配置项中设置很多属性方法可以实现复杂的功能 在配置中可以设置el的属性，el属性代表的是此实例的作用范围 在配置中同过设置data属性来为实例绑定数据 mvc/mvvm阮大神博客 mvc 分为三层，其实M层是数据模型层，它是真正的后端数据在前端js中的一个映射模型，他们的关系是：数据模型层和视图层有映射关系，model改变，view展示也会更改，当view产生用户操作或会反馈给controller，controller更改model，这个时候view又会进行新的数据渲染 MVC 这是纯纯的MVC的模式，但是很多框架都会有一些更改 前端mvc框架，如angularjs，backbone： 前端MVC 会发现，用户可以直接操作controller（例如用户更改hash值，conrtoller直接监听hash值变化后执行逻辑代码，然后通知model更改） 控制器可以直接操作view，如果，让某一个标签获得进入页面获得焦点，不需要model来控制，所以一般会直接操作（angularJS，指令） view可以直接操作model （数据双向绑定） MVP: mvp view和model不能直接通信，所有的交互都由presenter来做，其他部分的通信都是双向的 view较薄 ，presenter较为厚重 MVVM： mvvm MVVM和MVP及其相似，只是view和viewmodel的通信是双向绑定，view的操作会自动的像viewmodel通过","tags":[{"name":"vue","slug":"vue","permalink":"https://hanjinbao.cn/tags/vue/"}]},{"title":"浅谈tap-highlight-color与::selection","date":"2017-04-27T04:16:50.000Z","path":"2017/04/27/浅谈tap-highlight-color/","text":"语法：1tap-highlight-color：&lt;color&gt; - 默认值：由user agent决定 - 适用于：所有元素 - 继承性：有 - 动画性：是 说明：- 设置或检索对象的轻按时高亮。 - 当用户轻按一个链接或者JavaScript可点击元素时给元素覆盖一个高亮色 - 如果想取消这个高亮，将值设置为全透明即可，比如transparent - 对应的脚本特性为textHighlightColor。 问题指向- CSS3 修改和去除移动端点击事件出现的背景框 - 设定元素在移动设备（如Adnroid、iOS）上被触发点击事件时，响应的背景框的颜色。 - 例：在Adnroid版本的微信中，点击a标签时将会出现一个橙色的小框表示点击的响应。此时，如果对元素设置了tap-highlight-color值，例如:-webkit-tap-highlight-color: rgba(240,240,240,0.7); 则可改变元素被点击时背景框的颜色。 如果需要背景框不显示，则可以将rgba中的alpha值设为0即可，例如rgba(0,0,0,0) ::selection 选择器问题- 应用场景：通常我们选中文字时的背景色是黑色，文字颜色是白色。我们可以用以下样式去设置网页的选中内容的样式： 12345::selection &#123; background:#000; color:#fff; &#125;::-moz-selection &#123; background:#000; color:#fff; &#125;::-webkit-selection &#123; background:#000; color:#fff;&#125; - 官方参考文档---http://www.w3school.com.cn/cssref/selector_selection.asp","tags":[{"name":"css","slug":"css","permalink":"https://hanjinbao.cn/tags/css/"}]},{"title":"代码魅力","date":"2017-03-05T02:51:00.000Z","path":"2017/03/05/代码魅力/","text":"视觉盛宴","tags":[{"name":"canvas","slug":"canvas","permalink":"https://hanjinbao.cn/tags/canvas/"}]},{"title":"input自动获取焦点","date":"2017-02-15T01:29:14.000Z","path":"2017/02/15/input自动获取焦点/","text":"自动获取焦点1&lt;input type=&quot;text&quot; name=&quot;fname&quot; autofocus=&quot;autofocus&quot;&gt;","tags":[{"name":"html","slug":"html","permalink":"https://hanjinbao.cn/tags/html/"}]},{"title":"文字溢出处理","date":"2017-02-14T09:18:14.000Z","path":"2017/02/14/文字溢出处理/","text":"文字溢出处理两种方式处理以下情况 1234567&lt;p style=&quot;width: 300px;&quot;&gt; 因使用了WebKit的CSS扩展属性，该方法gggggg 因使用了WebKit的CSS扩展属性，该方法gggggg 因使用了WebKit的CSS扩展属性，该方法gggggg 因使用了WebKit的CSS扩展属性，该方法gggggg 因使用了WebKit的CSS扩展属性，该方法gggggg&lt;/p&gt; 1. 第一种限定行数123456p&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; // 限定3行，超出部分隐藏并且用省略号代替。 overflow: hidden;&#125; 2. 第二种限定高度12345678910111213141516p&#123; position: relative; line-height: 20px; max-height: 80px; // 限定一个高度，超过这个高度，超出部分隐藏并且用省略号代替。 overflow: hidden;&#125;p::after&#123; content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(right, transparent, #fff 55%); background: -moz-linear-gradient(right, transparent, #fff 55%); background: linear-gradient(to right, transparent, #fff 55%);&#125;","tags":[{"name":"css","slug":"css","permalink":"https://hanjinbao.cn/tags/css/"}]},{"title":"Linux 常用命令","date":"2017-02-10T02:32:26.000Z","path":"2017/02/10/Linux 常用命令/","text":"常用命令arch 显示机器的处理器架构 uname -m 显示机器的处理器架构 uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 ) shutdown -h now 关闭系统 init 0 关闭系统 telinit 0 关闭系统 shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启 reboot 重启 logout 注销 文件和目录 cd /home 进入 ‘/ home’ 目录’ cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls [0-9] 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构 lstree 显示文件和目录由根目录开始的树形结构 mkdir dir1 创建一个叫做 ‘dir1’ 的目录’ mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 ‘file1’ 的文件’ rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 cp -r dir1 dir2 复制一个目录及子目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text 文件搜索 find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name *.rpm -exec chmod 755 ‘{}’ \\; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径","tags":[{"name":"linux","slug":"linux","permalink":"https://hanjinbao.cn/tags/linux/"}]},{"title":"Es6+babel","date":"2017-01-23T10:51:20.000Z","path":"2017/01/23/Es6-babel/","text":"Ecmascript 6 + Babel npm scripts Express Babel Register第一：在项目根目录下创建一个 .babelrc 文件，写入以下内容： 1234&#123; \"presets\": [ ]&#125; 第二：安装对应的转码规则： 1234567891011# ES2015转码规则$ npm install --save-dev babel-preset-es2015# react转码规则$ npm install --save-dev babel-preset-react# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 第三：将 .babelrc 文件中修改为以下内容： 12345&#123; \"presets\": [ \"es2015\" ]&#125; 第四步（从第四步开始，前三部必不可少）： babel-cli：命令行转码 babel-node：babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境 babel-register：实时转码，所以只适合在开发环境使用 babel-core：如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块 babel-cli： 一种使用方式就是全局安装：npm install -g babel-cli（可以通过 npm root -g 查看全局包安装目录），只要全局安装了 babel-cli，则会在命令行中多出一个命令：babel。 这里如果使用全局安装的 babel-cli 进行转码是没有问题的，但是问题是如果一旦项目给了别人，别人不知道你使用了这个转码工具，所以解决方式就是将 babel-cli 安装到本地项目中： 1npm install --save-dev babel-cli 这种第三方命令行工具如果安装到本地项目，会在 node_modules 中生成一个目录：.bin，然后第三方命令行工具会将对应的可执行文件放到该目录中。 这样的话，就可以直接在本地项目中使用该第三方命令行工具了。 对于如何使用，则可以通过配置 package.json 文件中的 scripts 字段来配置使用： 123456789101112&#123; \"name\": \"babel-demo\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"babel demo1.js\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.22.2\", \"babel-preset-es2015\": \"^6.22.0\", \"babel-preset-react\": \"^6.22.0\" &#125;&#125; babel-register（适合开发阶段，实时编码转换）: 第一：安装 babel-register 1npm install --save-dev babel-register 第二：添加一个傀儡文件(main.js)： 12require('babel-register')require('你的核心功能代码入口文件模块') 第三：使用 node 执行 main.js，而不是你的入口文件. –save 和 –save-dev通过 --save 参数安装的包，是将依赖项保存到 package.json 文件中的 dependencies 选项中。通过 --save-dev 参数安装的包，是将依赖项保存到 package.json 文件中的 devDependencies 选项中。 无论是 --save 或者 --save-dev 安装的包，通过执行 npm install 都会将对应的依赖包安装进来。 但是，在开发阶段会有一些仅仅用来辅助开发的一些第三方包或是工具，然后最终上线运行（到了生产环境），这些开发依赖项就不再需要了，就可以通过 npm install --production 命令仅仅安装 dependencies 中的依赖项。 Expresshello world基本路由根据不同的请求路径分发到具体的请求处理函数 处理静态资源模板引擎中间件Express API express() Application Request Response Router","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"Ecmascript6-阮一峰","date":"2017-01-18T00:44:25.000Z","path":"2017/01/18/Ecmascript6-阮一峰/","text":"Ecmascript 6-阮一峰 Ecmascript 6 ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。 Ecmascript 是 JavaScript 语言的标注规范 JavaScript 是 Ecmascript 规范的具体实现 具体实现取决于各大浏览器厂商的支持进度 Ecmascript 6 也被称作 Ecmascript 2015 各大浏览器厂商对于最新的 Ecmascript 6 标准支持可以参照： http://kangax.github.io/compat-table/es6/ 对于不支持 ES6 的环境，可以使用一些编译转码工具做转换处理再使用 例如 babel let 和 const let 类似于 var，也是用来定义变量的 通过 let 定义的变量是块级作用域，只在当前代码块有效 const 也类似于 var，用来定义常量 通过 const 定义的常量，定义的时候必须初始化 const 定义的变量一旦定义，不能修改 let 和 const 都没有作用域提升 let 和 const 在一个块级作用域中都不能重复定义 解构赋值数组解构： 12let [a, b, c] = [123, 456, 789]console.log(a, b, c) 123 456 789 对象解构： 12let &#123; name, age &#125; = &#123; name: 'Jack', age: 18 &#125;console.log(name, age) Jack 18 函数参数解构： 12345function f (p1, &#123; p2 = 'aa', p3 = 'bb' &#125;) &#123; console.log(p1, p2, p3)&#125;f('p1', &#123; p2: 'p2' &#125;) p1 p2 bb 字符串解构： 12let [a, b, c, d, e] = 'hello'console.log(a, b, c, d, e) h e l l o 字符串模板字符串： 12 数组方法： 1234567891011// 将一个伪数组转为一个真正的数Array.from()// Array.of方法用于将一组值，转换为数组Array.of()// 查找某个元素Array.find()// 查找某个元素的索引下标Array.findIndex() 函数对象babel","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"Git-bash、Git基本命令","date":"2016-08-13T10:50:04.000Z","path":"2016/08/13/Git-bash、Git基本命令/","text":"Git-bash、Git基本命令 Git-bash 文件操作相关命令 touch：创建文件 cat：查看文件 less：查看大文本文件 vi：visual interface Esc 退出到命令模式 i 进入插入模式 :q 退出vi :w 保存编辑 :wq 保存并退出 :q! 强制退出不保存修改 vi 的所有操作基本全部是命令，这里掌握基本使用基于可以了 有时候使用 git commit 进行提交的时候希望能多写几行提交日志，这时候可以省略 -m 参数进入 vi 编辑模式 Git基本命令 git init git status git add git commit git log 添加/删除文件1234567891011121314151617# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 代码提交123456789101112131415# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 回退撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 分支管理默认在 git 的仓库中，会有个分支的原点：master 1234567891011121314151617181920# 列出所有本地分支git branch# 基于当前分支新建一个分支，但依然停留在当前分支git branch [branch-name]# 基于当前分支新建一个分支，并切换到该分支git checkout -b [branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支，交替和上一个分支进行切换git checkout -# 合并指定分支到当前分支git merge [branch]# 删除分支git branch -d [branch-name] 远程操作1234567891011121314151617181920# 下载一个远程仓库$ git clone [url]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force Git 工作流程：分支策略 Git 工作流程 Git FlowGithub Collabrators这种方式公司团队项目使用居多 Github Flow这种方式开源项目使用居多 fork clone 到你的本地 在clone下来的项目中拉出一个新的分支 修改的时候最好是基于 master 拉出一个修改的分支，例如这个分支是用来添加某个功能的 在新分支上开发或者修改完成之后，提交到本地仓库，然后 push 推到自己的账户中 fork 过来的仓库 最后，在 Github 上你 fork 过来的仓库界面中找到 New Pull Request 发起提交请求 对方就会在仓库的 Pull Requests 中收到你发起的提交请求 然后双方就可以使用社会化交流方式进行沟通协作 例如 Code Review 代码审查 最后对方审查通过没有问题之后，选择 Merge Request 到此，一个完整的 Github 工作流结束 这种方式开源项目更多一些（大家都不认识） Gitlab flowGitlab对于第三方代码仓库托管服务有很多，其中 Github 最火，但是如果想要托管私有项目收费比较高，而且在国内受限于网络环境影响，鲜少有公司使用。 也有的公司，例如京东、淘宝这种级别的公司，也不太常用别的第三方的托管服务。 Gitlab 是一个开源的类似于 Github 的一个系统，开源免费部署到自己的公司内容。 与 Github 进行多人协作CollaboratorsPull Request","tags":[{"name":"git","slug":"git","permalink":"https://hanjinbao.cn/tags/git/"}]},{"title":"版本控制（SVN、Git）和Github整理","date":"2016-08-11T04:45:03.000Z","path":"2016/08/11/版本控制（SVN、Git）和Github整理/","text":"版本控制（SVN、Git）和Github整理 知识点 版本控制 SVN Git Github 版本控制问题1：历史记录问题2：多人协作解决问题：软件12345版本 用户 说明 日期 张三 删除了软件服务条款5 7/12 10:38 张三 增加了License人数限制 7/12 18:09 李四 财务部门调整了合同金额 7/13 9:51 张三 延长了免费升级周期 7/14 15:17 什么是版本控制？版本管理就是管理更新的历史记录，它给我们提供了一些在软件开发过程中必不可少的功能，例如： 记录一款软件添加或更改源代码的过程 回滚到特定阶段，恢复误删除的文件 合并多人协作的文件等 多人协同，文件传输 版本控制分类 集中式 SVN 分布式 Git SVNSVN 全称 Apache Subversion，是一个开放源代码的集中式版本管理系统。在 2000 年由 CollabNet 开发，现已发展成为 Apache 软件基金会的一个开源项目。 环境安装SVN 交互协作流程 集中式版本管理 集中式早期的版本管理就是以 Apache Subversion 为代表的集中式版本管理，集中式版本管理将所有的数据集中存放在服务器中，这是有便于统一管理的优点。但是一旦开发者所处的环境不能连接服务器，就无法获取最新源代码，开发也就无法进行。服务器宕机时也是同样的道理，而且万一服务器故障导致数据丢失，恐怕开发者就再也见不到最新的源代码了。 简而言之： 中央服务器好比是一个图书馆 你要改一本书，必须先从图书馆借出来（checkout） 然后回到家自己改，改完了，再放到图书馆（commit） 一些术语 源代码库（repository）：源代码统一存放的地方 检出（checkout）：当你手上没有源代码的时候，就需要从 responsive checkout 一份 提交（commit）：当你已经修改了代码，就需要 commit 到 repository 更新（update）：当你已经 checkout 了一份源代码，Update 一下就可以和 repository 上的源代码同步，你手上的代码就会有最新的变更 使用 VisualSVN 搭建 SVN 服务器SVN 服务器：运行 Subversion 服务的计算机。 为了方便，我们这里使用比较流行的图形化工具 VisualSVN来搭建我们的 SVN 服务。 安装完毕之后，基本使用流程如下： 创建用户 创建版本仓库 设定用户权限 使用 TortoiseSVN 作为 SVN 客户端SVN 客户端：用户通过SVN客户端同SVN服务器交互 这里我们使用最流行的 TortoiseSVN https://DESKTOP-40UMEJI:8443/svn/jd https://192.168.133.25:8443/svn/jd TortoiseSVN 客户端基本操作流程 检出项目：checkout 在没有源代码的前提下，需要通过 tortoise-svn 客户端下载 提交修改：commit 帮你记录当前开发的软件的状态 更新文件或目录：update（更新） 别的开发人员在已有源代码的前提下可以通过 update 更新服务器上最新的版本 查看版本日志：log（日志） 关于冲突假设 A、B 两个用户都在版本号为 100 的时候，更新了 kingtuns.txt 这个文件，A 用户在修改完成之后提交 kingtuns.txt 到服务器， 这个时候提交成功，这个时候 kingtuns.txt 文件的版本号已经变成 101 了。同时B用户在版本号为 100 的 kingtuns.txt 文件上作修改， 修改完成之后提交到服务器时，由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。 良好的使用习惯就是，提交之前，先更新。 为了避免冲突，别人的文件你最好不要动，万一你要修改公共的文件或者是别人的文件，跟别人最好口头沟通好，就是你改动的时候，别人最好不要去改动，这样才能最大程度上避免冲突的问题。 多人协作时，同个目录或同个文件需要不同成员共同开发，这个时候 commit 和 update 就可能出现冲突。 两个程序员只要不是修改了同一行程序，SVN 可以通过 update 自动合并修改 但是如果两个程序员修改了同一行程序， SVN 会提示文件 conflict，需要手动确定 如何解决？ 第一种解决方法：手动合并冲突的内容 第二种解决方法：每次修改某个文件的时候对文件上锁，这样你在修改的过程中别人就无法更新这个文件 建议： 一个文件最好同一时间只被一个人修改提交 多跟团队成员沟通 不要随便去修改别人的文件 版本管理使用建议 不要频繁的提交版本 一般有比较成熟的功能模块的时候，再去提交 修复了功能性 bug 的时候再去提交 提交的代码最好无 bug 每次 commit 之前都要 update 因为你在编辑这个文件的时候，可能比人已经编辑并提交了某个版本 所以先 update，目的是为了检查一下服务器上有没有最新版，如果有，直接更新 更新的过程中如果遇到冲突，不要慌，去手动解决 每次 commit 的时候都务必要写提交日志 这个提交日志就好比你保存副本的时候加的一个标记 目的是为了日后做版本的回退查找以及查看记录更新状态 使用总结 版本控制管理系统 源代码仓库 repository 检出代码 checkout 更新最新源代码 update 提交修改 commit 其它 清除svn保存的username用户名和paasword密码(windows和linux) 菜鸟教程 - SVN 教程 Git 维基百科 - Git 学习资源介绍 Git教程 - 廖雪峰 Pro Git git - 简明指南 猴子都能懂的GIT入门 Git 简介 是什么 Git 也是一个版本控制管理软件 有什么用，可以解决什么问题 保存历史记录 多人协作 有了 SVN，为啥要学 Git Git 火 Git 相对于 SVN 来说，更强大，用户也非常多 怎么用 Git 的诞生 http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000 Git 使用交互流程 git交互模型 安装和配置 Git 环境 下载地址：https://git-scm.com/ git-bash 常用命令 pwd ls ls -a cd mkdir clear rmdir 只能删除空目录 rm rm 文件名 rm -rf 目录名 注：很强大，可以删除非空目录，以及一些比较顽固的文件或者目录 初始化配置12345678# 设置用户名git config --global user.name \"你的名字\"# 配置用户邮箱git config --global user.email \"你的常用邮箱\"# 设置 gitk 图形查看工具中文显示默认编码（防止乱码）git config --global gui.encoding utf-8# 查看配置列表项git config --list 基本使用 git init 初始化一个 Git 仓库 git status 查看当前工作区、暂存区、本地仓库的状态 git add git commit 示例：git commit -m &quot;日志说明&quot; --author=&quot;操作者姓名 &lt;邮箱&gt;&quot; 执行 git commit 的时候，Git 会要求具有用户名和邮箱的参数选项 可以通过 git config 命令配置一下用户名和邮箱 git log gitk 总结：操作 Git 的基本工作流程就是先修改文件，然后执行 git add 命令。git add 命令会把文件加入到暂存区，接着就可以执行 git commit 命令，将文件存入文档库，从而形成一次历史记录。 问题1：关于 Git-bash 中文问题 Git for Windows Unicode Support 问题2：执行 commit 的时候一大堆的信息 问题3：配置 user.name 和 user.email 问题 工作区、暂存区、本地仓库版本回退1234567891011121314151617181920212223242526272829303132# git rm --cached &lt;file&gt;# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 远程同步 remote push pull 在线仓库托管服务 一个不知道 github、stackoverflow 的程序员想想都是可悲的 github 码云 coding Github Github 就是程序员的新浪微博它可以让你使用社交化的方式进行编程协作、 - 点赞 - 评论 - 转发 - etc. 主要作用：可以免费在线托管你的仓库可以实现多人协作提供了一个可视化界面（Web Page）让你能直观清晰的了解你的项目源代码 基本使用 注册 登陆 创建远程仓库","tags":[{"name":"git","slug":"git","permalink":"https://hanjinbao.cn/tags/git/"},{"name":"svn","slug":"svn","permalink":"https://hanjinbao.cn/tags/svn/"}]},{"title":"Express-MongoDB-package.json","date":"2016-06-01T04:38:01.000Z","path":"2016/06/01/Express-MongoDB-package-json/","text":"Express、 MongoDB、 package.json的介绍 知识点 Express MongoDB package.json 文件package.json 文件一般用来描述项目的一些基本信息，例如入口文件、依赖项、项目介绍、开发作者等数据。 目前已知的两个非常重要的属性： main main 和模块化中的第三方包加载规则有关系 dependencies dependencies 和 npm 命令行工具有关系 当你安装包的时候，如果加上 --save 参数，则npm会自动把这个第三方包依赖信息写入到 package.json 文件中的 dependencies 字段中 当你执行 npm install 的时候，npm 会找到当前项目中的 package.json 文件中的 dependencies 依赖项，然后依次将所有的依赖下载下来 这个文件最好每一个项目都有，保存一些项目的基本信息。 这个文件可以通过 npm init 以向导的形式生成，也可以加上 -y 参数，一步生成。 Express 一个基于 Node 开发的一个快速 Web 开发框架主要用来构建 Server http://expressjs.com/ http://www.expressjs.com.cn/ hello-world12345678910111213141516171819202122var express = require('express')// 1. 调用 express 方法，得到一个类似于 server 的实例// 一般称作 appvar app = express()// 2. 通过 app 根据不同的请求方法及请求路径设定具体的处理函数// 当用户以 GET 请求 / 的时候，执行对应的回调处理函数app.get('/', function (req, res) &#123; res.end('hello world')&#125;)// 当用户以 GET 请求 /login 的时候，执行对应的回调处理函数app.get('/login', function (req, res) &#123; res.end('hello login')&#125;)// 3. 启动监听app.listen(3000, function () &#123; console.log('服务器已启动，请访问：http://127.0.0.1:3000/')&#125;) 处理静态资源 参考文档：http://www.expressjs.com.cn/starter/static-files.html 通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。 配置规则如下： 1app.use('路径访问前缀', express.static('资源目录路径')) 以下是一些配置示例： 将目录 static 资源暴露出来，可以通过 /static/* 的形式进行访问 app.use(&#39;/static/&#39;, express.static(&#39;static目录的绝对路径&#39;)) /static/css/a.css /static/css/b.css /static/img/ab2.jpg 将目录 public 资源暴露出来，不需要任何前缀就可以访问 app.use(express.static(&#39;public 目录的绝对路径&#39;)) /css/bb.css /img/a.jpg 将目录 demo 资源暴露出来，可以通过 /aa/* /aa前缀的形式进行访问 app.use(&#39;/aa/&#39;, express.static(&#39;demo 目录的绝对路径&#39;)) /aa/css/a.css /aa/**/*.* 将目录 static 资源暴露出来，可以通过 /static/* 或者 /aa/* 的形式进行访问 app.use(&#39;/aa/&#39;, express.static(&#39;static 目录的绝对路径&#39;)) app.use(&#39;/static/&#39;, express.static(&#39;static 目录的绝对路径&#39;)) 上面的形式就是把 static 目录中的资源提供了两种形式，既能以 /static/ 为前缀进行访问也可以以 /aa/ 的前缀进行访问 路由系统在 Express 配置使用 ejs 模板引擎Express 这个框架很精简，默认是不支持模板引擎的，需要配合一些第三方的模板引擎来结合使用，例如这里将 ejs 和 express 结合起来使用： 第一：安装 ejs： 1npm install --save ejs 第二：在代码中配置： 12app.set('views', 模板文件存储路径) // 注意，这里可以不配置，因为 Express 默认会去项目中的 `views` 目录进行查找app.set('view engine', 'ejs') // 这里表示让 Express 中的 res.render 方法使用 ejs 模板引擎，这里的 ejs 就是你安装的那个模板引擎的包名 只要经过了上面这种配置，然后 res 对象上就会自动多出一个方法：res.render ,使用方式和咱们之前自己封装的一样：res.render(&#39;视图名称&#39;, {要解析替换的对象数据}) 注意：使用了 ejs 模板引擎，默认视图文件后缀名必须是 .ejs，否则 render 方法找不到。如果想要修改，可以像下面这样： 1234// app.set('view enginge', 'ejs')// 将上面这句配置改为下面的形式，就修改了默认的 .ejs 后缀名app.engine('.html', require('ejs').__express)app.set('view engine', 'html') 在 Express 中配置使用 body-parser 插件解析处理表单 POST 请求体第一步：安装 body-parser 1npm install --save body-parser 第二步，在代码中进行配置： 12app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json()) 只要经过上面的安装配置，则在任意的 post 处理函数中都可以直接通过 req.body 来获取表单 POST 请求体数据。 例如： 1234app.post('login', function (req, res) &#123; // 这里可以直接通过 req.body 来获取表单 POST 请求体数据 console.log(req.body)&#125;) MongoDB数据库概念 数据库：一个电子化的文件柜 数据库就是为我们方便的管理数据的一个平台，例如对数据的存储、修改、查询等都非常的方便。 数据库分类数据库产品有很多，以下是一些常见的数据库产品： MySQL Oracle DB2 SqlServer MongoDB etc. 数据库没有排名之分，各有各的应用场景，这里说的是 MongoDB 数据库。 MongoDB 数据库 为了更好的学习 MongoDB 数据库，可以参考菜鸟教程上的 MongoDB 数据库教程文档，链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.html MongoDB 数据库存储结构 mongodb数据存储结构 安装与配置 MongoDB 数据库环境启动 MongoDB 服务实例可以通过使用安装程序中的 mongod CLI应用程序来启动 MongoDB 服务。 直接在控制台输入：mongod 敲回车即可。 在启动的时候，可以通过 --dbpath 指定数据服务存储数据的目录，如果不指定该目录，默认 mongod 会去 c:/data/db 作为自己的数据存储目录。 64 位版本启动 MongoDB 数据服务： 1mongod --dbpath C:\\data\\db 32 位版本使用下面的命令启动数据服务： 1mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1 提示：如果不加 --dbpath, mongod 会自动使用 C:\\data\\db 目录作为自己的数据存储路径，所以，如果你已经有了 C:\\data\\db 目录了，可以省略 --dbpath。 执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了，千万不要关闭，否则无法连接，如果对数据库的操作结束，可以打开该控制台通过 Ctrl + C 关闭。 连接 MongoDB 数据服务注意：在进行连接之前请确保你的服务实例是开启状态的（不要关闭刚才开启的数据服务实例）。 打开一个新的控制台，在控制台输入以下命令用来连接本机的 MongoDB 服务实例： 1mongo mongo 命令默认去连接本机上的 MongoDB 服务实例：127.0.0.1:27017，可以通过下面的命令指定连接的主机名和端口号： 1mongo --host 127.0.0.1 --port 27017 如果看到类似于如下的字样说明连接成功： 123456789MongoDB shell version v3.4.0connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.0Server has startup warnings:2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten]2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten]&gt; 如果提示 “无法连接主机”，请检查你的 MongoDB 数据服务实例是否开启。 基本操作命令 show dbs 查看当前服务实例上所有的数据库 use 数据库名称 这个命令表示切换到指定的数据库 如果没有，也不会创建 如果已经有了，则表示切换到这个数据库对该数据库进行操作 db 查看当前所处的数据库 db.集合名称.insert(数据文档) show collections 查看当前数据库中所有的集合 db.集合名称.find() 查询指定集合中所有的数据 可以通过 db.集合名称.find().pretty() 美化输出格式 默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据 db.集合名称.update({更新条件}, {要更新的字段}) 更新指定集合数据 db.集合名称.remove({删除条件}) 删除指定集合中的数据 使用 Node 操作 MongoDB安装 MongoDB 官方提供的驱动包： 1npm install --save mongodb 具体操作方式请参考官方文档：https://www.npmjs.com/package/mongodb 目标 能概述 package.json 文件的作用并能列举出至少两个该文件内成员的名称及作用 能掌握 Express 的基本使用（配置处理静态资源、配置使用ejs模板引擎、解析处理表单POST请求体） 能完成将 Hacker-News 案例改为 Express 版本 能掌握 MongoDB 数据库的基本使用（添加、删除、修改、查询）","tags":[{"name":"node","slug":"node","permalink":"https://hanjinbao.cn/tags/node/"},{"name":"express","slug":"express","permalink":"https://hanjinbao.cn/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://hanjinbao.cn/tags/mongodb/"}]},{"title":"对Node的理解以及简单使用","date":"2016-05-21T04:48:44.000Z","path":"2016/05/21/对Node的理解以及简单使用/","text":"Node理解、npm使用NodeNode 是一个平台，Node 是一个框架，基于 Ecmascript 语言，在这个平台（或者说框架）之上给 Ecmascript 提供了很多操作系统级别的编程接口。 做 Node 编程实际上就是通过 Ecmascript、Node平台内置的核心模块、第三方社区提供的模块构建高度模块化的程序。 REPL：Node 中类似于浏览器中的 Console 控制台 Read Eval Print Loop Node 中的 JavaScript Ecmascript console setInterval(callback, delay[, …args]) setTimeout(callback, delay[, …args]) clearInterval(intervalObject) clearTimeout(timeoutObject) clearImmediate(immediateObject) setImmediate(callback[, …args]) __dirname 用于获取当前文件所属目录的绝对路径 使用场景：常用语将相对路径转为绝对路径，防止执行node命令所处的目录影响路径的问题 __filename 作用：获取当前文件的绝对路径 process process 是Node中一个进程对象，可以用来访问当前运行进程的一些信息 global 类似于浏览器中的 window，是一个全局对象 唯一的区别在于浏览器中的 window 是全局对象，默认在全局声明的变量成员都属于 window Node 中是模块作用域 在一个模块系统中，所有的模块都共享一个 global 也就是说可以通过给 global 显示的挂载成员在多个模块之间全局共享 虽然可以这样做，了解即可，尽量不要使用 模块成员 module module 是一个模块对象，里面包含了当前模块的一些信息 例如 exports 就是当前模块对外的导出接口对象 exports 在每一个模块中，同时还提供了一个接口成员：exports exports 是 module.exports 接口对象的一个引用 也就是可以把 module.exports.foo=xxx 的形式简写为 exports.foo=xxx 注意：注重向外的暴露的接口对象是：module.exports require() 执行被加载模块中的代码 拿到被加载模块中的 module.exports 接口对象 模块化模块化概念 开发生产效率高 可维护性好 每一个模块默认都是一个私有的作用域，互相独立，内部实现某一个具体的功能职责，暴露接口成员，通过特定的规则将不同的模块组织到一起，就构成了一个完整的模块系统。 自定义模块核心模块以下是Node中的一些核心模块及作用： 核心模块名 作用 fs 文件操作 http 网络操作 net 更底层的网络操作 os 操作系统相关 path 文件路径操作 querystring 查询字符串处理 url url操作处理 第三方模块模块加载机制规则require 方法中传递的参数叫做模块标识，其中涉及三种情况： 以 ./ 后者 ../ 或者 / 或者 C:/demo/a.js 这种形式的文件模块 加载核心模块 核心模块是Node内置的，例如：fs、http、url 等 已经别编译到了可执行文件中了 用的时候，必须通过一个特定的核心模块标识名称加载使用 加载第三方模块 通过 npm 下载的模块或者说包 加载第三方模块也是通过指定第三方模块的标识名称加载的 Node 会判定如果不是文件路径形式的模块，也不是核心模块 Node 会基于当前文件模块同级目录中的 node_modules 目录去查找该第三方模块标识对应的目录 如果在 node_modules 目录中能找到对应的目录，例如 mime 则 Node 去 mime 目录下找 package.json 文件 如果找到 package.json 文件，则找该文件中的 main 属性，然后根据该属性指向的文件模块进行加载 如果上述条件某一个环节不成立，则 Node 进入上一级目录中的 node_modules 进行查找，规则同上 如果一直到当前文件模块所属的磁盘根目录下都没有找到对应的 node_modules 中的第三方模块 则最后报错：can not find module xxx 包与Npm将一些相关功能的文件模块组织到一起就形成了一个包。 通过模块化改造 Hacker News 案例 总结基础概念 使用 Npm 安装全局命令行工具在 npm 社区中，除了有可以在项目中使用的第三方包之外，还有一些特殊的包：这些特殊的包被称之为命令行工具，不是用于项目的，而是可以安装到计算机中，然后通过命令行中的命令的形式来使用，这种工具有很多，例如：http-server、gulp、browser-sync、nodemon 等等等等很多。 安装方式： 1npm install --global 第三方命令行工具名字 卸载： 1npm uninstall --global 第三方命令行工具名称 查看全局命令行安装目录： 1npm root --global 目标 能掌握 Node 中模块化交互 API（require、exports、module.exports）并解释每一个API的作用 能详细概述 Node 中模块的分类以及加载规则（自己写的模块、核心模块、第三方模块） 能完成将 Hacker-News 案例改造为模块化的形式并解释每一个模块的作用 能掌握在Node中处理表单 POST 提交并详细概述在post类型表单中点击submit之后发生的事情（客户端与服务端都做了什么）","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"},{"name":"node","slug":"node","permalink":"https://hanjinbao.cn/tags/node/"}]},{"title":"npm介绍","date":"2016-05-15T04:44:19.000Z","path":"2016/05/15/npm介绍/","text":"npm介绍npm是什么两层含义 npm 是一个网站，这个网站上托管了几十万个使用 JavaScript 开发的功能模块库 npm 是一个基于Node开发的一个终端命令行包管理工具 可以使用这个工具去 npm 网站上下载对应的库 npm 安装只要安装了 node 就有了 npm。 通过 npm -v 测试是否有 npm 工具。 使用 npm 安装包 找到能解决自己问题的包，看文档使用说明 通过 npm install 包名 下载到当前项目中的根目录 在代码中通过 require(&#39;第三方包名&#39;) 使用你下载的包 通过 npm install 包名 安装的包会自动下载到当前目录下的 node_modules 目录，如果该目录不存在，则直接创建，如果已存在，则直接将文件下载进去。 Node 中的模块化模块通信交互规则 一个 JavaScript 文件就是一个模块 模块天生就是一个私有的作用域，默认模块内定义的变量等成员只能被模块内部访问 每一个模块中都有一个 module.exports 编程接口对象，默认是一个空对象 可以通过给 module.exports 编程接口对象添加成员向外暴露内部成员 例如：var foo = &#39;bar&#39; module.exports.foo = foo 上面示例标识当前模块向外部暴露了一个接口对象，内部有一个 foo 成员，值是 bar require 方法可以用来加载模块，该方法是同步加载执行的，主要做两件事儿 执行被加载模块中所有的代码 拿到被加载模块中的 module.exports 接口对象 用户自定义模块核心模块核心模块就是 Node 提供的模块，例如 fs、http、path。。。，这些模块其实也是文件模块，核心模块一般都是通过一个固定的标识名称进行加载的，也就是说不能写错，固定的。用什么就加载什么，无论是程序执行效率还是可维护性都非常好。 第三方模块也就是npm社区提供的第三方包，用的时候，先下载，然后也是通过 require 进行加载，加载第三方模块的时候，就是通过 require(&#39;第三方模块标识名&#39;)，所以第三方模块不可能有和核心模块重名的名称。 第三方加载模块有自己的一套加载规则，node 会按照对应的加载机制去加载。具体明天上午会给大家详细解析。 目标 能掌握基本的Web开发思想（没有Web容器、url只是标识、处理页面资源和静态资源） 能掌握在Node中使用模板引擎（服务端渲染） 能掌握解析处理表单 GET 提交并详细概述点击提交按钮之后发生的事情（客户端做了什么，后台如何解析处理的） 能掌握基本的模块化交互规则（require、module.exports）","tags":[{"name":"npm","slug":"npm","permalink":"https://hanjinbao.cn/tags/npm/"}]},{"title":"node介绍","date":"2016-05-12T04:37:42.000Z","path":"2016/05/12/node.js介绍/","text":"Node.js 介绍1. 了解node.js1.1 网站开发模型（BS） Server 为客户端提交接口：数据 Java、.Net、Ruby、Python、PHP、Go、Swift、Lua 学 Node 本质不是在学 Node，在学 服务器（Web后台）编程 请求 处理 响应 大前端时代：JavaScript 语言也可以运行在服务器端 使用 JavaScript 这门语言也可以进行服务器编程 JavaScript 通过 Node.js 运行在服务器端 Browser 客户端：把一坨用户看不懂的数据变成友好的形式给用户体验 1.2 什么是 Node.js？ 简单的说 Node.js 就是运行在服务端的 JavaScriptNode开发就是利用 Ecmascript + 第三方开源库 + Node平台环境API进行编程 什么是 JavaScript JavaScript 一个运行在浏览器端的脚本原因 运行时：浏览器 Ecmascript：JavaScript 基本语法：var、if-else、for、Array、Object、String、function BOM Window DOM 渲染引擎 JavaScript 解析执行引擎 在所有浏览器中，Google Chrome 的 V8 引擎是最快的 JS 脚本代码解析执行引擎 通过 V8 引擎解析和执行 JavaScript 代码 Node 官网：https://nodejs.org/en/ Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js 是一个构建与 Chrome V8 引擎之上的一个 JavaScript 运行时（执行环境） Node 使用 JavaScript 进行编程 Node 采用了 Chrome 的 V8 引擎解析和执行 JavaScript 脚本代码 Node 不是一种语言，Node 可以用来解析和执行 JavaScript 代码 在 Node 没有 DOM、BOM 了，也不用去关心样式、结构问题了 Node 在基本的 JavaScript 语言之上，或者在 Node 平台给 Ecmascript 提供了大量的底层编程接口 例如文件IO 例如网络IO 处理数据 操作数据库 构建网络服务 。。。 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. event-driven：事件驱动 在 Node 中，也采用了类似于浏览器端的编程思想，事件模型编程思想 non-blocking I/O model：非阻塞IO模型 Node 中大量的通过类似于浏览器中 ajax 的方式进行编程 绝大多数代码都是异步编程模型 lightweight &amp; efficient：轻量和高效 Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node.js 包生态系统 Npm 是世界上最大的开源库生态系统 largest ecosystem：最大的开源库生态系统 1.3 使用 Node 可以做什么？ 开发网站服务器 游戏服务器 开发命令行工具 软件分为两种： GUI：看得见，鼠标点点点 CLI：命令窗口，各种命令，选项参数等 1.4 Node 发展史 Node.js 由 Ryan Dahl 和一些其他的开发者于2009年在 Joyent 工作时发明 Node 作者当初只是想做一个类似于 Apache 的服务器而已，最初的时候起的名字叫：webjs 2009年2月，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。 2009年5月，Ryan Dahl在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用。 2009年11月和2010年4月，两届JSConf大会都安排了Node.js的讲座。 2010年年底，Node.js获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node.js的发展。 2011年7月，Node.js在微软的支持下发布Windows版本。[2] 1.5 学习资源推荐 国内NodeJS开发者社区：https://cnodejs.org/ 《深入浅出Node.js》：作者：阿里巴巴.朴灵 2. 快速上手2.1 环境安装 https://nodejs.org/en/download/ 2.2 Hello World 当你在控制台输入：node 01-hello-world.js 之后 实际上通过你安装目录下的那个 node.exe 可执行程序读取了 01-hello-world.js 文件中的源代码 然后解析和执行文件中的代码 最后将结果打印输出到了控制台中 2.3 path 环境变量 目的：就是为了在终端的任意目录中都可以找到该可执行文件 配置方式： 一种在 path 中写路径，通过英文分号分隔 一种先定义变量，给一个变量值，然后在 path 中通过英文分号进行分隔，使用 %变量名% 引用该变量 2.4 文件操作2.5 HTTP 服务2.6 文件版留言本 3. Node 基础3.1 Node 中的 JavaScript console setInterval(callback, delay[, …args]) setTimeout(callback, delay[, …args]) clearInterval(intervalObject) clearTimeout(timeoutObject) clearImmediate(immediateObject) setImmediate(callback[, …args]) __dirname __filename module exports global process require() 3.2 模块化3.3 自定义模块（用户自己编写的模块） require module.exports exports 3.4 核心模块（Node 提供） 在线文档地址：https://nodejs.org/dist/latest-v6.x/docs/api/ 以下是常用的核心模块及作用： 核心模块名 作用 fs 文件操作 http 网络操作 net 更底层的网络操作 os 操作系统相关 path 文件路径操作 querystring 查询字符串处理 url url操作处理 3.5 第三方模块（也称作包）3.6 包与 Npm目标 能掌握path环境变量的配置 能掌握基本的文件读写操作 能掌握基本的 http 服务构建（路径、静态资源、页面资源） 能掌握在 Node 中处理表单 GET 提交","tags":[{"name":"node","slug":"node","permalink":"https://hanjinbao.cn/tags/node/"}]},{"title":"node的知识点整理","date":"2016-05-10T04:35:24.000Z","path":"2016/05/10/node的知识点整理/","text":"将之前学习过的node知识简单整理一下1模块有点多，自己按着自己的记忆大概梳理一下","tags":[{"name":"node","slug":"node","permalink":"https://hanjinbao.cn/tags/node/"}]},{"title":"JS原生框架-6","date":"2016-03-21T00:46:21.000Z","path":"2016/03/21/JS原生框架-6/","text":"常见问题 这几个模块的js文件，除了第一个core.js，其他的沙箱是不是不需要暴露接口了 这几个模块就存在了一个依赖关系 iquery.core.js 去重函数为什么不能是实例方法而是工具方法不太明白 一般情况, 需要实现某些通用功能的时候, 都是实现一个静态方法, 然后再用这个静态方法 实现一个实例方法, 类似于 map 或 each. 上次的案例有一个算法上的缺陷. iQuery.unique = function ( array ) { var arr = []; // 循环, 将唯一的元素加到 这个数组中 return arr; } iquery 对象包含: [ i ] 索引元素外, 还有 prevObject, 其他方法, ... 如果一定要实现, 必须保证保留 除 索引元素外的所有数据 iQUery.unique = function ( iObj ) { var iTmp, arr = []; iObj.each( function ( i, v ) { if ( arr.indexOf( v ) == -1 ) { arr.push( v ); } }); iTmp = iQuery( arr ); iTmp.prevObject = iObj.prevObject; return iTmp; }; iQuery.fn.unique = function () { return iQUery.unique( this ); }; pushStack 与 end var o1 = { name: &apos;jim&apos; }; 假如有一个功能 func( o1, name ) 返回的对象 名字就改了, 改成传入的名字 要求, 返回新对象, 同时要求可以记录旧对象. function func( o, name ) { o.name = name; return o; } 如何记录以前的信息呢? 在当前对象中记录以前的信息 function func( o, name ) { o.prevName = o.name; o.name = name; return o; } 如果要访问以前的名字, 即访问 prevName 属性即可. 如果要访问以前的名字: o.prevName || o.name 我们的逻辑是在链发生改变的时候记录下以前的对象 var oldObj = ...; // 新元素一定是一个由数组构成的对象 var arr = [ ... ]; var newObj = iQuery( arr ); newObj.prevObject = oldObj; return newObj; $( &apos;div&apos; ).css( &apos;border&apos;, &apos;1px solid red&apos; ) .css( &apos;width&apos;, &apos;100px&apos; ) .css( ... ) 推荐书籍 1, dom 程序xxx的艺术 2, js 语言精粹 3, js 权威指南( 犀牛 ) 4, js 模式 事件操作 在 jq 中如何使用事件? 以 点击事件为例 $( &apos;.btn&apos; ).click( function () { ... }); $( &apos;#btn&apos; ).on( &apos;click&apos;, function () { }); iQuery.fn.on = function ( type, callback ) { return this.each(function () { this.addEventListener( type, callback ); }); } iQuery.fn.off = function ( type, callback ) { return this.each(function () { this.removeEventListener( type, callback ); }); } iQuery.fn.click = function ( callback ) { return this.on( &apos;click&apos;, callback ); } 属性操作与样式操作 常用的方法: .attr( ) .prop( ) .html( ) .text( ) .val( ) .css( ) .addClass() .removeClass() .hasClass() .toggleClass() 压缩合并代码 前段发展的有一批工具可以被使用, 这里的所有工具有一个共同的特征, 就是需要 node 平台 谷歌给出了世界上最快的 js 解析引擎, chrome v8 将 v8 引擎分离出来, 是的 js 可以脱离 浏览器来运行, 这个就是 node 平台 安装 node 环境 1) 在网站 nodejs.org 中下载对应的版本 2) 双击安装 3) 在命令行中输入 node -v 和 npm -v 检查是否安装成功 压缩的准备工作 -&gt; npm, node 的包管理器 包 package, 就是 js 库 使用 npm install 包名 安装包, 安装到当前目录的 node_modules 文件夹中 如果没有梯子, 就是用: npm install 包名 --registry=https://registry.npm.taobao.org 如果是 mac 系统, 会在 家目录下( ~ ) 创建一个 node_modules 会下载到这来. 如果 想要下载到当前目录, 需要手动创建 node_modules 文件夹 还可以将包安装到全局 npm install -g 包名 一般将可执行的或通用的一些包安装到全局 -&gt; 构建工具 这些工具都是开源的有很多种, grunt, gulp, webpack 等 在这里我们使用 gulp 来实现 gulp官网: www.gulpjs.com.cn www.gulpjs.com -&gt; gulp 的基本使用 -&gt; 安装 1. 安装全局 gulp 项目 npm install -g gulp 2. 安装本地的依赖项 npm install gulp -&gt; 使用 1. 在当前目录下建一个文件 命名为 gulpfile.js 2. 在里面编写需要处理的代码 -&gt; 首先 var gulp = require( &apos;gulp&apos; ); 相当于 html 文件中的 script 标签 gulp.task( 名字, function () { // 处理代码 });","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"JS原生框架-5","date":"2016-03-15T10:46:00.000Z","path":"2016/03/15/JS原生框架-5/","text":"常见问题 1&gt; 代码结构 2&gt; 总结: $( &apos;&lt;div&gt;123&lt;/div&gt;&apos; ).appendTo( $( &apos;div&apos; ) ) 1) 如果左边的html字符串是多个元素什么结果, 规律是什么 2) 如果右边的选择器得到的是多个元素, 结果又是什么, 有什么规律 3) 如果两边都是多个元素, 又是什么结果, 什么规律 3&gt; 实现代码 appendTo() 参数为 dom 数组的情况 4&gt; dom 操作整理 jq 案例 … // 鼠标移入的时候有颜色高亮, 鼠标移开的时候颜色恢复 $( ‘#dv’ ).mouseenter(function () { $( this ).addClass... }).mouseleave(function () { $( this ). ... }); iQuery.select = function ( selector ) { return slice.call( document.querySelectorAll( selector ) ); }; //这里直接return document.querySelectorAll( selector)行吗？一定要返回一个真数组吗？ //构造函数中push.apply(this, iQuery.select(selector));传入伪数组也是可以的吧？ var init = iQuery.prototype.init = function (selector) { return [].push.apply(this, iQuery.select(selector)); } iQuery.select = function (selector) { return [].slice.call(document.querySelectorAll(selector)); } 为什么要分成两步，直接[].push.apply(this,document.querySelectorAll(selector))不就好了， 为什么[].slice.call(document.querySelectorAll(selector))转换成真数组再 [].push.apply(this, iQuery.select(selector)) 核心结构中 iQuery.fn = iQuery.prototype = {}; iQuery.prototype.init.prototype = iQuery.fn; 这两句连写成iQuery.prototype.init.prototype = iQuery.fn = iQuery.prototype = {}; 会报错Cannot set property &apos;prototype&apos; of undefined，为什么？ parseHTMl方法中为什么不使用Children？ 当用childNodes时，如果传入的字符串 ‘ &lt;div&gt;&lt;/div&gt; ’两端有空格，得到的数组就会有文本节点存在， 难道不会造成使用问题和性能问题吗？ iQuery.select = function(selector){ slice.call(document.querySelectorAll(selector)); } 用来获取dom对象, var init = iQuery.fn.init = function(){ push.apply(this,iQuery); } 用来初始化函数,是不是多此一举?为什么不直接: var init = iQuery.fn.init = function(){ slice.apply(this,document.querySelectorAll(selector)); } 不是一样么? 如果appendTo方法右边是多个元素, 如何处理 … $( ‘ppp‘ ).appendTo( ‘div’ ); 首先实现 假如 appendTo 方法的参数为 div 数组的时候, 如何处理 处理了 dom 元素, 简答 处理了 dom 数组, 相对容易, 而且就解决了 传入的是 iQuery 对象的情况 appendTo 还可以使用 字符串选择器 function appendTo( selector ) { &lt;!--if ( selector.nodeType ) { } else if( selecto.length &gt;=0 ) { } else if ( typeof selector == &apos;string&apos; ) { var iObj = iQuery( selector ) }--&gt; var IObj= iQuery( selector ); } 说明 appendTo: function ( array ) { var that = this; var arr = I.map( array, function ( v, i ) { return that.map(function ( v1, i1 ) { var node = i === array.length - 1 ? v1 : v1.cloneNode( true ); v.appendChild( node ); return node; }); }); arr = arr.concat,apply( [], arr ); // [ [] ] -&gt; [] return iQuery( arr ); } 实现 prepend 与 prependTo 方法 区别: 1&gt; appendTo 和 prependTo $( &apos;&lt;div&gt;&lt;/div&gt;&apos; ).appendTo( &apos;div&apos; ); 将新创建的 div 加到页面中已有的 div 中的子元素中的结尾处( 追加 ) $( &apos;&lt;div&gt;&lt;/div&gt;&apos; ).prependTo( &apos;div&apos; ); 将新创建的 div 标签加到页面中已有的 div 中的子元素的最前面. 2&gt; append 和 prepend $( &apos;div&apos; ).append( &apos;&lt;p&gt;ppp&lt;/p&gt;&apos; ) $( &apos;div&apos; ).prepend( &apos;&lt;p&gt;ppp&lt;/p&gt;&apos; ) insertBefore 等方法 用法: $( &apos;&lt;p&gt;pppp&lt;/p&gt;&apos; ).insertBefore( &apos;div&apos; ); 将新创建的 p 标签, 插入到 页面中的 所有的 div 元素的前面 如果是单个元素: div.parentNode.insertBefore( newNode, div ); -&gt; f( div, newNode ) 如果是一个数组 div[ i ].parentNode.insertBefore( newNodes[ j ], div[ i ] ) insertAfter 用法: $( &apos;&lt;p&gt;pppp&lt;/p&gt;&apos; ).insertAfter( &apos;div&apos; ); 首先判断是不是最后一个元素: parent.lastChild === currentNode 如果是最后一个元素则 append 如果不是则找到后一个元素, 往前加: currentNode.nextSibling... insertBefore... after 与 before 其他的亲属节点访问方法 .parent() .next() .nextAll() .prev() .prevAll() .siblings()","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"JS原生框架-4","date":"2016-03-09T02:40:48.000Z","path":"2016/03/09/JS原生框架-4/","text":"常见问题 var name = ‘…’ // 张三丰 -&gt; 张* // 李四 -&gt; 李 function convert( name ) { var firstName = name.charAt( 0 ); // 遍历 百家姓 // 如果是复姓 indexOf( ... ) == 0 var lastName = &apos;**********&apos;.slice( 0, name.length - 1 ); return firstName + lastName; } 在 ES6 中引入了箭头函数( 简单的说: 函数的简写形式 ) arr.forEach( function ( v, i ) { // ... }); 1) 删去 function 关键字 2) 利用 =&gt; 链接参数与函数体, 符号 =&gt; 读作 goes to arr.forEach( ( v, i ) =&gt; { // ... }); 注意: 1) 如果参数只有一个, 那么圆括号可以省略 arr.forEach( v =&gt; { console.log( v ); }); 2) 如果方法体只有一句话, {} 可以省略, return 也可以省略 // 例如将数组元素扩大一倍返回 arr.map(function ( v ) { return v * 2; }); // 如果使用箭头函数 arr.map( v =&gt; v*2 ); 3) 在 箭头函数中, 函数内的 this 不再具有新的作用域. 问题 ([|!^$~]?=) 分析[|!^$~]?= 因此它是匹配 = 或 xxx= [|!^$~] 匹配 | 或者 ! 或者 ^ 或者 $ 或者 ~ 因此正则表达式是在匹配 =, |=, !=, ^=, $=, ~= &lt;div class=&quot;main-app aap1 app2 app3&quot;&gt;&lt;/div&gt; [class |= main] function replace( str, regex, callback ) { var arr = regex.exec( str ); // [ 0, 1, ... ] callback.apply( null, arr ) // 字符串拼接 } ^(?:\\s*(&lt;[\\w\\W]+&gt;)[^&gt;]*|#([\\w-]*))$ 分析 (&lt;[\\w\\W]+&gt;)[^&gt;]* 01234567890123 &lt;div&gt;123&lt;/div&gt; &apos; &lt;div&gt; .... &lt;/div&gt; &apos; #([\\w-]*) #名字 核心结构 1) 代码应该写在 单独的文件中 2) 应该具有的成员有什么呢? 构造函数, 暴露的函数接口, 原型, each 和 map 框架的 扩展 所谓的扩展就是给原型或构造方法( iQuery ) 提供新的成员 就是在给一个对象增加新的成员 可以使用混合式. 其思想就是将几个对象的成员混合到一起 extend 扩展 需求: 1) 实现 extend 方法 2) 使得代码尽可能短 // 对原型的处理 iQuery.fn.extend = function ( options ) { for ( var k in options ) { this[ k ] = options[ k ]; } } // 对 iQuery 处理 iQuery.extend = function( options ) { for ( var k in options ) { this[ k ] = options[ k ]; } } // iQuery.extend = iQuery.fn.extend = function ( options ) { for ( var k in options ) { this[ k ] = options[ k ]; } }; 将来在扩展功能的时候怎么用呢? 1) 扩展实例方法 iQuery.fn.extend({ method: function ... }); 2) 扩展静态方法 iQuery.extend( ... ) DOM 操作 appendTo append prependTo prepend insertBefore insertAfter before parent next nextAll prev prevAll siblings parseHTML 要实现一个方法 1) 如何定义其参数与返回值( 返回以dom作为元素的数组 ) 2) 具体的代码实现 ‘‘ ‘‘ function parseHTML ( htmlStr ) { } // 思路: 只需要创建一个 div, 将 字符串赋值给 div 的 innerHTML 属性即可 function parseHTML ( htmlStr ) { var div = document.createElement( &apos;div&apos; ); div.innerHTML = htmlStr; // 转换 // 要返回数组 // return div.childNodes; return [].slice.call( div.childNodes ); } // 思考题: 这里有一个 bug 问题 所有的 dom 元素只允许有一个父元素. 因此将一个 dom 元素 追加到另一个元素里时, 会自动的从原有的父元素中移除. &lt;div&gt;123&lt;/div&gt; &lt;div&gt;456&lt;/div&gt; 将 第 0 个 div 追加到 body 上的时候, 会从原有的位置移除 &lt;div&gt;456&lt;/div&gt; 此时 childNodes 的长度也会自动的 -1, 原来排在第 1 号 位置的 div 也会变成 第 0 号. 将 parseHTML 引入到 框架结构中 修改构造函数, 判断一下, 如果是 字符串结构, 就采用 parseHTML 如果不是字符串结构就用 qsa 方法 在 jq 构造函数中, 参数可以是很多东西 1) 字符串: 1&gt;选择器, 2&gt;HTML 字符串 2) DOM 元素 3) 函数: 相当于 onload 事件 4) jquery 元素 $( &apos;&lt;div /&gt;&apos; ).appendTo( $( &apos;body&apos; ) ); $( &apos;&lt;div /&gt;&apos; ).appendTo( &apos;body&apos; ); 5) 可以是 空 ... 在 init 构造函数中准备一套 if else 结构 处理每一个情况 引入 appendTo 方法 问题: 1&gt; 方法写在哪里? 加到原型中 2&gt; 参数与返回值? 参数: 字符串, dom, iquery 3&gt; 具体的逻辑实现? 实现: 1) 参数为 dom 对象 2) dom 数组怎么处理( *** ) 3) 一般情况 问题 1&gt; 代码结构 2&gt; 总结: $( &apos;&lt;div&gt;123&lt;/div&gt;&apos; ).appendTo( $( &apos;div&apos; ) ) 1) 如果左边的html字符串是多个元素什么结果, 规律是什么 2) 如果右边的选择器得到的是多个元素, 结果又是什么, 有什么规律 3) 如果两边都是多个元素, 又是什么结果, 什么规律 3&gt; 实现代码 appendTo() 参数为 dom 数组的情况 4&gt; dom 操作整理 js 数据类型-&gt; 简单类型: number, string, boolean. 变量存储数据本身.-&gt; 复合类型: 由简单类型或复合类型组合得到是数据类型. 对象: String, Number, Boolean, [], {}, /.+/, ... 函数 由于结构特征, 一二引用数据无法直接确定需要占据多大内存, 因此理论上 变量不能直接存储数据本身. 系统一般会在内存的一个独立区域存储数据本身, 而变量仅仅存储的是 这个数据的 &quot;内存地址&quot;. 常常称为引用. -&gt; 空类型: null, undefined var number1 = 123; var number2 = number1; number1 = 456; var person = { name: &apos;jim&apos;, age: 19, gender: &apos;男&apos;, scores: { chinese: 95, english: 80, math: 70 } }; var stu = person; // 凡是看到等号, 就是将 等号右边的盒子中 的数据 拷贝一份 // 存储到 左边的这个盒子中","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"JS原生框架-3","date":"2016-02-14T02:44:45.000Z","path":"2016/02/14/JS原生框架-3/","text":"每天坚持多看看 今天主要内容：复习经常会遇到的问题整理一下正则表达式的用法 问题 1.为什么 forEach 中的回调函数有第三个参数 arr.forEach( function ( v, i, arr ) { ... } ) 1) 代码要运行就会被解析, 已解析就会创建对象 for ( var i = 0; i &lt; 10; i++ ){ var o = {}; } 2) forEach 与 setInterval 等函数一样, 回调函数会被多次解析 因此会造成一定的 性能问题, 因此应该考虑将函数独立的书写在外面, 使用的时候作为参数传入. // 设置一个非常限制级的条件 // ... function getFoo () { return function foo( v, i, arr ) { // 可以访问到被遍历的数组么? } } // ... function mainFunc( foo ) { // ... arr.forEach( foo ); } // ... mainFunc( getFoo() ) 2.jq 中 map 与 each 中回调函数的参数为什么不同 1) 数组中的参数全部都是 v, i 2) jq 中 map 是 v, i; each 是 i, v arr.forEach(function ( v, i ) { // 操作元素 // 使用 v }) jq 中 map 也是因为使用的频率, 所以 i 在后面, v 在前面 但是 each 呢? 因为 this 就是遍历的对象, 开发的时候基本不会写参数 $.each( nodeList, function () { this.style... } ) 3.$(&quot;&lt;p/&gt;&quot;).appendTo(&quot;div&quot;).addClass(&quot;test&quot;).end().addClass(&quot;test2&quot;) 执行过程 $(&quot;&lt;p/&gt;&quot;) 创建 DOM 对象 -&gt; 包装成 jq 对象 .appendTo(&quot;div&quot;) 追加到页面中的 div 中( 注意: 标签的拷贝 ) .addClass(&quot;test&quot;) 将所有的 p 标签增加 class 演示 .end() 恢复最近的一次破坏, 即一个 p 标签的情况 .addClass(&quot;test2&quot;) 给这一个 p 标签, 添加 类演示 链式编程就是工厂的流水线 工具 everything rquickExpr=/^(?:\\s(&lt;[\\w\\W]+&gt;)[^&gt;]|#([\\w-]*))$/, 老师这个正则表达式能不能讲讲 正则表达式( regular expression ) RegExp 用处: 匹配, 验证; 替换, 截取, 分析 要求: 1&gt; 记住元字符 基本元字符: . 匹配任意的非换行字符, 常常表示通用元字符使用 [\\s\\S] [] 匹配一个出现在 [] 中的字符, [123456789123456789123456789], [a-z0-9A-Z] 计算机只认识 数字, 所以我们写的字符串计算机其实不是以字符串的形式存储 有一个编码系统: unicode &apos;0&apos; 48 &apos;1&apos; 49 ... &apos;9&apos; 57 写上: &apos;012&apos; , 在内存中存储: 48 49 50 需要记住的是: &apos;0&apos; 48 &apos;a&apos; 97 &apos;A&apos; 65 \\u0030 () 1&gt; 分组; 2&gt; 提升优先级 | 或者 匹配 foot 或者 food foot|food 注意: | 具有最低优先级 ^(foot|food)$ 常见的用法 例如要匹配jq的属性选择器: [name] [name=value] 用正则: \\[\\w+=\\w+\\]|\\[\\w+\\] jq 的写法: \\[\\w+(=\\w+|)\\] (foot|food) 匹配: &apos;foot&apos; 或者 &apos;food&apos; (foot|) 匹配: &apos;foot&apos; 或者 &apos;&apos; food(=food|) 匹配: &apos;food=food&apos; 或者 &apos;food&apos; \\w+(=\\w+|) 匹配: &apos;字符=字符&apos; 或 &apos;字符&apos; \\[\\w+(=\\w+|)\\] 匹配: &apos;[xxx]&apos; 或 &apos;[xxx=vvv]&apos; \\[\\s*(\\w+)\\s*(?:([|!^$~]?=)\\s*(\\w+)|)\\s*\\] =&gt; \\[ \\s* (\\w+) \\s* (?: ([|!^$~]?=) \\s* (\\w+) |) \\s* \\] 限定元字符 + (abc)+ {1,} * {0,} ? {n} {n,} {n,m} 首尾元字符 ^ 必须以 xxx 开头 表示否定: [abc] 用来匹配 一个 字符 a, 或 b, 或 c [^abc] 用来匹配一个字符, 要求不允许是 a, b, c $ 必须以 xxx 结尾 表示组引用 a(b)c 简写元字符 \\w word \\W \\s space \\S \\d digit \\D 其他: (?: ) \\1 2&gt; 基本的匹配案例 如何匹配 1) 匹配任意的自然数, 就是 0, 1, 2, 3, ... [0-9] 等价于 \\d 分类讨论 -&gt; 一位数字: \\d -&gt; 两位: [1-9]\\d -&gt; 任意位( 除了一位 ): [1-9]\\d+ 合并: \\d|[1-9]\\d+ 可以进行演变( 用不同的方法写同一个例子 ) [1-9]\\d*|0 [1-9][0-9]*|0 ... 2) 匹配任意的整数, 0, +1, -1, +2, -2, ... [+-]?[1-9][0-9]*|0 (+|-|)[1-9][0-9]*|0 ... 3) 匹配任意的实数, 0.01, 0.0000123, -0.1234567 整数 + 小数部分 分类( 划归 ) ((+|-|)[1-9][0-9]*|0)(\\.\\d+|) 无法匹配 -0.1 无非就是不允许匹配 -0.0+ 使用正则的原则: 够用即可, 尽可能写成多步的判断, 要保证正则表达式的尽可能简洁 -0+(\\.|)0* if ( !... ) { if ( ... ) } \\d{17}|[\\dxX] \\d{11} 4) 匹配邮箱 [^@]+@[^@]+ 如果想要严谨一点 邮箱分成用户名 和 域名 用户名: 可以有数字, 字母下划线组成( 还有一些特殊字符 ) [\\w\\-]+ 域名: xxx.com.cn.xxxx [\\w\\-]+(\\.[\\w\\-]+)+ 5) 匹配 ip 地址 采用数字点分的方法描述, 而且每一个数字的取值在 0-255 之间, 都可以取到 0.0.0.0 255.255.255.255 123.124.125.126 ... \\d{1,3}(\\.\\d{1,3}){3} 或者: \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3} 利用正则实现匹配 0 到 255 的数字 分类: 一位: [0-9] 两位: 10-99 [1-9][0-9] 三位: 100-255 开始为 1 的: 100-199: 1[0-9][0-9] 开始为 2 的: 200-255: 中间为 0-4 的: 2[0-4][0-9] 中间为 5 的: 25[0-5] [0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5] IP: [0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]\\.[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]\\.[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]\\.[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5] 练习: 如配匹配计算机中的一个文件路径全名 例如: C:\\myMusics\\list\\myFavorite\\rain.MP3 盘符: 一个字符: a-z, 简单的写 . 如果想要严格处理 [a-z] 冒号和斜线: :\\\\ 路径(文件夹的名字): .+\\\\ 如果想要精确: ([^|:\\?\\*&gt;&lt;\\\\\\/\\&quot;]+\\\\)* 文件名: .+\\..+ 如果想要精确一点: [^|:\\?\\*&gt;&lt;\\\\\\/\\&quot;]+\\.[^|:\\?\\*&gt;&lt;\\\\\\/\\&quot;]+ 组合起来: .:.*\\\\.+\\..+ 注意: 正则表达式有贪婪模式 C:\\myMusics\\list\\myFavorite\\rain.MP3 .:(.*)\\\\.+\\..+ .:.*\\\\.+.+ 如果一个正则表达式中有多个 .+ 或 .* 的结构, 如果造成了匹配的歧义, 满足一个规则. 即贪婪模式 从左往右 匹配个数的能力是左强又弱, 而且只有两个级别, 要么强, 要么弱 例如: var s = &apos;1234567890&apos;; // 1 2 3 var r = /(.+)(.+)(.+)/; var res = r.exec( s ); 例如匹配 div 标签 var r = /&lt;div.*?&gt;.*&lt;\\/div&gt;/; 如果不希望有贪婪模式在 限定元字符( +, * 等 )后写上 ? 3&gt; 字符串提取( 解析 ) .exec 方法 利用正则表达式, 去处理字符串, 并将字符串中符合正则表达式的数据取出来 var s = &apos;1234567&apos;; var r = /\\d/; var m = r.exec( s ); // m 是 match 的简写, 表示捕获 // 如果匹配上了, 就返回数组, 第 0 项 就是匹配到的结果, 如果正则表达式中有 分组 // 分组都是从 1 开始的编号, 那么对应的 第 n 组匹配到的结果就在这个数组的第 n 项 // 注意: 是真数组 // 如果没有匹配到 则返回 null 分组: 就是 () 从左往右数 (, 第一个开始编号, 从 1 开始编号, 此时编号完成以后, 对应圆括号组成的就是对应的组 // 1 2 34 5 例如: r = /(\\d)(\\d((\\d)\\d))(\\d)/; 做坏事: 想要做一个推广, 在论坛中发布我有XXX的视频, 如果想要的留下邮箱 如果有人留下的是 QQ 号, 将其拉到一个群里 注意: exec 匹配提取, 只能匹配提取第一个被捕获的数据 如果需要匹配字符串中所有符合要求的字符串 1) 开启全局模式, 在正则后面写上一个 g, 或在构造函数的 第二个参数中提供 &apos;g&apos; 创建正则: -&gt; 字面量: /.+\\\\.+/g -&gt; 构造函数: new RegExp( &apos;.+\\\\\\\\.+&apos;, &apos;g&apos; ) 2) 开启全局模式后, 使用 正则表达式对象 调用 exec 方法一次, 就会从 0 位置或上一次结束的位置开始 查找下一个匹配结果, 如果查找到结果则返回对应数组, 如果没有查找到( 即, 找完了 )就会返回 null. 如果还继续调用 exec, 那么就从头开始再查一次. 例如: var s = &apos;123&apos;; var r = /\\d/g; r.exec( s ); // [ &apos;1&apos; ] r.exec( s ); // [ &apos;2&apos; ] r.exec( s ); // [ &apos;3&apos; ] r.exec( s ); // null r.exec( s ); // [ &apos;1&apos; ] ... 一般要取到所有的数据, 可以使用下面的代码结构 var m; while ( ( m = r.exec( s ) ) != null ) { // 此时 m 就是找到的结果 } 练习: 1) 将文章中所有的数字提取出来 2) 将文章中所有的邮箱提取出来 ... 4&gt; 字符串替换 .replace( 正则表达式, 需要替换的字符串 ) 1) 将一个字符串中所有的 - 换成一个连线 var s = &apos;a-----------------------------------b----------------------c----d&apos;; // =&gt; a-b-c-d var res = s.replace( /-+/g, &apos;-&apos; ); 应用背景 /\\*.*?([\\r\\n]+.*?)*\\*/ 换行: \\r\\n 因此 \\r 是回车的意思 \\n 是换行的意思 平时在处理换行的时候要注意: 在 有些时候是 \\r\\n, 有些时候是 \\n 在 类 Unix 操作系统中( unix, linux, mac ) 换行都是 \\n 在 windows 中是 换行是 \\r\\n 2) 在替换中还可以使用组 var s = &apos;2012-3-4&apos;; // 在不同的系统中想要显示成 // 2012年3月4日 // 3月4日2012年 // 4/3/2012 // ... var r = /(\\d+)\\-(\\d+)\\-(\\d+)/; var res = s.replace( r, &apos;$1年$2月$3日&apos; ) 3) 替换的时候, 第二参数可以是函数, 函数的参数为, 匹配到的数组的散列值 利用函数的返回值替换匹配到的结果 var s = &apos;2012-3-4&apos;; var r = /(\\d+)\\-(\\d+)\\-(\\d+)/; s.replace( r, function ( match, g1, g2, g3 ) { return g1 + &apos;年&apos; + g2 + &apos;月&apos; + g3 + &apos;日&apos;; }); 电话号码的加密 var list = [ &apos;12345678901&apos;, &apos;12345678912&apos;, &apos;12345678923&apos;, &apos;12345678934&apos;, &apos;12345678945&apos;, &apos;12345678956&apos; ]; var res = list.map( function ( v ) { // 电话号码的前4位 // 电话号码的后 2 位 return v.replace( /(\\d{4})(\\d+)(\\d{2})/, function ( a, b, c, d ) { // a 就是匹配到的 电话号码 // b 就是匹配到的 电话号码的前 4 位 // c 就是匹配到的电话号码的 中间 5 位 // d 就是匹配到的电话号码的 后 2 位 return b + &apos;***********&apos;.slice( 0, c.length ) + d; // return b + &apos;*****&apos; + d; }); }); (?:) var s = &apos;1234567&apos;; // 1 2 3 4 var r1 = /(\\d)(\\d\\d\\d)(\\d\\d)(\\d)/; r1.exec( s ); // =&gt; [ &apos;1234567&apos;, &apos;1&apos;, &apos;234&apos;, &apos;56&apos;, &apos;7&apos; ] \\ // 1 2 3 var r2 = /(\\d)(?:\\d\\d\\d)(\\d\\d)(\\d)/; r2.exec( s ); // =&gt; [ &apos;1234567&apos;, &apos;1&apos;, &apos;56&apos;, &apos;7&apos; ]","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"JS原生框架-2","date":"2016-02-12T11:41:29.000Z","path":"2016/02/12/JS原生框架-2/","text":"迭代 就是循环 产品迭代, 将一个产品做出来, 做出一个 “稳定” 版本. 在其基础上通过需求调整, 算法的调整等等一系列调整得到一个新的 “稳定” 版本. 这个过程就是迭代过程. 例如使用 DOM-Core 方法设置 div 的样式 设置 div 的宽度为 300px div.style.width = ‘300px’; div.setAttribute( ‘style’, ‘width: 300px; height: 100p; border: 1px dashed red;’ ) var style = div.getAttribute( ‘style’ ); var styles = style.split( ‘;’ ); var styleObj = {}; styles.forEach(function ( v ) { var tmp = v.split( &apos;:&apos; ); // 要修改样式只需要修改对象的属性即可 styleObj[ tmp[ 0 ] ] = tmp[ 1 ]; }); // … // 要修改样式只需要修改对象的属性即可, 最后要修改标签的时候 var style2 = $.map( styleObj, function ( v, k ) { return k + &apos;:&apos; + v; }).join( ‘;’ ); //将返回的数组 join成字符串，之间用 ; 连接。 // … 在 jq 中 append 表示的是追加, 含义是将 后面参数中的 DOM 追加到 前面 对象的 子元素的结尾处. 与 appendChild 一致. $( &apos;body&apos; ).append( $( &apos;&lt;img src=&quot;....jpg&quot;/&gt;&apos; ) ) 与 body.appendChild( img ) 是一样的 appendTo 表示追加, 含义讲前面的元素 追加到 后面的元素的子元素的结尾处. $( &apos;&lt;img src=&quot;...jpg&quot;/&gt;&apos; ).appendTo( &apos;body&apos; ) function each( arr, callback ) { } each( [ 1, 2, 3 ], function ( v, i ) { // ... }) 1&gt; 函数中如果没有代码 数组的每一项就什么也不做 2&gt; 函数中写什么代码 数组中的每一项就做什么事情 3&gt; 也就是说函数在处理数组的每一项 由于要处理每一项, 因此必须要遍历数组的每一个元素 即有 function each( arr, callback ) { for ( var i= 0; i &lt; arr.length; i++ ) { var item = arr[ i ]; } } 使用函数处理每一项就是用函数处理 item 就是说将 item 传入函数处理 function each( arr, callback ) { for ( var i= 0; i &lt; arr.length; i++ ) { var item = arr[ i ]; callback( item ); } } // 按照 数组的 forEach 方法实现 自己的 each 方法 // 要求 有两个参数, 一个是需要遍历的数组, 一个是回调函数, 要求回调函数有两个参数, 分别是 v, i function each( arr, callback ) { for ( var i = 0; i &lt; arr.length; i++ ) { callback( arr[ i ], i ); } } // 改良第一步, 添加 this 的引用, 参数向 jq 靠拢 function each( arr, callback ) { for ( var i = 0; i &lt; arr.length; i++ ) { callback.call( arr[ i ], i, arr[ i ] ); } } // 第二次改良, 在返回 false 的时候跳出循环, 注意, 返回 undefined, 0, 等不会跳出 // 所以这里一定有一个 完全等于 , 跳出循环就是跳出 each 函数内的 for 即需要 break function each( arr, callback ) { for ( var i = 0; i &lt; arr.length; i++ ) { if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break; } } // 第三个改良就是返回被遍历的对象 function each( arr, callback ) { for ( var i = 0; i &lt; arr.length; i++ ) { if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break; } return arr; } 遍历对象与遍历数组 有什么区别? -&gt; 遍历对象是将对象的所有键值对遍历出来( 包括自然数项, 如果有的话 ) -&gt; 遍历数组就是在遍历自然数项 让我们的 each 方法可以遍历对象 要求, 不考虑数组, 只用 each 遍历对象 代码怎么写? function each( obj, callback ) { for ( var k in obj ) { if ( callback.call( obj[ k ], k, obj[ k ] ) === false ) break; } return obj; } 判断是不是 数组或伪数组 的依据就是 length &gt;= 0 对象没有length属性; function each( arr, callback ) { if ( arr.length &gt;= 0 ) { for ( var i = 0; i &lt; arr.length; i++ ) { if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break; } } else { for ( var k in arr ) { if ( callback.call( arr[ k ], k, arr[ k ] ) === false ) break; } } return arr; } 封装 map 首先考虑, 只是处理 v 返回 结果( 实现一个 与 数组 的 map 一样的方法 ) function map( arr, callback ) { var rest = []; for ( var i = 0; i &lt; arr.length; i++ ) { // 要返回的数据是 回调函数的 返回值 rest.push( callback( arr[ i ], i ) ); } return rest; } // 向 jq 靠拢 // 1&gt; 不返回则不加到数组中 // 2&gt; 遍历对象 function map( arr, callback ) { var rest = [], tmp; if ( arr.length &gt;= 0 ) { for ( var i = 0; i &lt; arr.length; i++ ) { //为什么是 null，如果 return undefined；jq中没有return 是【】。 tmp = callback( arr[ i ], i ); if ( tmp != null ) { rest.push( tmp ); } } } else { for ( var k in arr ) { tmp = callback( arr[ k ], k ); if ( tmp != null ) { rest.push( tmp ); } } } return rest; } 再回到原始的问题 使用 jq 来实现, 应该怎么写 $( ‘div, p’ ).each( … ) 在 jq 中有两组遍历方法, 一个是静态的 each 和 map, 例如 $.map( arr, callback ) $.each( arr, callback ) 静态的方法遍历的是传入的对象或数组 除此之外 jq 还提供了一组实例方法 $( ... ).each( function () { ... } ) $( ... ).map( function () { ... } ) 实例方法中遍历当前 jq 对象. $( &apos;div&apos; ) jq 的本质就是 伪数组 利用 jq 判断页面中某一个元素是否存在: $( ‘…’ ).length &gt; 0 框架的核心结构 需求: 1&gt; 有一个函数, 可以实现元素的获取功能( select -&gt; Array ) 2&gt; 这个函数返回的对象具有 each 方法. 该方法只有一个 回调函数的 参数, 用于遍历每一个对象. 先把函数写出来 function I( selector ) { } 该函数可以获取元素 function I( selector ) { var list = document.querySelectorAll( selector ); // 伪数组 } 返回的数据应该就是这个 list, 但是又需要有 each 所以可以考虑直接让 list 带有 each 方法 //list.each = function(callback){ //将其每一项传到回调函数中，each(this,callback); //}; function I( selector ) { var list = document.querySelectorAll( selector ); // 伪数组 list.each = function ( callback ) { // 调用 该方法就是在 遍历 list 并将每一个元素用 callback 进行处理 each( this, callback ); } return list } 引入构造函数( init ) 知道 list 是一个有 qsa 方法返回的对象, 每次提供 each 方法不合理, 而且 jq 有很多方法 所以借助 oop 的知识应该使用 继承. 利用构造函数来创建 “list 对象”, 但是继承自提供 each 等方法的原型对象. function F( selector ) { // 给 this 加 伪数组项 } F.prototype.each = function () { } 考虑到 list 中每次都添加方法不合理, 而且冗余, 因此使用构造函数创建对象( 伪数组 ). 让构造函数.prototype 提供各种方法, 那么实例对象( 伪数组 )就可以使用这些方法了. function F( selector ) { // 给 this 加 伪数组项 var list = document.querySelectorAll( selector ); for( var i = 0; i &lt; list.length; i++ ) { this[ i ] = list[ i ]; } this.length = list.length; } F.prototype.each = function ( callback ) { each( this, callback ); }; 升级一下 function F( selector ) { // 给 this 加 伪数组项 //这一步是给 新建对象初始化，将伪数组每一项附给 this。 [].push.apply( this, document.querySelectorAll( selector ) ); } F.prototype.each = function ( callback ) { each( this, callback ); }; 如何使用呢? new F( ‘div, p’ ).each( … ) 隐藏 new 关键字 考虑引入函数 function iQuery( selector ) { return new F( selector ); } var I = iQuery; 引入沙箱 从沙箱中如果要暴露一些函数或对象采用方法有三种( 常用 ) 1&gt; 利用 window 参数 (function ( window ) { window.xxx = vvv; })( window ); 2&gt; 利用 返回值( 例如 Sizzle ) var Sizzle = (function () { return xxx; })(); 3&gt; 利用 this 映射 (function () { // 这里的this 代表window。 this.xxx = vvv; })(); 缺点: 1&gt; 代码结构凌乱. 优化结构. 2&gt; 无法实现扩展, 只有在该文件中实现代码结构. // ?不是引入沙箱模式了吗？ 可扩展性 1&gt; 可以将 iQuery 的一个属性指向构造函数 var iQuery = function ( selector ) { return new F( selector ); }; ... iQuery.F = F; ... 此时对外的扩展 iQuery.F.prototype.xxx = vvv; 2&gt; 在 jq 中采用是原型映射的办法, jq 中将 对外公开的 jquery 函数 与 构造函数 的原型用一个对象表示 // 类比 F.prototype = {}; iQuery.prototype = F.prototype; //=============================================================== var jQuery = function ( selector ) { return ...( selector ); }; jQuery.prototype = { // 对象 constructor: jQuery, each: function () .... }; var init = function ( selector ) { // ... 构造函数 ... // [].push.apply( this, document.querySelectorAll( selector ) ); }; init.prototype = jQuery.prototype; //=============================================================== // 在 jq 中又 进一步处理 // 将 init 函数作为 jquery 的原型的一个方法 // 将所有的方法挂载到 jQuery 上, 便于优化与更新 //init应该指的是构造函数，目的是为了在外面能够直接修改方法。 // jquery 1.7 以后的写法 var jQuery = function ( selector ) { return new init1( selector ); return new jQuery.fn.init( selector ); }; jQuery.fn = jQuery.prototype = { // 对象 constructor: jQuery }; var init1 = jQuery.fn.init = function ( selector ) { // ... }; //静态成员？ //这一步存在的意义？ //答：因为在外界如果要改构造函数方法。需要jQuery.fn.init 才能访问到 构造函数，那么问题来了，因为外界不知道有这么一个 init方法。所以，可以让构造函数的原型和 jQuery 公用一个原型，这样就能通过修改jQuery的原型，进而对构造函数进行修改。 init1.prototype = jQuery.fn; 等价的写法 // jquery 1.7 以前的写法 var jQuery = function ( selector ) { return new jQuery.fn.init( selector ); }; jQuery.fn = jQuery.prototype = { // 对象 constructor: jQuery, init: function ( selector ) { // ... } }; jQuery.fn.init.prototype = jQuery.fn; 代码结构 1.为什么 forEach 中的回调函数会有第三个参数 arr.forEach( function ( v, i, arr ){ 1) 代码要运行就会被解析，一解析就会创建对象 }","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"JS原生框架-1","date":"2016-02-08T11:35:45.000Z","path":"2016/02/08/JS原生框架-1/","text":"原生框架 -&gt; 注意: 不是在重复造轮子. -&gt; 把学习到的 js 等知识用起来 -&gt; 学习背后的思想( 提升, 面试 ) -&gt; 准备工作 -&gt; js 语言入门: 1) 所有关键字( delete, in ), 2) 学会字符串操作, 3) 数组操作, 4) 键值对的使用( 容易 ) -&gt; 熟悉 jquery -&gt; 基本的 DOM 操作 -&gt; OOP (面向对象编程 ) 内容分类 -&gt; 选择模块 -&gt; 框架的核心结构 -&gt; DOM 操作 -&gt; 事件与属性和样式 -&gt; 插件机制 -&gt; 工具 案例 将下列 div 与 p 标签添加 1px solid red 样式 div span P span div span P span div span P DOM 操作的要求 -&gt; 学会分析 DOM 树 绘制 DOM 树( 标准 代码需要与图对象 ) -&gt; 增删改查的方法 查: document.getElementById() document.getElementsByTagName() document.getELementsByClassName() document.getElementsByName() document.querySelector() document.querySelectorAll() -&gt; 访问亲属节点深度为 2 级 如何访问父节点 如果访问兄弟节点 如何访问子节点 DOM 常用属性 .nodeName 标签名, 都是大写 .nodeType 获得节点的类型: 1, 元素; 2, 属性; 3, 文本 .nodeValue 常常用于文本节点, 表示文本的内容 利用数据, 生成 table var data = [ { name:&apos;jim1&apos;, age:19, gender: &apos;女&apos; }, { name:&apos;jim2&apos;, age:9, gender: &apos;男&apos; }, { name:&apos;jim3&apos;, age:29, gender: &apos;女&apos; }, { name:&apos;jim4&apos;, age:39, gender: &apos;女&apos; }, { name:&apos;jim5&apos;, age:49, gender: &apos;男&apos; }, { name:&apos;jim6&apos;, age:59, gender: &apos;男&apos; } ]; // 利用这个数据在 也没中 生成一个 table, 要求: 不用考虑 thead 等元素, 只考虑 tbody 即可 假定页面为 &lt;input type=&quot;button&quot; value=&quot;点击生成表格&quot; id=&quot;btn&quot;/&gt; select( '#btn' ).onclick = function () { // ... }; 答疑 -&gt; NodeList 该数据就是一个伪数组的数据类型 HTMLCollection NodeList 用于描述一个集合数据类型( 伪数组 ) -&gt; slice.call 问 [].slice.call Array.prototype.slice.call rest.slice.call 有什么区别? var o = { method: function () {} }; o.method(); o.method.call( ... ) var f = o.method; f.call( ... ); -&gt; apply call 参数 -&gt; 概念 [].push.apply( rest, list ); 相当于 rest.push( &quot;list&quot; ) [].push.call( rest, list ); 相当于 rest.push( &quot;list&quot; ) -&gt; call 与 apply 的参数 -&gt; 第一个参数: 如果是基本类型( string, number, boolean ) 会转换成包装类型( String, Number, Boolean ) 如果是引用类型( 非空 ), this 就是它( 相当于方法调用 ) 如果是空( null 与 undefined ) 那么 this 就是 window -&gt; 第二个+参数 apply 只有两个参数, 第二个参数一定是一个数组( 伪数组 ) func.apply( obj, [ a, b, c, ..., n ] ) 等价于 func( a, b, c, ..., n ) call 将参数散列处理, 函数调用时怎么传参, call 就怎么传参 func.call( obj, a, b, c, ..., n ) 等价于 func( a, b, c, ..., n ) -&gt; 既然有 call 为何还要有 apply var arr = [ 1, 2 ]; arr.push( 3, 4, 5, 6, 7 ); var weiArray = { 0:1, 1:2, 2:3, length: 3 }; var zhenArray = [ 1, 2 ]; [].push.call( zhenArray, weiArray ); =&gt; zhenArray.push( weiArray ); [].push.apply( zhenArray, weiArray ); =&gt; zhenArray.push( ...weiArray ) -&gt; 关联数组的用法 var o = { name:&apos;jim&apos;, age: 19, gender: &apos;男&apos; }; // 点语法访问( 硬编码 ) // o.name // 如果想要提供一个功能, 用户输入什么就访问什么 if ( input === &apos;name&apos; ) { o.name .... } else if ( input === &apos;age&apos; ) { o.age .... } else if ( input === &apos;gender&apos; ) { o.gender .... } ... ... // js 允许像使用数组一样使用对象, 只需要提供 属性的名字即可 // o[ 名字 ] o[ input ] =&gt; o[ &apos;name&apos; ] o[ &apos;age&apos; ] o[ &apos;gender&apos; ] ... ... DOM-Core 与 HTML DOM 在 实际开发中, 有很多数据使用 XML 格式来进行表示的( win 新的技术( WPF ), 安卓界面, 苹果的界面, … ) 在处理这数据的时候 通用方法称为 核心 DOM 方法 111211121112 在实际应用 HTML 飞速发展, 因此在处理 HTML 的时候给出了一些快速处理的 api, 这些 api 就称为 HTML-DOM HTML-DOM, 首先是 DOM 方法, 适用于 HTML 文档 给 body 标签增加一个 itcast 属性","tags":[{"name":"js","slug":"js","permalink":"https://hanjinbao.cn/tags/js/"}]},{"title":"通知","date":"2016-01-02T02:51:59.000Z","path":"2016/01/02/通知/","text":"callback callbackcallback callback callbackcallback callback callback1callback callback callback callback callback callback","tags":[]}]
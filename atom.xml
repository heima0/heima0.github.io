<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人间客栈</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://heima0.github.io/"/>
  <updated>2022-11-13T04:27:24.713Z</updated>
  <id>https://heima0.github.io/</id>
  
  <author>
    <name>Mr.Han</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络协议-01</title>
    <link href="https://heima0.github.io/2022/11/13/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-01/"/>
    <id>https://heima0.github.io/2022/11/13/网络协议-01/</id>
    <published>2022-11-13T03:43:31.000Z</published>
    <updated>2022-11-13T04:27:24.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络协议-01"><a href="#网络协议-01" class="headerlink" title="网络协议-01"></a>网络协议-01</h1><p>《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类没法儿沟通，达不成“协议”，通天塔的计划就失败了。但是千年以后，有一种叫“程序猿”的物种，敲着一种这个群体通用的语言，连接着全世界所有的人，打造这互联网世界的通天塔。如今的世界，正是因为互联网，才连接在一起。</p><h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><ul><li><p>语法，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。</p></li><li><p>语义，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。</p></li><li><p>顺序，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。</p></li></ul><h3 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h3><blockquote><p>Windows 上是 ipconfig，在 Linux 上是 ifconfig。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络协议-01&quot;&gt;&lt;a href=&quot;#网络协议-01&quot; class=&quot;headerlink&quot; title=&quot;网络协议-01&quot;&gt;&lt;/a&gt;网络协议-01&lt;/h1&gt;&lt;p&gt;《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类没法儿沟
      
    
    </summary>
    
    
      <category term="网络" scheme="https://heima0.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="https://heima0.github.io/2022/11/12/ES6/"/>
    <id>https://heima0.github.io/2022/11/12/ES6/</id>
    <published>2022-11-12T02:28:04.000Z</published>
    <updated>2022-11-12T14:02:35.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6-ES13"><a href="#ES6-ES13" class="headerlink" title="ES6-ES13"></a>ES6-ES13</h3><h4 id="一-走入ES6"><a href="#一-走入ES6" class="headerlink" title="一. 走入ES6"></a>一. 走入ES6</h4><h5 id="1-初识ES6"><a href="#1-初识ES6" class="headerlink" title="1.初识ES6"></a>1.初识ES6</h5><blockquote><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p></blockquote><ul><li><p>1997年：ECMAScript 1.0</p></li><li><p>1998年：ECMAScript 2.0</p></li><li><p>1999年：ECMAScript 3.0</p></li><li><p>2006年：ECMAScript 4.0 未通过</p></li><li><p>2009年：ECMAScript 5.0</p></li><li><p>2015年：ECMAScript 6.0</p></li><li><p>至今，版本号改用年号的形式。</p></li></ul><h5 id="2-let声明变量与const声明常量"><a href="#2-let声明变量与const声明常量" class="headerlink" title="2.let声明变量与const声明常量"></a>2.let声明变量与const声明常量</h5><ol><li><p><code>let</code> 不允许重复声明变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var 的时候重复声明变量是没问题的，只不过就是后面会把前面覆盖掉</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">200</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 let 重复声明变量的时候就会报错了</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">200</span> <span class="comment">// 这里就会报错了</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 const 重复声明变量的时候就会报错</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">200</span> <span class="comment">// 这里就会报错了</span></span><br></pre></td></tr></table></figure></li><li><p><code>let</code> 和 <code>const</code> 声明的变量不会在预解析的时候解析（也就是没有变量提升）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为预解析（变量提升）的原因，在前面是有这个变量的，只不过没有赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 let 不会进行预解析（变量提升），所以直接报错了</span></span><br><span class="line"><span class="built_in">console</span>.log(num) </span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 const 不会进行预解析（变量提升），所以直接报错了</span></span><br><span class="line"><span class="built_in">console</span>.log(num) </span><br><span class="line"><span class="keyword">const</span> num = <span class="number">100</span></span><br></pre></td></tr></table></figure></li><li><p><code>let</code> 和 <code>const</code> 声明的变量会被所有代码块限制作用范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 声明的变量只有函数能限制其作用域，其他的不能限制</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 声明的变量，除了函数可以限制，所有的代码块都可以限制其作用域（if/while/for/...）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p><code>let</code> 和 <code>const</code> 的区别</p><ol><li><p><code>let</code> 声明的变量的值可以改变，<code>const</code> 声明的变量的值不可以改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line">num = <span class="number">200</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line">num = <span class="number">200</span> <span class="comment">// 这里就会报错了，因为 const 声明的变量值不可以改变（我们也叫做常量）</span></span><br></pre></td></tr></table></figure></li><li><p><code>let</code> 声明的时候可以不赋值，<code>const</code> 声明的时候必须赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num</span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num <span class="comment">// 这里就会报错了，因为 const 声明的时候必须赋值</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h5 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h5><ul><li>解构赋值，就是快速的从对象或者数组中取出成员的一个语法方式</li></ul><h6 id="3-1-解构对象"><a href="#3-1-解构对象" class="headerlink" title="3-1 解构对象"></a>3-1 解构对象</h6><ul><li><p>快速的从对象中获取成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的方法想得到对象中的成员</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'miller'</span>,</span><br><span class="line">  age: <span class="number">100</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = obj.name</span><br><span class="line"><span class="keyword">let</span> age = obj.age</span><br><span class="line"><span class="keyword">let</span> gender = obj.gender</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构赋值的方式从对象中获取成员</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'miller'</span>,</span><br><span class="line">  age: <span class="number">100</span>,</span><br><span class="line">  gender: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面的 &#123;&#125; 表示我要从 obj 这个对象中获取成员了</span></span><br><span class="line"><span class="comment">// name age gender 都得是 obj 中有的成员</span></span><br><span class="line"><span class="comment">// obj 必须是一个对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age, gender &#125; = obj</span><br></pre></td></tr></table></figure></li></ul><h6 id="3-2-解构数组"><a href="#3-2-解构数组" class="headerlink" title="3-2 解构数组"></a>3-2 解构数组</h6><ul><li><p>快速的从数组中获取成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的方式从数组中获取成员</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'miller'</span>, <span class="string">'tiechui'</span>, <span class="string">'gangdan'</span>]</span><br><span class="line"><span class="keyword">let</span> a = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> b = arr[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> c = arr[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用解构赋值的方式从数组中获取成员</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'miller'</span>, <span class="string">'tiechui'</span>, <span class="string">'gangdan'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面的 [] 表示要从 arr 这个数组中获取成员了</span></span><br><span class="line"><span class="comment">// a b c 分别对应这数组中的索引 0 1 2</span></span><br><span class="line"><span class="comment">// arr 必须是一个数组</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-模版字符串"><a href="#4-模版字符串" class="headerlink" title="4. 模版字符串"></a>4. 模版字符串</h5><ul><li><p>ES5 中我们表示字符串的时候使用 <code>&#39;&#39;</code> 或者 <code>&quot;&quot;</code></p></li><li><p>在 ES6 中，我们还有一个东西可以表示字符串，就是 <strong><code></code></strong>（反引号）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`hello world`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str) <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li><li><p>和单引号、双引号的区别</p><ol><li><p>反引号可以换行书写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个单引号或者双引号不能换行，换行就会报错了</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello world'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个就报错了</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'hello </span></span><br><span class="line"><span class="string">world'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string"> hello</span></span><br><span class="line"><span class="string"> world</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// 是可以使用的</span></span><br></pre></td></tr></table></figure></li><li><p>反引号可以直接在字符串里面拼接变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 需要字符串拼接变量的时候</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span> + num + <span class="string">'world'</span> + num</span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// hello100world100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接写在字符串里面不好使</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'hellonumworldnum'</span></span><br><span class="line"><span class="built_in">console</span>.log(str2) <span class="comment">// hellonumworldnum</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版字符串拼接变量</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`hello<span class="subst">$&#123;num&#125;</span>world<span class="subst">$&#123;num&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// hello100world100</span></span><br></pre></td></tr></table></figure><ul><li>在 <strong><code></code></strong> 里面的 <code>${}</code> 就是用来书写变量的位置</li></ul></li></ol></li></ul><h5 id="5-字符串扩展"><a href="#5-字符串扩展" class="headerlink" title="5.字符串扩展"></a>5.字符串扩展</h5><h6 id="5-1-includes函数"><a href="#5-1-includes函数" class="headerlink" title="5-1 includes函数"></a>5-1 includes函数</h6><p>判断字符串中是否存在指定字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myname = <span class="string">"miller"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myname.includes(<span class="string">"e"</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(myname.startsWith(<span class="string">"k"</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(myname.endsWith(<span class="string">"n"</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h6 id="5-2-repeat函数"><a href="#5-2-repeat函数" class="headerlink" title="5-2 repeat函数"></a>5-2 repeat函数</h6><p>repeat()方法返回一个新字符串,表示将原字符串重复n次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myname = <span class="string">"miller"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myname.repeat(<span class="number">3</span>)) <span class="comment">//millermillermiller</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myname.repeat(<span class="number">0</span>)) <span class="comment">//"" </span></span><br><span class="line"><span class="built_in">console</span>.log(myname.repeat(<span class="number">3.5</span>)) <span class="comment">//millermillermiller</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myname.repeat(<span class="string">"3"</span>))<span class="comment">//millermillermiller</span></span><br></pre></td></tr></table></figure><h5 id="6-数值扩展"><a href="#6-数值扩展" class="headerlink" title="6.数值扩展"></a>6.数值扩展</h5><h6 id="6-1-二进制和八进制表示法"><a href="#6-1-二进制和八进制表示法" class="headerlink" title="6-1 二进制和八进制表示法"></a>6-1 二进制和八进制表示法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count1 = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> count2 = <span class="number">0x100</span></span><br><span class="line"><span class="keyword">let</span> count3 = <span class="number">0o100</span></span><br><span class="line"><span class="keyword">let</span> count4 = <span class="number">0b100</span></span><br></pre></td></tr></table></figure><h6 id="6-2-isFinite与isNaN方法"><a href="#6-2-isFinite与isNaN方法" class="headerlink" title="6-2 isFinite与isNaN方法"></a>6-2 isFinite与isNaN方法</h6><p>减少全局性方法，使得语言逐步模块化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">Number</span>.isFinite(<span class="number">100</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>.isFinite(<span class="number">100</span>/<span class="number">0</span>) <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">Number</span>.isFinite(<span class="string">"100"</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">Number</span>.isNaN(<span class="number">100</span>) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">Number</span>.isNaN(<span class="string">"miller"</span>) <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">Number</span>.isNaN(<span class="string">"100"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</p><h6 id="6-3-isInteger方法"><a href="#6-3-isInteger方法" class="headerlink" title="6-3 isInteger方法"></a>6-3 isInteger方法</h6><p>用来判断一个数值是否为整数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">Number</span>.isInteger(<span class="number">100</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>.isInteger(<span class="number">100.0</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">Number</span>.isInteger(<span class="string">"miller"</span>) <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">Number</span>.isInteger(<span class="string">"100"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h6 id="6-4-极小常量Number-EPSILON"><a href="#6-4-极小常量Number-EPSILON" class="headerlink" title="6-4 极小常量Number.EPSILON"></a>6-4 极小常量Number.EPSILON</h6><p>它表示 1 与大于 1 的最小浮点数之间的差。2.220446049250313e-16</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-b)&lt;<span class="built_in">Number</span>.EPSILON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEqual(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span>+<span class="number">0.2</span>===<span class="number">0.3</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h6 id="6-5-Math-trunc"><a href="#6-5-Math-trunc" class="headerlink" title="6-5 Math.trunc"></a>6-5 Math.trunc</h6><p>将小数部分抹掉,返回一个整数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">1.2</span>)) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">1.8</span>))<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-1.8</span>)) <span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-1.2</span>))<span class="comment">//-1</span></span><br></pre></td></tr></table></figure><h6 id="6-6-Math-sign"><a href="#6-6-Math-sign" class="headerlink" title="6-6 Math.sign"></a>6-6 Math.sign</h6><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-100</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">100</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-0</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">"miller"</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h5 id="7-数组扩展"><a href="#7-数组扩展" class="headerlink" title="7.数组扩展"></a>7.数组扩展</h5><h6 id="7-1-扩展运算符"><a href="#7-1-扩展运算符" class="headerlink" title="7-1 扩展运算符"></a>7-1 扩展运算符</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...arr1,...arr2])</span><br></pre></td></tr></table></figure><h6 id="7-2-Array-from"><a href="#7-2-Array-from" class="headerlink" title="7-2 Array.from"></a>7-2 Array.from</h6><p>将类数组对象转换为真正数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oli = <span class="built_in">document</span>.querySelectorAll(<span class="string">"li"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(oli))</span><br></pre></td></tr></table></figure><h6 id="7-3-Array-of"><a href="#7-3-Array-of" class="headerlink" title="7-3 Array.of"></a>7-3 Array.of</h6><p>将一组值转化为数组,即新建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)<span class="comment">// [,,]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h6 id="7-4-find方法"><a href="#7-4-find方法" class="headerlink" title="7-4. find方法"></a>7-4. find方法</h6><p>1)该方法主要应用于查找第一个符合条件的数组元素 </p><p>2)它的参数是一个回调函数。在回调函数中可以写你要查找元素的条件,当条件成立为true时,返回该元素。如果没有符合条件的元素,返回值为undefined </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">13</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">13</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">//14</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><h6 id="7-5-fill方法"><a href="#7-5-fill方法" class="headerlink" title="7-5. fill方法"></a>7-5. fill方法</h6><p>使用自己想要的参数替换原数组内容,但是会改变原来的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">"miller"</span>)</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="string">"miller"</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)<span class="comment">//['miller', 'miller', 'miller']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="comment">// ['a', 'miller', 'c']</span></span><br></pre></td></tr></table></figure><h6 id="7-6-flat与flatMap方法"><a href="#7-6-flat与flatMap方法" class="headerlink" title="7-6 flat与flatMap方法"></a>7-6 flat与flatMap方法</h6><p>按照一个可指定的深度递归遍历数组,并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [&#123;</span><br><span class="line">                name: <span class="string">"A"</span>,</span><br><span class="line">                list: [<span class="string">"鞍山"</span>, <span class="string">"安庆"</span>, <span class="string">"安阳"</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">"B"</span>,</span><br><span class="line">                list: [<span class="string">"北京"</span>, <span class="string">"保定"</span>, <span class="string">"包头"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">]</span><br><span class="line"><span class="built_in">console</span>.log(obj.flatMap(<span class="function"><span class="params">item</span> =&gt;</span> item.list))</span><br></pre></td></tr></table></figure><h5 id="8-对象扩展"><a href="#8-对象扩展" class="headerlink" title="8.对象扩展"></a>8.对象扩展</h5><h6 id="8-1-对象简写"><a href="#8-1-对象简写" class="headerlink" title="8-1 对象简写"></a>8-1 对象简写</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name =<span class="string">"moduleA"</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name,</span><br><span class="line">    test1()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    test2()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="8-2-属性名表达式"><a href="#8-2-属性名表达式" class="headerlink" title="8-2 属性名表达式"></a>8-2 属性名表达式</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name =<span class="string">"moduleA"</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name,</span><br><span class="line">    [name+<span class="string">"test1"</span>]()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    [name+<span class="string">"test2"</span>]()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="8-3-Object-assign"><a href="#8-3-Object-assign" class="headerlink" title="8-3 Object.assign"></a>8-3 Object.assign</h6><p>Object.assign(target, object1，object2)的第一个参数是目标对象，后面可以跟一个或多个源对象作为参数。</p><p>target：参数合并后存放的对象</p><p>object1：参数1</p><p>object2：参数2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"miller"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    name:<span class="string">"tiechui"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">    age:<span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(obj1, obj2, obj3);</span><br><span class="line"><span class="comment">//obj1 &#123;name: 'tiechui', age: 100&#125;</span></span><br></pre></td></tr></table></figure><h6 id="8-4-Object-is"><a href="#8-4-Object-is" class="headerlink" title="8-4 Object.is"></a>8-4 Object.is</h6><p>方法判断两个值是否是相同的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>===<span class="literal">NaN</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span>===<span class="number">-0</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>,<span class="number">-0</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h5 id="9-函数扩展"><a href="#9-函数扩展" class="headerlink" title="9.函数扩展"></a>9.函数扩展</h5><h6 id="9-1-箭头函数"><a href="#9-1-箭头函数" class="headerlink" title="9-1 箭头函数"></a>9-1 箭头函数</h6><ul><li><p>箭头函数是 ES6 里面一个简写函数的语法方式</p></li><li><p>重点： <strong>箭头函数只能简写函数表达式，不能简写声明式函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 不能简写</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 可以简写</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 可以简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>语法： <code>(函数的行参) =&gt; { 函数体内要执行的代码 }</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用箭头函数写成</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用箭头函数写成</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  fn: <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="9-2-箭头函数的特殊性"><a href="#9-2-箭头函数的特殊性" class="headerlink" title="9-2 箭头函数的特殊性"></a>9-2 箭头函数的特殊性</h6><ul><li><p>箭头函数内部没有 this，箭头函数的 this 是上下文的 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的</span></span><br><span class="line"><span class="comment">// 因为这里的 this 是 window</span></span><br><span class="line"><span class="comment">// 所以箭头函数内部的 this 就是 window</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这个位置是箭头函数的上一行，但是不能打印出 this</span></span><br><span class="line">  fun: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn()</span><br><span class="line">obj.fun()</span><br></pre></td></tr></table></figure><ul><li>按照我们之前的 this 指向来判断，两个都应该指向 obj</li><li>但是 fun 因为是箭头函数，所以 this 不指向 obj，而是指向 fun 的外层，就是 window</li></ul></li><li><p>箭头函数内部没有 <code>arguments</code> 这个参数集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  fun: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 会打印一个伪数组 [1, 2, 3]</span></span><br><span class="line">obj.fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 会直接报错</span></span><br></pre></td></tr></table></figure></li><li><p>函数的行参只有一个的时候可以不写 <code>()</code> 其余情况必须写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'没有参数，必须写小括号'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  fn2: <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'一个行参，可以不写小括号'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  fn3: <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'两个或两个以上参数，必须写小括号'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数体只有一行代码的时候，可以不写 <code>{}</code> ，并且会自动 return</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  fun: <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(fun(<span class="number">10</span>)) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="9-3-函数传递参数的时候的默认值"><a href="#9-3-函数传递参数的时候的默认值" class="headerlink" title="9-3 函数传递参数的时候的默认值"></a>9-3 函数传递参数的时候的默认值</h6><ul><li><p>我们在定义函数的时候，有的时候需要一个默认值出现</p></li><li><p>就是当我不传递参数的时候，使用默认值，传递参数了就使用传递的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a = a || <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()   <span class="comment">// 不传递参数的时候，函数内部的 a 就是 10</span></span><br><span class="line">fn(<span class="number">20</span>) <span class="comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span></span><br></pre></td></tr></table></figure><ul><li>在 ES6 中我们可以直接把默认值写在函数的行参位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()   <span class="comment">// 不传递参数的时候，函数内部的 a 就是 10</span></span><br><span class="line">fn(<span class="number">20</span>) <span class="comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span></span><br></pre></td></tr></table></figure><ul><li>这个默认值的方式箭头函数也可以使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a = <span class="number">10</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()   <span class="comment">// 不传递参数的时候，函数内部的 a 就是 10</span></span><br><span class="line">fn(<span class="number">20</span>) <span class="comment">// 传递了参数 20 的时候，函数内部的 a 就是 20</span></span><br></pre></td></tr></table></figure><ul><li>注意： <strong>箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写 （）</strong></li></ul></li></ul><h5 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10.Symbol"></a>10.Symbol</h5><blockquote><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p></blockquote><ol><li>使用Symbol作为对象属性名</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> age = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">var</span> obj  =&#123;</span><br><span class="line">    [name]:<span class="string">"miller"</span>,</span><br><span class="line">    [age]:<span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Symbol()函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。这主要是为了在控制台显示，比较容易区分。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="keyword">let</span> age = <span class="built_in">Symbol</span>(<span class="string">"age"</span>)</span><br><span class="line"><span class="keyword">var</span> obj  =&#123;</span><br><span class="line">    [name]:<span class="string">"miller"</span>,</span><br><span class="line">    [age]:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><ol start="3"><li>遍历问题</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = &#123;</span><br><span class="line">    name:<span class="built_in">Symbol</span>(<span class="string">"name"</span>),</span><br><span class="line">    age:<span class="built_in">Symbol</span>(<span class="string">"age"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj  =&#123;</span><br><span class="line">    [keys.name]:<span class="string">"miller"</span>,</span><br><span class="line">    [keys.age]:<span class="number">100</span>,</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj).forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item,obj[item])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>Symbol.for()可以重新使用同一个 Symbol 值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  =&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.for(<span class="string">"name"</span>)]:<span class="string">"miller"</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.for(<span class="string">"age"</span>)]:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.for(<span class="string">"name"</span>)])</span><br></pre></td></tr></table></figure><h5 id="11-Iterator迭代器"><a href="#11-Iterator迭代器" class="headerlink" title="11.Iterator迭代器"></a>11.Iterator迭代器</h5><blockquote><p>Iterator 的作用有三个：</p><p>一是为各种数据结构，提供一个统一的、简便的访问接口；</p><p>二是使得数据结构的成员能够按某种次序排列；</p><p>三是 ES6 创造了一种新的遍历命令<strong>for…of</strong>循环，Iterator 接口主要供<strong>for…of</strong>循环</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"miller"</span>, <span class="string">"tiechui"</span>, <span class="string">"gangdaner"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Iterator 的遍历过程是这样的。</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(i.next())</span><br><span class="line"><span class="built_in">console</span>.log(i.next())</span><br><span class="line"><span class="built_in">console</span>.log(i.next())</span><br><span class="line"><span class="built_in">console</span>.log(i.next())</span><br></pre></td></tr></table></figure><blockquote><p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</p></blockquote><p>原生默认具备 Iterator 接口的数据结构如下。</p><ul><li>Array</li><li>Set</li><li>Map</li><li>String</li><li>arguments 对象</li><li>NodeList 对象</li></ul><p><strong>如何对于对象进行for fo遍历？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">"miller"</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">"tiechui"</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">"gangdaner"</span>,</span><br><span class="line">    length: <span class="number">3</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    data: [<span class="string">'miller'</span>, <span class="string">'tiechui'</span>, <span class="string">"gangdaner"</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="comment">// let _this = this</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="keyword">this</span>.data.length) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: <span class="keyword">this</span>.data[index++],</span><br><span class="line">                        done: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: <span class="literal">undefined</span>,</span><br><span class="line">                        done: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> obj2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="12-Set结构"><a href="#12-Set结构" class="headerlink" title="12.Set结构"></a>12.Set结构</h5><blockquote><p>它类似于数组，但成员的值都是唯一的，没有重复的值。</p></blockquote><h6 id="12-1-初识Set"><a href="#12-1-初识Set" class="headerlink" title="12-1 初识Set"></a>12-1 初识Set</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">s2.add(<span class="number">1</span>)</span><br><span class="line">s2.add(<span class="number">2</span>)</span><br><span class="line">s2.add(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s2)</span><br></pre></td></tr></table></figure><h6 id="12-2-实例的属性和方法"><a href="#12-2-实例的属性和方法" class="headerlink" title="12-2 实例的属性和方法"></a>12-2 实例的属性和方法</h6><ul><li><p>size：返回Set实例的成员总数。</p></li><li><p><code>Set.prototype.add(value)</code>：添加某个value。</p></li><li><code>Set.prototype.delete(value)</code>：删除某个value，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><h6 id="12-3-遍历"><a href="#12-3-遍历" class="headerlink" title="12-3 遍历"></a>12-3 遍历</h6><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：遍历每个成员</li></ul><h6 id="12-4-复杂数据结构去重"><a href="#12-4-复杂数据结构去重" class="headerlink" title="12-4 复杂数据结构去重"></a>12-4 复杂数据结构去重</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uni</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> id = <span class="built_in">JSON</span>.stringify(item)</span><br><span class="line">        <span class="keyword">if</span> (res.has(id)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(id)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"data"</span>, &#123;</span><br><span class="line">    name: <span class="string">"miller"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    name: <span class="string">"miller"</span></span><br><span class="line">&#125;,</span><br><span class="line">           [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">           [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">           [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">          ]</span><br><span class="line"><span class="built_in">console</span>.log(uni(arr))</span><br></pre></td></tr></table></figure><h5 id="13-Map结构"><a href="#13-Map结构" class="headerlink" title="13.Map结构"></a>13.Map结构</h5><blockquote><p>类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p></blockquote><h6 id="13-1-初识Map"><a href="#13-1-初识Map" class="headerlink" title="13-1 初识Map"></a>13-1 初识Map</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m1.set(<span class="string">"name"</span>,<span class="string">"miller"</span>)</span><br><span class="line">m1.set(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;,<span class="string">"大连"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m2= <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">"name"</span>,<span class="string">"miller"</span>],</span><br><span class="line">    [&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;,<span class="string">"大连"</span>]</span><br><span class="line">])</span><br><span class="line"><span class="built_in">console</span>.log(m2)</span><br></pre></td></tr></table></figure><h6 id="13-2-实例的属性和方法"><a href="#13-2-实例的属性和方法" class="headerlink" title="13-2 实例的属性和方法"></a>13-2 实例的属性和方法</h6><ul><li><p>size：返回 Map 结构的成员总数。</p></li><li><p><code>Map.prototype.set(key,value)</code>：添加key对应得value，返回 Map 结构本身。</p></li><li><code>Map.prototype.get(key)</code>：获取key对应的value</li><li><code>Map.prototype.delete(key)</code>：删除某个键（键名+键值）</li><li><code>Map.prototype.has(key)</code>：某个键是否在当前 Map 对象之中。</li><li><code>Map.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><h6 id="13-3-遍历"><a href="#13-3-遍历" class="headerlink" title="13-3 遍历"></a>13-3 遍历</h6><ul><li>Map.prototype.keys()：返回键名的遍历器。</li><li>Map.prototype.values()：返回键值的遍历器。</li><li>Map.prototype.entries()：返回所有成员的遍历器。</li><li>Map.prototype.forEach()：遍历 Map 的所有成员。</li></ul><h5 id="14-Proxy代理"><a href="#14-Proxy代理" class="headerlink" title="14.Proxy代理"></a>14.Proxy代理</h5><blockquote><p>Proxy如其名， 它的作用是在对象和和对象的属性值之间设置一个代理，获取该对象的值或者设置该对象的值， 以及实例化等等多种操作， 都会被拦截住， 经过这一层我们可以统一处理，我们可以认为它就是“代理器”</p></blockquote><h6 id="14-1-get方法"><a href="#14-1-get方法" class="headerlink" title="14-1.get方法"></a>14-1.get方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">    <span class="keyword">get</span>(target,prop)&#123;</span><br><span class="line">        <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="14-2-set方法"><a href="#14-2-set方法" class="headerlink" title="14-2.set方法"></a>14-2.set方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">    <span class="keyword">get</span>(target,prop)&#123;</span><br><span class="line">        <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target,prop,value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prop===<span class="string">"data"</span>)&#123;</span><br><span class="line">            box.innerHTML = value</span><br><span class="line">        &#125;</span><br><span class="line">        target[prop] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="14-3-has方法"><a href="#14-3-has方法" class="headerlink" title="14-3.has方法"></a>14-3.has方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    _prop: <span class="string">"内部数据"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">        <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, prop, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop === <span class="string">"data"</span>) &#123;</span><br><span class="line">            box.innerHTML = value</span><br><span class="line">        &#125;</span><br><span class="line">        target[prop] = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    has(target, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="14-4-this问题"><a href="#14-4-this问题" class="headerlink" title="14-4.this问题"></a>14-4.this问题</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">        <span class="keyword">const</span> value =  target[key]</span><br><span class="line">        <span class="comment">// 遇到 Function 都手动绑定一下 this</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`访问<span class="subst">$&#123;value&#125;</span>方法了`</span>)</span><br><span class="line">            <span class="keyword">return</span> value.bind(target)</span><br><span class="line">            <span class="comment">//不能 是 call apply </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.add(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Proxy本质上属于元编程非破坏性数据劫持，在原对象的基础上进行了功能的衍生而又不影响原对象，符合松耦合高内聚的设计理念。</p></blockquote><h5 id="15-Reflect对象"><a href="#15-Reflect对象" class="headerlink" title="15.Reflect对象"></a>15.Reflect对象</h5><blockquote><p>Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。</p></blockquote><h6 id="15-1-代替Object的某些方法"><a href="#15-1-代替Object的某些方法" class="headerlink" title="15-1 代替Object的某些方法"></a>15-1 代替Object的某些方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'miller'</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="15-2-修改某些Object方法返回结果"><a href="#15-2-修改某些Object方法返回结果" class="headerlink" title="15-2 修改某些Object方法返回结果"></a>15-2 修改某些Object方法返回结果</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="15-3-命令式变为函数行为"><a href="#15-3-命令式变为函数行为" class="headerlink" title="15-3 命令式变为函数行为"></a>15-3 命令式变为函数行为</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//老写法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> obj) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//新写法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has(obj, <span class="string">'name'</span>)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//老写法</span></span><br><span class="line"><span class="keyword">delete</span> obj.name</span><br><span class="line"><span class="comment">//新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(obj, <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><h6 id="15-4-配合Proxy"><a href="#15-4-配合Proxy" class="headerlink" title="15-4 配合Proxy"></a>15-4 配合Proxy</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target,key)</span><br><span class="line">        <span class="comment">// 遇到 Function 都手动绑定一下 this</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`访问<span class="subst">$&#123;value&#125;</span>方法了`</span>)</span><br><span class="line">            <span class="keyword">return</span> value.bind(target)</span><br><span class="line">            <span class="comment">//不能 是 call apply </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.add(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>, key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>, key, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 能够打印出很多内容</span></span><br><span class="line"><span class="comment">// get push     (寻找 proxy.push 方法)</span></span><br><span class="line"><span class="comment">// get length   (获取当前的 length)</span></span><br><span class="line"><span class="comment">// set 3 4      (设置 proxy[3] = 4)</span></span><br><span class="line"><span class="comment">// set length 4 (设置 proxy.length = 4)</span></span><br></pre></td></tr></table></figure><h5 id="16-Promise"><a href="#16-Promise" class="headerlink" title="16.Promise"></a>16.Promise</h5><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案回调函数,  更合理和更强大。ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象 。</p></blockquote><ul><li><p>指定回调函数方式更灵活易懂。</p></li><li><p>解决异步 <strong>回调地狱</strong> 的问题。</p></li></ul><h6 id="16-1-回调地狱"><a href="#16-1-回调地狱" class="headerlink" title="16-1 回调地狱"></a>16-1 回调地狱</h6><ul><li><p>当一个回调函数嵌套一个回调函数的时候</p></li><li><p>就会出现一个嵌套结构</p></li><li><p>当嵌套的多了就会出现回调地狱的情况</p></li><li><p>比如我们发送三个 ajax 请求</p><ul><li>第一个正常发送</li><li>第二个请求需要第一个请求的结果中的某一个值作为参数</li><li>第三个请求需要第二个请求的结果中的某一个值作为参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="string">'我是第一个请求'</span>,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="comment">// 现在发送第二个请求</span></span><br><span class="line">    ajax(&#123;</span><br><span class="line">      url: <span class="string">'我是第二个请求'</span>，</span><br><span class="line">      data: &#123; <span class="attr">a</span>: res.a, <span class="attr">b</span>: res.b &#125;,</span><br><span class="line">      success (res2) &#123;</span><br><span class="line">        <span class="comment">// 进行第三个请求</span></span><br><span class="line">        ajax(&#123;</span><br><span class="line">          url: <span class="string">'我是第三个请求'</span>,</span><br><span class="line">          data: &#123; <span class="attr">a</span>: res2.a, <span class="attr">b</span>: res2.b &#125;,</span><br><span class="line">          success (res3) &#123; </span><br><span class="line">            <span class="built_in">console</span>.log(res3) </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>回调地狱，其实就是回调函数嵌套过多导致的</strong></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/es6-img/%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>当代码成为这个结构以后，已经没有维护的可能了</li></ul><h6 id="16-2-Promise使用"><a href="#16-2-Promise使用" class="headerlink" title="16-2 Promise使用"></a>16-2 Promise使用</h6><ul><li><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// resolve 表示成功的回调</span></span><br><span class="line">  <span class="comment">// reject 表示失败的回调</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 成功的函数</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 失败的函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h6 id="16-3-Promise-对象的状态"><a href="#16-3-Promise-对象的状态" class="headerlink" title="16-3 Promise 对象的状态"></a>16-3 Promise 对象的状态</h6><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">异步操作未完成（pending）</span><br><span class="line">异步操作成功（fulfilled）</span><br><span class="line">异步操作失败（rejected）</span><br></pre></td></tr></table></figure><p>这三种的状态的变化途径只有两种。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从“未完成”到“成功”</span><br><span class="line">从“未完成”到“失败”</span><br></pre></td></tr></table></figure><p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p><p>因此，Promise 的最终结果只有两种。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。</span><br><span class="line">异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/es6-img/image-20220902141409899.png" alt="image-20220902141409899" title="">                </div>                <div class="image-caption">image-20220902141409899</div>            </figure><h6 id="16-4-Promise-all"><a href="#16-4-Promise-all" class="headerlink" title="16-4 Promise.all"></a>16-4 Promise.all</h6><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>p的状态由p1,p2,p3 决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><h6 id="16-5-Promise-race"><a href="#16-5-Promise-race" class="headerlink" title="16-5 Promise.race"></a>16-5 Promise.race</h6><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><h5 id="17-Generator-函数"><a href="#17-Generator-函数" class="headerlink" title="17.Generator 函数"></a>17.Generator 函数</h5><blockquote><p>Generator 函数是 ES6 提供的一种异步编程解决方案</p><p>Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p></blockquote><h6 id="17-1-基本语法"><a href="#17-1-基本语法" class="headerlink" title="17-1 基本语法"></a>17-1 基本语法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.next()</span><br><span class="line">g.next()</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220917070351858.png" alt="image-20220917070351858" style="zoom:50%;float:left"></p><blockquote><p>yield(产出)表达式是暂停执行的标记，而next方法可以恢复执行。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"><span class="keyword">let</span> res1 = g.next()</span><br><span class="line"><span class="built_in">console</span>.log(res1)</span><br><span class="line"><span class="keyword">let</span> res2 = g.next()</span><br><span class="line"><span class="built_in">console</span>.log(res2)</span><br><span class="line"><span class="keyword">let</span> res3 = g.next()</span><br><span class="line"><span class="built_in">console</span>.log(res3)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/es6-img/image-20220917070836171.png" alt="image-20220917070836171" title="">                </div>                <div class="image-caption">image-20220917070836171</div>            </figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line">g.next(<span class="string">"data-1"</span>)</span><br><span class="line">g.next(<span class="string">"data-2"</span>)</span><br><span class="line">g.next(<span class="string">"data-3"</span>)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/es6-img/image-20220917071219520.png" alt="image-20220917071219520" title="">                </div>                <div class="image-caption">image-20220917071219520</div>            </figure><h6 id="17-2-异步流程"><a href="#17-2-异步流程" class="headerlink" title="17-2 异步流程"></a>17-2 异步流程</h6><p><strong>手动版本</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">yield</span> ajax(<span class="string">"1.json"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">yield</span> ajax(<span class="string">"2.json"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()   </span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    g.next(data).value.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>自动版本</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">yield</span> ajax(<span class="string">"1.json"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">yield</span> ajax(<span class="string">"2.json"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AutoRun</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> g = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = g.next(data);</span><br><span class="line">        <span class="keyword">if</span> (res.done) <span class="keyword">return</span> </span><br><span class="line">        res.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AutoRun(gen);</span><br></pre></td></tr></table></figure><h5 id="18-Class语法"><a href="#18-Class语法" class="headerlink" title="18. Class语法"></a>18. Class语法</h5><h6 id="18-1-类的写法"><a href="#18-1-类的写法" class="headerlink" title="18-1 类的写法"></a>18-1 类的写法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Person(<span class="string">"miller"</span>,<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><h6 id="18-2-getter与setter"><a href="#18-2-getter与setter" class="headerlink" title="18-2 getter与setter"></a>18-2 getter与setter</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(ele)&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = ele</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> html()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> html(arr)&#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = arr.map(<span class="function"><span class="params">item</span>=&gt;</span><span class="string">`&lt;li&gt;<span class="subst">$&#123;item&#125;</span>&lt;/li&gt;`</span>).join(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> List(<span class="built_in">document</span>.querySelector(<span class="string">"#list"</span>))</span><br><span class="line"></span><br><span class="line">obj.html = [<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"cccc"</span>]</span><br></pre></td></tr></table></figure><h6 id="18-3-静态属性和静态方法"><a href="#18-3-静态属性和静态方法" class="headerlink" title="18-3 静态属性和静态方法"></a>18-3 静态属性和静态方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">"Person这个类"</span></span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> eat()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"eat"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Person(<span class="string">"miller"</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.name)</span><br><span class="line">Person.eat()</span><br></pre></td></tr></table></figure><h6 id="18-4-继承"><a href="#18-4-继承" class="headerlink" title="18-4 继承"></a>18-4 继承</h6><blockquote><p>ES6 规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">"Person这个类"</span></span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> eat()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"eat"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age,score)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age)</span><br><span class="line">        <span class="keyword">this</span>.score = score</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="keyword">super</span>.say()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.score)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> eat()&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"student eat"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Student(<span class="string">"miller"</span>,<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line">obj.say()</span><br><span class="line">Student.eat()</span><br></pre></td></tr></table></figure><h5 id="19-模块化"><a href="#19-模块化" class="headerlink" title="19.模块化"></a>19.模块化</h5><blockquote><p>JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。</p><p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p></blockquote><p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><p><strong>写法1：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> A1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> a1 <span class="keyword">from</span> <span class="string">"./1.js"</span></span><br></pre></td></tr></table></figure><p><strong>写法2：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;A1,A2&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;A1,A2&#125; <span class="keyword">from</span> <span class="string">"./1.js"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;A1 <span class="keyword">as</span> a1,A2 <span class="keyword">as</span> a2&#125; <span class="keyword">from</span> <span class="string">"./1.js"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">"./1.js"</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">A1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"A1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">A2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"A2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;A1,A2&#125; <span class="keyword">from</span> <span class="string">"./1.js"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;A1 <span class="keyword">as</span> a1,A2 <span class="keyword">as</span> a2&#125; <span class="keyword">from</span> <span class="string">"./1.js"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">"./1.js"</span></span><br></pre></td></tr></table></figure><p><strong>混合写法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;A1&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> A2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> A2,&#123;A1&#125; <span class="keyword">from</span> <span class="string">"./1.js"</span></span><br></pre></td></tr></table></figure><h4 id="二-ES7新特性"><a href="#二-ES7新特性" class="headerlink" title="二. ES7新特性"></a>二. ES7新特性</h4><h5 id="1-求幂运算符"><a href="#1-求幂运算符" class="headerlink" title="1. 求幂运算符"></a>1. 求幂运算符</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">2</span>) === <span class="number">3</span> ** <span class="number">2</span>    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h5 id="2-数组的includes方法"><a href="#2-数组的includes方法" class="headerlink" title="2.数组的includes方法"></a>2.数组的includes方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><blockquote><p>如果仅仅查找数据是否在数组中，建议使用includes，如果是查找数据的索引位置，建议使用indexOf更好一些</p></blockquote><h4 id="三-ES8新特性"><a href="#三-ES8新特性" class="headerlink" title="三. ES8新特性"></a>三. ES8新特性</h4><h5 id="1-async和await"><a href="#1-async和await" class="headerlink" title="1. async和await"></a>1. async和await</h5><h6 id="1-1-Async"><a href="#1-1-Async" class="headerlink" title="1-1.Async"></a>1-1.Async</h6><p>async 函数，使得异步操作变得更加方便。</p><ul><li>更好的语义。</li><li>返回值是 Promise。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h6 id="1-2-Await"><a href="#1-2-Await" class="headerlink" title="1-2.Await"></a>1-2.Await</h6><p><code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res1 =  <span class="keyword">await</span> ajax(<span class="string">"http://localhost:3000/news1"</span>)</span><br><span class="line">    <span class="keyword">var</span> res2 =  <span class="keyword">await</span> ajax(<span class="string">"http://localhost:3000/news2"</span>)</span><br><span class="line">    <span class="keyword">return</span> res2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"返回结果"</span>,res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"err"</span>,err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="1-3-错误处理"><a href="#1-3-错误处理" class="headerlink" title="1-3.错误处理"></a>1-3.错误处理</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res1 =  <span class="keyword">await</span> ajax(<span class="string">"http://localhost:3000/news1"</span>)</span><br><span class="line">    <span class="keyword">var</span> res2 =  <span class="keyword">await</span> ajax(<span class="string">"http://localhost:3000/news2"</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"err"</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-对象方法扩展"><a href="#2-对象方法扩展" class="headerlink" title="2.对象方法扩展"></a>2.对象方法扩展</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span>,</span><br><span class="line">    age:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj))</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220920154527417.png" alt="image-20220920154527417" style="zoom:50%;float:left"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span>,</span><br><span class="line">    age:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj))</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220920154622530.png" alt="image-20220920154622530" style="zoom:50%;float:left"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span>,</span><br><span class="line">    age:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj))</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220920155143538.png" alt="image-20220920155143538" style="zoom:50%;float:left"></p><p><strong>克隆对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span>,</span><br><span class="line">    age:<span class="number">100</span>,</span><br><span class="line">    location:&#123;</span><br><span class="line">        provice:<span class="string">"辽宁"</span>,</span><br><span class="line">        city:<span class="string">"大连"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//只设置city，防止破坏province</span></span><br><span class="line">    <span class="keyword">get</span> city()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.location.city</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> city(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.location.city = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> nameset(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = value.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()+value.substring(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> nameset()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj1))</span><br><span class="line"><span class="keyword">var</span> obj2=  &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Object.assign(obj2,obj1)//无法克隆 get set方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj2,<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj1))</span><br></pre></td></tr></table></figure><h5 id="3-字符串填充"><a href="#3-字符串填充" class="headerlink" title="3. 字符串填充"></a>3. 字符串填充</h5><blockquote><p>padStart()、padEnd()方法可以使得字符串达到固定长度，有两个参数，字符串目标长度和填充内容。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str= <span class="string">"miller"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.padStart(<span class="number">10</span>,<span class="string">"x"</span>));<span class="comment">//xxxxmiller</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padEnd(<span class="number">10</span>,<span class="string">"x"</span>));<span class="comment">//millerxxxx</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padStart(<span class="number">5</span>,<span class="string">"x"</span>))<span class="comment">//miller</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padEnd(<span class="number">5</span>,<span class="string">"x"</span>))<span class="comment">//miller</span></span><br></pre></td></tr></table></figure><h5 id="4-函数参数的末尾加逗号"><a href="#4-函数参数的末尾加逗号" class="headerlink" title="4. 函数参数的末尾加逗号"></a>4. 函数参数的末尾加逗号</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> a,</span></span></span><br><span class="line"><span class="function"><span class="params"> b,</span></span></span><br><span class="line"><span class="function"><span class="params"> c,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a,b)</span><br><span class="line">&#125;</span><br><span class="line">test(</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>『末尾逗号』在添加新的参数、属性、元素时是有用的，你可以直接新加一行而不必给上一行再补充一个逗号，这样使版本控制工具的修改记录也更加整洁</p></blockquote><h4 id="四-ES9新特性"><a href="#四-ES9新特性" class="headerlink" title="四. ES9新特性"></a>四. ES9新特性</h4><h5 id="1-对象的剩余参数与扩展运算符"><a href="#1-对象的剩余参数与扩展运算符" class="headerlink" title="1. 对象的剩余参数与扩展运算符"></a>1. 对象的剩余参数与扩展运算符</h5><h6 id="1-1-对象的剩余参数"><a href="#1-1-对象的剩余参数" class="headerlink" title="1-1 对象的剩余参数"></a>1-1 对象的剩余参数</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span>,</span><br><span class="line">    age:<span class="number">100</span>,</span><br><span class="line">    location:<span class="string">"dalian"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;name,...other&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">//miller</span></span><br><span class="line"><span class="built_in">console</span>.log(other) <span class="comment">//&#123;age: 100, location: 'dalian'&#125;</span></span><br></pre></td></tr></table></figure><h6 id="1-2-对象的扩展运算符"><a href="#1-2-对象的扩展运算符" class="headerlink" title="1-2 对象的扩展运算符"></a>1-2 对象的扩展运算符</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    age:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;...obj1,...obj2&#125;)</span><br></pre></td></tr></table></figure><h5 id="2-正则表达式命名捕获组"><a href="#2-正则表达式命名捕获组" class="headerlink" title="2.正则表达式命名捕获组"></a>2.正则表达式命名捕获组</h5><p>JS正则表达式可以返回一个匹配的对象, 一个包含匹配字符串的类数组, 比如: 以 YYYY-MM-DD的格式解析日期，</p><p>这样的代码可读性很差, 并且在改变正则表达式的结构的时候很有可能就会改变匹配对象的索引</p><p>ES9允许使用命名捕获 ?<name> , 在打开捕获括号后立即命名</name></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"今天是2022-10-10"</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res1 = reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(res1)</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220921110518183.png" alt="image-20220921110518183" style="zoom:67%;float:left"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"今天是2022-10-10"</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res1 = reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(res1)</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220921110644896.png" alt="image-20220921110644896" style="zoom:67%;float:left"></p><h5 id="3-Promise-finally"><a href="#3-Promise-finally" class="headerlink" title="3. Promise.finally()"></a>3. Promise.finally()</h5><blockquote><p>无论是成功还是失败, 都运行同样的代码, 比如隐藏对话框, 关闭数据连接</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="number">1111</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//showloading</span></span><br><span class="line">ajax().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//hideloading</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"finally"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="4-异步遍历器"><a href="#4-异步遍历器" class="headerlink" title="4. 异步遍历器"></a>4. 异步遍历器</h5><h6 id="4-1-同步遍历器的问题"><a href="#4-1-同步遍历器的问题" class="headerlink" title="4-1 同步遍历器的问题"></a>4-1 同步遍历器的问题</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">1111</span></span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">2222</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> syncI = fn();</span><br><span class="line"><span class="built_in">console</span>.log(syncI.next())</span><br><span class="line"><span class="built_in">console</span>.log(syncI.next())</span><br><span class="line"><span class="built_in">console</span>.log(syncI.next())</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220921132030973.png" alt="image-20220921132030973" style="zoom:67%;float:left"></p><p>###### </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>resolve(<span class="string">"1111"</span>))</span><br><span class="line">    <span class="keyword">yield</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>resolve(<span class="string">"2222"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> syncI = fn();</span><br><span class="line">syncI.next().value.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res)&#125;)</span><br><span class="line">syncI.next().value.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res)&#125;)</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220921132403676.png" alt="image-20220921132403676" style="zoom:67%;float:left"></p><blockquote><p><code>value</code>属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。</p></blockquote><h6 id="4-2-异步遍历器生成函数"><a href="#4-2-异步遍历器生成函数" class="headerlink" title="4-2 异步遍历器生成函数"></a>4-2 异步遍历器生成函数</h6><blockquote><p>Generator 函数返回一个同步遍历器，异步 Generator 函数的作用，是返回一个异步遍历器对象。在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>resolve(<span class="string">"1111"</span>))</span><br><span class="line">    <span class="keyword">yield</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>resolve(<span class="string">"2222"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> asyncI = fn();</span><br><span class="line"></span><br><span class="line">asyncI.next().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> asyncI.next()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> asyncI.next()</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220921132528997.png" alt="image-20220921132528997" style="zoom:67%;float:left"></p><h6 id="4-3-for-await-of"><a href="#4-3-for-await-of" class="headerlink" title="4-3 for await of"></a>4-3 for await of</h6><blockquote><p><code>for...of</code>循环用于遍历同步的 Iterator 接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的 Iterator 接口。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> asyncI) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h6 id="4-4-案例改造"><a href="#4-4-案例改造" class="headerlink" title="4-4 案例改造"></a>4-4 案例改造</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              resolve(t)</span><br><span class="line">          &#125;, t)</span><br><span class="line">      &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> timer(<span class="number">1000</span>)<span class="comment">//任务1</span></span><br><span class="line">    <span class="keyword">yield</span> timer(<span class="number">2000</span>)<span class="comment">//任务2</span></span><br><span class="line">    <span class="keyword">yield</span> timer(<span class="number">3000</span>)<span class="comment">//任务3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一下 for await ...of</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span>(<span class="keyword">const</span> val <span class="keyword">of</span> fn()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"start"</span>,<span class="built_in">Date</span>.now())</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"end"</span>,<span class="built_in">Date</span>.now())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure><h6 id="4-5-nodejs用法"><a href="#4-5-nodejs用法" class="headerlink" title="4-5 nodejs用法"></a>4-5 nodejs用法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">inputFilePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> readStream = fs.createReadStream(</span><br><span class="line">    inputFilePath,</span><br><span class="line">    &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span>, <span class="attr">highWaterMark</span>: <span class="number">1024</span> &#125;</span><br><span class="line">  );</span><br><span class="line">  readStream.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt; '</span>+chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  readStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'### DONE ###'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步遍历器写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">inputFilePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> readStream = fs.createReadStream(</span><br><span class="line">    inputFilePath,</span><br><span class="line">    &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span>, <span class="attr">highWaterMark</span>: <span class="number">1024</span> &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> readStream) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt; '</span>+chunk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'### DONE ###'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五-ES10新特性"><a href="#五-ES10新特性" class="headerlink" title="五.ES10新特性"></a>五.ES10新特性</h4><h5 id="1-Object-fromEntries"><a href="#1-Object-fromEntries" class="headerlink" title="1. Object.fromEntries"></a>1. Object.fromEntries</h5><blockquote><p>Object.fromEntries()方法允许你轻松地将键值对列表转换为对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="string">"name"</span>, <span class="string">"miller"</span>], [<span class="string">"age"</span>, <span class="number">100</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.fromEntries(arr))<span class="comment">//&#123;name: 'miller', age: 100&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="string">"name"</span>,<span class="string">"tiechui"</span>)</span><br><span class="line">m.set(<span class="string">"age"</span>,<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.fromEntries(m))</span><br></pre></td></tr></table></figure><p><strong>用处</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str =<span class="string">"name=miller&amp;age=100"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> URLSearchParams(str)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.fromEntries(searchParams))<span class="comment">//&#123;name: 'miller', age: '100'&#125;</span></span><br></pre></td></tr></table></figure><h5 id="2-trimStart-and-trimEnd"><a href="#2-trimStart-and-trimEnd" class="headerlink" title="2. trimStart() and trimEnd()"></a>2. trimStart() and trimEnd()</h5><blockquote><p>trimStart()和trimEnd()方法在实现与trimLeft()和trimRight()相同。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"   miller    "</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"|"</span>+str.trimStart(str)+<span class="string">"|"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"|"</span>+str.trimEnd(str)+<span class="string">"|"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"|"</span>+str.trimLeft(str)+<span class="string">"|"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"|"</span>+str.trimRight(str)+<span class="string">"|"</span>)</span><br></pre></td></tr></table></figure><h5 id="3-Symbol-对象的-description-属性"><a href="#3-Symbol-对象的-description-属性" class="headerlink" title="3. Symbol 对象的 description 属性"></a>3. Symbol 对象的 description 属性</h5><blockquote><p>为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">"miller"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s.description) <span class="comment">//miller</span></span><br></pre></td></tr></table></figure><h5 id="4-可选的-catch"><a href="#4-可选的-catch" class="headerlink" title="4. 可选的 catch"></a>4. 可选的 catch</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//执行器函数</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">"成功的结果"</span>)</span><br><span class="line">    &#125;, <span class="number">30000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> pro2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//执行器函数</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject()</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.race([pro1, pro2])</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"不关心错误结果，网络超时"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h4 id="六-ES11新特性"><a href="#六-ES11新特性" class="headerlink" title="六. ES11新特性"></a>六. ES11新特性</h4><h5 id="1-Promise-allSettled"><a href="#1-Promise-allSettled" class="headerlink" title="1. Promise.allSettled"></a>1. Promise.allSettled</h5><blockquote><p>Promise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的 promise 结果。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [ ajax(<span class="string">'/200接口'</span>), ajax(<span class="string">'/401接口'</span>) ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).then(<span class="function"><span class="params">results</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 过滤出成功的请求</span></span><br><span class="line">    results.filter(<span class="function"><span class="params">item</span> =&gt;</span>item.status === <span class="string">'fulfilled'</span>);</span><br><span class="line">    过滤出失败的请求</span><br><span class="line">    results.filter(<span class="function"><span class="params">item</span>=&gt;</span> item.status === <span class="string">'rejected'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="2-module新增"><a href="#2-module新增" class="headerlink" title="2.module新增"></a>2.module新增</h5><h6 id="2-1-动态导入-import"><a href="#2-1-动态导入-import" class="headerlink" title="2-1 动态导入 import()"></a>2-1 动态导入 import()</h6><blockquote><p>标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;login&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="module"&gt;</span></span><br><span class="line"><span class="regexp">        let role1 = "管理员"</span></span><br><span class="line"><span class="regexp">        let role2 = "普通用户"</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        function login()&#123;</span></span><br><span class="line"><span class="regexp">            return "普通用户"</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        async function render(role)&#123;</span></span><br><span class="line"><span class="regexp">            if(role===role1)&#123;</span></span><br><span class="line"><span class="regexp">                let res1 = await import("./</span><span class="number">1.</span>js<span class="string">")</span></span><br><span class="line"><span class="string">                console.log(res1.default)</span></span><br><span class="line"><span class="string">            &#125;else&#123;</span></span><br><span class="line"><span class="string">                let res2 = await import("</span>./<span class="number">2.</span>js<span class="string">")</span></span><br><span class="line"><span class="string">                console.log(res2.default)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        let obtn = document.querySelector("</span>button<span class="string">")</span></span><br><span class="line"><span class="string">        obtn.onclick = function()&#123;</span></span><br><span class="line"><span class="string">            let role = login()</span></span><br><span class="line"><span class="string">            render(role)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure><h6 id="2-2-import-meta"><a href="#2-2-import-meta" class="headerlink" title="2-2 import.meta"></a>2-2 import.meta</h6><p>import.meta 会返回一个对象，有一个 url 属性，返回当前模块的url路径，只能在模块内部使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">        <span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">'./1.js'</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/1.js</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log(import.meta)</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h6 id="2-3-export-as-obj-from-‘module’"><a href="#2-3-export-as-obj-from-‘module’" class="headerlink" title="2-3 export * as obj from ‘module’"></a>2-3 export * as obj from ‘module’</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">'111111'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"22222"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> obj1 <span class="keyword">from</span> <span class="string">'./1.js'</span></span><br><span class="line"><span class="comment">//html</span></span><br><span class="line"> &lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">        <span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">'./2.js'</span></span><br><span class="line">        <span class="built_in">console</span>.log(obj)</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/es6-img/image-20220922111416681.png" alt="image-20220922111416681" style="zoom:67%;float:left;"></p><h5 id="3-字符串的matchAll方法"><a href="#3-字符串的matchAll方法" class="headerlink" title="3.字符串的matchAll方法"></a>3.字符串的matchAll方法</h5><blockquote><p>matchAll() 方法返回一个包含所有匹配正则表达式的结果的迭代器。可以使用 for…of 遍历，或者使用 展开运算符(…) 或者 Array.from 转换为数组.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;1111&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;2222&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;3333&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;4444&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;li&gt;(.*)&lt;\/li&gt;/g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)) </span><br><span class="line"><span class="comment">//'&lt;li&gt;1111&lt;/li&gt;', '&lt;li&gt;2222&lt;/li&gt;', '&lt;li&gt;3333&lt;/li&gt;', '&lt;li&gt;4444&lt;/li&gt;'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;1111&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;2222&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;3333&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;4444&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;li&gt;(.*)&lt;\/li&gt;/g</span></span><br><span class="line"><span class="keyword">let</span> match = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>(match = reg.exec(str))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(match[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">console</span>.log(match[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;1111&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;2222&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;3333&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;4444&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;li&gt;(.*)&lt;\/li&gt;/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> str.matchAll(reg))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-BigInt"><a href="#4-BigInt" class="headerlink" title="4. BigInt"></a>4. BigInt</h5><blockquote><p>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> <span class="comment">//9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span> <span class="comment">//9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">53</span>)+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234</span> <span class="comment">// 普通整数</span></span><br><span class="line"><span class="number">1234n</span> <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span> <span class="comment">// 3n</span></span><br></pre></td></tr></table></figure><h5 id="5-globalThis"><a href="#5-globalThis" class="headerlink" title="5. globalThis"></a>5. globalThis</h5><blockquote><p>globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es6-shim</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the only reliable means to get the global object is</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function('return this')()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// However, this causes CSP violations in Chrome apps.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globals = getGlobal();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!globals.Reflect) &#123;</span><br><span class="line"></span><br><span class="line">defineProperty(globals, ‘<span class="built_in">Reflect</span>’, &#123;&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以前</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> globals = getGlobal()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (globals.document) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"进行dom操作相关"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"不能进行dom操作"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在</span></span><br><span class="line"><span class="keyword">if</span> (globalThis.document) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"进行dom操作相关"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"不能进行dom操作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-空值合并运算符"><a href="#6-空值合并运算符" class="headerlink" title="6.空值合并运算符"></a>6.空值合并运算符</h5><blockquote><p><strong>空值合并运算符（<em>??</em>）</strong>是一个逻辑运算符。当左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span>,</span><br><span class="line">    introduction:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.introduction || <span class="string">"这个人很懒"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj.introduction ?? <span class="string">"这个人很懒"</span>)</span><br></pre></td></tr></table></figure><p><strong>??和 || 的区别是什么呢?</strong></p><p>他们两个最大的区别就是 ’ ‘和 0，??的左侧 为 ’ ‘或者为 0 的时候，依然会返回左侧的值；</p><p>|| 会对左侧的数据进行boolean类型转换，所以’ ‘和 0 会被转换成false,返回右侧的值</p><h5 id="7-可选链操作符"><a href="#7-可选链操作符" class="headerlink" title="7.可选链操作符"></a>7.可选链操作符</h5><blockquote><p>可选链前面的值如果是null或undefined，则不再执行后面的，之前返回可选链前面的值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span>,</span><br><span class="line">    introduction:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// location:&#123;</span></span><br><span class="line">    <span class="comment">//     city:"dalian"</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj &amp;&amp; obj.location &amp;&amp; obj.location.city)</span><br><span class="line"><span class="built_in">console</span>.log(obj?.location?.city)</span><br></pre></td></tr></table></figure><h4 id="七-ES12新特性"><a href="#七-ES12新特性" class="headerlink" title="七. ES12新特性"></a>七. ES12新特性</h4><h5 id="1-逻辑赋值操作符"><a href="#1-逻辑赋值操作符" class="headerlink" title="1. 逻辑赋值操作符"></a>1. 逻辑赋值操作符</h5><p>逻辑赋值操作符 ??=、&amp;&amp;=、 ||=</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span></span><br><span class="line"><span class="comment">//a &amp;&amp;= b //false</span></span><br><span class="line">a ||= b ; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"miller"</span>,           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.introduction = obj.introduction??<span class="string">"很懒"</span></span><br><span class="line">obj.introduction??=<span class="string">"很懒"</span></span><br></pre></td></tr></table></figure><h5 id="2-数字分隔符"><a href="#2-数字分隔符" class="headerlink" title="2.数字分隔符"></a>2.数字分隔符</h5><p>这个新特性是为了方便程序员看代码而出现的，如果数字比较大，那么看起来就不是那么一目了然</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num= <span class="number">123456789</span>；</span><br></pre></td></tr></table></figure><p>分隔符不仅可以分割十进制，也可以分割二净值或者十六净值的数据，非常好用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> number = <span class="number">1</span>_000_000_000_000;</span><br><span class="line"><span class="keyword">const</span> binary = <span class="number">0b1010</span>_0101_1111_1101;</span><br><span class="line"><span class="keyword">const</span> hex = <span class="number">0xA1</span>_B2_C3;</span><br></pre></td></tr></table></figure><h5 id="3-replaceAll"><a href="#3-replaceAll" class="headerlink" title="3. replaceAll"></a>3. replaceAll</h5><blockquote><p>所有匹配都会被替代项替换。模式可以是字符串或正则表达式，而替换项可以是字符串或针对每次匹配执行的函数。并返回一个全新的字符串  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str =</span><br><span class="line">      <span class="string">"I wish to wish the wish you wish to wish, but if you wish the wish the witch wishes, I won't wish the wish you wish to wish. "</span>;</span><br><span class="line"><span class="keyword">const</span> newStr = str.replaceAll(<span class="string">"wish"</span>, <span class="string">"miller"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newStr);</span><br></pre></td></tr></table></figure><h5 id="4-Promise-any"><a href="#4-Promise-any" class="headerlink" title="4.Promise.any"></a>4.Promise.any</h5><p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><blockquote><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p></blockquote><h5 id="5-WeakRef"><a href="#5-WeakRef" class="headerlink" title="5. WeakRef"></a>5. WeakRef</h5><blockquote><p>在一般情况下，对象的引用是强引用的，这意味着只要持有对象的引用，它就不会被垃圾回收。只有当该对象没有任何的强引用时，垃圾回收才会销毁该对象并且回收该对象所占的内存空间。</p><p>而 <code>WeakRef</code> 允许您保留对另一个对象的弱引用，而不会阻止被弱引用对象被垃圾回收。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> WeakRef(target);</span><br></pre></td></tr></table></figure><p>WeakRef 实例对象有一个<code>deref()</code>方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> WeakRef(target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = wr.deref();</span><br><span class="line"><span class="keyword">if</span> (obj) &#123; <span class="comment">// target 未被垃圾回收机制清除</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> like = <span class="keyword">new</span> WeakRef(<span class="built_in">document</span>.getElementById(<span class="string">"like"</span>))</span><br><span class="line"><span class="keyword">let</span> mymap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">mymap.set(like.deref(), &#123;</span><br><span class="line">    click: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">like.deref().onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> times = mymap.get(like.deref())</span><br><span class="line">    times.click++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(like.deref())</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h5 id="6-FinalizationRegistry"><a href="#6-FinalizationRegistry" class="headerlink" title="6. FinalizationRegistry"></a>6. FinalizationRegistry</h5><blockquote><p>清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。</p></blockquote><p>首先，新建一个注册表实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> registry = <span class="keyword">new</span> FinalizationRegistry(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.register(obj, <span class="string">"some value"</span>);</span><br><span class="line">registry.unregister(obj);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> like = <span class="keyword">new</span> WeakRef(<span class="built_in">document</span>.getElementById(<span class="string">"like"</span>))</span><br><span class="line"><span class="keyword">let</span> mymap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">mymap.set(like.deref(), &#123;</span><br><span class="line">    click: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">like.deref().onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> times = mymap.get(like.deref())</span><br><span class="line">    times.click++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// registry.register(document.getElementById("like"), mymap.get(like.deref()));</span></span><br><span class="line">    registry.register(like.deref(), mymap.get(like.deref()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(like.deref())</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> registry = <span class="keyword">new</span> FinalizationRegistry(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"被销毁了"</span>, data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="八-ES13新特性"><a href="#八-ES13新特性" class="headerlink" title="八.ES13新特性"></a>八.ES13新特性</h4><h5 id="1-私有属性和方法"><a href="#1-私有属性和方法" class="headerlink" title="1. 私有属性和方法"></a>1. 私有属性和方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line">    #obj  =&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>(key)&#123;</span><br><span class="line">        return this.#obj[key]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">set</span>(key,value)&#123;</span><br><span class="line">    this.#obj[key] =value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> Cache()</span><br><span class="line">cache.set(<span class="string">"name"</span>,<span class="string">"miller"</span>)</span><br></pre></td></tr></table></figure><h5 id="2-静态成员的私有属性和方法"><a href="#2-静态成员的私有属性和方法" class="headerlink" title="2.静态成员的私有属性和方法"></a>2.静态成员的私有属性和方法</h5><blockquote><p>我们还可以给类定义静态成员和静态私有函数。类的静态方法可以使用<code>this</code>关键字访问其他的私有或者公有静态成员，</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line">     static #count = 0;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> getCount()&#123;</span><br><span class="line">         return this.#count</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    #obj  =&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>(key)&#123;</span><br><span class="line">        return this.#obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(key,value)&#123;</span><br><span class="line">        this.#obj[key] =value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> Cache()</span><br><span class="line">cache.set(<span class="string">"name"</span>,<span class="string">"miller"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Cache.getCount())</span><br></pre></td></tr></table></figure><h5 id="3-静态代码块"><a href="#3-静态代码块" class="headerlink" title="3.静态代码块"></a>3.静态代码块</h5><blockquote><p>ES13允许在类中通过<code>static</code>关键字定义一系列静态代码块，这些代码块只会在类被创造的时候<strong>执行一次</strong>。这其实有点像一些其他的如C#和Java等面向对象的编程语言的静态构造函数的用法。</p></blockquote><p>一个类可以定义任意多的静态代码块，这些代码块会和穿插在它们之间的静态成员变量一起按照定义的顺序在类初始化的时候执行一次。我们还可以使用<code>super</code>关键字来访问父类的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> obj = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.obj.set(<span class="string">"name"</span>,<span class="string">"miller"</span>)</span><br><span class="line">        <span class="keyword">this</span>.obj.set(<span class="string">"age"</span>,<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Cache.obj)</span><br></pre></td></tr></table></figure><h5 id="4-使用in来判断某个对象是否拥有某个私有属性"><a href="#4-使用in来判断某个对象是否拥有某个私有属性" class="headerlink" title="4. 使用in来判断某个对象是否拥有某个私有属性"></a>4. 使用in来判断某个对象是否拥有某个私有属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    #obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">        return this.#obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(key, value) &#123;</span><br><span class="line">        this.#obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hasObj()&#123;</span><br><span class="line">        return #obj in this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> Cache()</span><br><span class="line"><span class="built_in">console</span>.log(cache.hasObj())</span><br></pre></td></tr></table></figure><h5 id="5-支持在最外层写await"><a href="#5-支持在最外层写await" class="headerlink" title="5.支持在最外层写await"></a>5.支持在最外层写await</h5><blockquote><p>顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">"data-1111"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> ajax();</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h5 id="6-at函数来索引元素"><a href="#6-at函数来索引元素" class="headerlink" title="6. at函数来索引元素"></a>6. at函数来索引元素</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"miller"</span>,<span class="string">"tiechui"</span>,<span class="string">"gangdan"</span>,<span class="string">"xiaoming"</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(arr[arr.length<span class="number">-1</span>]) <span class="comment">//变丑了</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[arr.length<span class="number">-2</span>]) <span class="comment">//变丑了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.at(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(arr.at(<span class="number">-1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(arr.at(<span class="number">-2</span>))</span><br></pre></td></tr></table></figure><h5 id="7-正则匹配的开始和结束索引"><a href="#7-正则匹配的开始和结束索引" class="headerlink" title="7. 正则匹配的开始和结束索引"></a>7. 正则匹配的开始和结束索引</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"今天是2022-11-10"</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>d</span><br><span class="line"></span><br><span class="line"><span class="comment">//exec</span></span><br><span class="line"><span class="keyword">let</span> res = reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/es6-img/image-20220927105243515.png" alt="image-20220927105243515" title="">                </div>                <div class="image-caption">image-20220927105243515</div>            </figure><h5 id="8-findLast-和findLastIndex-函数"><a href="#8-findLast-和findLastIndex-函数" class="headerlink" title="8.findLast()和findLastIndex()函数"></a>8.findLast()和findLastIndex()函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// let res = arr.find(function(value)&#123;</span></span><br><span class="line"><span class="comment">//   return value % 2 === 0</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// let res = arr.findIndex(function(value)&#123;</span></span><br><span class="line"><span class="comment">//   return value % 2 === 0</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// let res = arr.findLast(function(value)&#123;</span></span><br><span class="line"><span class="comment">//   return value % 2 === 0</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="keyword">let</span> res = arr.findLastIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure><h5 id="9-Error对象的Cause属性"><a href="#9-Error对象的Cause属性" class="headerlink" title="9.Error对象的Cause属性"></a>9.Error对象的Cause属性</h5><blockquote><p>Error对象多了一个<code>cause</code>属性来指明错误出现的原因。这个属性可以帮助我们为错误添加更多的上下文信息，从而帮助使用者们更好地定位错误。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(miller)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'New error 1111111'</span>,&#123;<span class="attr">cause</span>:<span class="string">"这是因为,,,,,,,,,"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    getData()</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6-ES13&quot;&gt;&lt;a href=&quot;#ES6-ES13&quot; class=&quot;headerlink&quot; title=&quot;ES6-ES13&quot;&gt;&lt;/a&gt;ES6-ES13&lt;/h3&gt;&lt;h4 id=&quot;一-走入ES6&quot;&gt;&lt;a href=&quot;#一-走入ES6&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>requestAnimationFrame</title>
    <link href="https://heima0.github.io/2022/11/11/requestAnimationFrame/"/>
    <id>https://heima0.github.io/2022/11/11/requestAnimationFrame/</id>
    <published>2022-11-11T09:17:51.000Z</published>
    <updated>2022-11-12T14:02:35.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><ul><li><p>requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘，让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p></li><li><p>在运行过程中，window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p></li></ul><p>  <code>注意：</code></p><blockquote><p>若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;requestAnimationFrame&quot;&gt;&lt;a href=&quot;#requestAnimationFrame&quot; class=&quot;headerlink&quot; title=&quot;requestAnimationFrame&quot;&gt;&lt;/a&gt;requestAnimationFrame&lt;/
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>字符集与字符编码</title>
    <link href="https://heima0.github.io/2022/11/05/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>https://heima0.github.io/2022/11/05/字符集与字符编码/</id>
    <published>2022-11-05T02:47:04.000Z</published>
    <updated>2022-11-12T14:02:35.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符集与编码系列"><a href="#字符集与编码系列" class="headerlink" title="字符集与编码系列"></a>字符集与编码系列</h1><ul><li><p>字符集：要想在计算机中显示文字，必须把文字都收集起来放在一个表中，这个表叫字符集（Charset）。</p></li><li><p>码表：字符集中的每个文字，都分配一个数字号码，这叫码表（Code chart）。比如中文 ‘霸’字，在码表中对应的码是38712（十进制），或者9738（十六进制）。</p></li><li><p>编码方式：有了码表，就需要确定哪些文字用几个字节表示，以及如果有多个字节代表一个字，字节的读取顺序，这些就是字符编码方式（Encoding）。</p></li></ul><blockquote><p>虽然为了严谨起见，上面我把字符集和码表分开说明，但实际上很多字符集也给每个字符分配了一个码（Code Point），所以很多人经常也把字符集叫做码表、码表叫做字符集。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符集与编码系列&quot;&gt;&lt;a href=&quot;#字符集与编码系列&quot; class=&quot;headerlink&quot; title=&quot;字符集与编码系列&quot;&gt;&lt;/a&gt;字符集与编码系列&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字符集：要想在计算机中显示文字，必须把文字都收集起来放在一个表中，这个表叫
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>技术管理-如何保持判断力</title>
    <link href="https://heima0.github.io/2022/10/27/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86-%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E5%88%A4%E6%96%AD%E5%8A%9B/"/>
    <id>https://heima0.github.io/2022/10/27/技术管理-如何保持判断力/</id>
    <published>2022-10-27T12:42:42.000Z</published>
    <updated>2022-11-12T14:02:35.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何保持判断力"><a href="#如何保持判断力" class="headerlink" title="如何保持判断力"></a>如何保持判断力</h1><p>作为一个技术管理者，即技术应用者，要评估的维度主要是以下三个方面：</p><ul><li><p>第一个维度是结果评估。<br>即，你要回答“要不要做”，希望拿到什么结果，你要从哪几个维度去衡量结果，从哪几个技术指标去验收成果。</p></li><li><p>第二个维度是可行性评估。<br>可行性有两层含义：一是“能不能做”，二是“值不值得”。 能不能和值不值得，是两码事。不懂技术的管理者一般问的都是“能不能做”，而有经验的技术管理者和资深工程师，考虑的是“值不值得”。</p></li><li><p>第三个评估维度，即风险评估。<br>技术风险评估，也叫技术风险判断力。即，有哪些技术风险需要未雨绸缪，考虑该技术方案带来最大损失的可能性和边界，以及在什么情形下会发生。这项评估工作很考验技术管理者的技术经验和风险意识，而且需要借助全团队的技术力量来做出准确判断。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何保持判断力&quot;&gt;&lt;a href=&quot;#如何保持判断力&quot; class=&quot;headerlink&quot; title=&quot;如何保持判断力&quot;&gt;&lt;/a&gt;如何保持判断力&lt;/h1&gt;&lt;p&gt;作为一个技术管理者，即技术应用者，要评估的维度主要是以下三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://heima0.github.io/2021/11/10/Git/"/>
    <id>https://heima0.github.io/2021/11/10/Git/</id>
    <published>2021-11-10T06:46:34.000Z</published>
    <updated>2022-11-12T14:02:35.946Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-走入Git"><a href="#一-走入Git" class="headerlink" title="一. 走入Git"></a>一. 走入Git</h4><h5 id="1-Git介绍"><a href="#1-Git介绍" class="headerlink" title="1.Git介绍"></a>1.Git介绍</h5><blockquote><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p></blockquote><ul><li><p>版本控制</p><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p></li><li><p>团队协作</p><p>从单兵作战转换为团队开发。</p></li></ul><h5 id="2-Git对比SVN"><a href="#2-Git对比SVN" class="headerlink" title="2.Git对比SVN"></a>2.Git对比SVN</h5><p><img src="/img/git-img/image-20220907110331660.png" alt="image-20220907110331660" style="zoom:67%;"></p><ol><li><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己的代码推送到中央服务器。集中式版本控制系统是必须联网才能工作。</p></li><li><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上，可以离线工作。</p></li></ol><h5 id="3-Git安装"><a href="#3-Git安装" class="headerlink" title="3.Git安装"></a>3.Git安装</h5><blockquote><p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p></blockquote><p><img src="/img/git-img/image-20220907110802124.png" alt="image-20220907110802124"></p><ul><li><p>下载好以后，直接双击进行安装就行</p></li><li><p>一直下一步就可以，安装再默认路径就行</p></li><li><p>安装完毕后检测一下安装是否成功</p><ul><li><p>打开 <code>cmd</code> 窗口，输入指令检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检测 git 是否安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure><ul><li>出现版本号，说明安装成功</li></ul></li></ul></li><li><p>安装完毕，接下来我们就可以开始使用了</p></li></ul><h4 id="二-Git常用命令"><a href="#二-Git常用命令" class="headerlink" title="二.Git常用命令"></a>二.Git常用命令</h4><h5 id="1-设置用户签名"><a href="#1-设置用户签名" class="headerlink" title="1.设置用户签名"></a>1.设置用户签名</h5><blockquote><p>签名的作用就是用来标识用户，以区分不同的开发人员。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  git config --global user.email "you@example.com"</span><br><span class="line">  git config --global user.name "Your Name"</span><br></pre></td></tr></table></figure><h5 id="2-初始化本地库"><a href="#2-初始化本地库" class="headerlink" title="2.初始化本地库"></a>2.初始化本地库</h5><ul><li><p>我们希望一个文件夹被 <code>git</code> 管理的话，那么就要在一个文件夹下进行 <strong>git 初始化</strong></p></li><li><p>找到一个希望被 <code>git</code> 管理的文件夹</p></li><li><p>在文件夹内单击鼠标右键，点开 <code>Git Bash Here</code></p></li><li><p>输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git 初始化的指令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure></li><li><p>然后文件夹内会多一个 <code>.git</code> 的文件夹（这个文件夹是一个隐藏文件夹）</p></li><li><p>这个时候，我的这个 <code>git_demo</code> 文件夹就被 <code>git</code> 管理了</p><ul><li><code>git</code> 不光管理这一个文件夹，包括所有的子文件夹和子文件都会被管理</li></ul></li><li><p>注意： <strong>只有当一个文件夹被 git 管理以后，我们才可以使用 git 的功能去做版本管理</strong></p><ul><li>也就是说，我们必须要把我们电脑中的某一个文件夹授权给 <code>git</code></li><li><code>git</code> 才能对这个文件夹里面的内容进行各种操作</li><li>而 <code>git init</code> 就是在进行这个授权的操作</li></ul></li></ul><h5 id="3-Git工作区、暂存区和版本库"><a href="#3-Git工作区、暂存区和版本库" class="headerlink" title="3.Git工作区、暂存区和版本库"></a>3.Git工作区、暂存区和版本库</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/git-img/image-20220907112424167.png" alt="image-20220907112424167" title="">                </div>                <div class="image-caption">image-20220907112424167</div>            </figure><p><strong>托管平台</strong></p><ul><li>局域网(内网)<ul><li>gitlab</li></ul></li><li>公网（外网）<ul><li>gitlab</li><li>github</li><li>gitee 码云</li></ul></li></ul><h5 id="4-git-add"><a href="#4-git-add" class="headerlink" title="4.git add"></a>4.git add</h5><ul><li><p>我们要放入暂存区，要使用 <code>git add</code> 指令</p></li><li><p>把单独一个文件放在暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把文件夹下的 index.txt 文本放在暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add index.txt</span></span><br></pre></td></tr></table></figure></li><li><p>把单独一个文件夹放在暂存区（暂存区不能存放空文件夹）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把文件夹下的 ceshi文件夹 放在暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add ceshi/</span></span><br></pre></td></tr></table></figure></li><li><p>把所有文件都放在暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把文件夹下所有的内容都放在暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git add --all 有一个简单的写法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><ul><li>全部存放的时候使用上面两个指令哪个都行</li></ul></li></ul><h5 id="5-git-commit"><a href="#5-git-commit" class="headerlink" title="5.git commit"></a>5.git commit</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区的内容放到历史区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"我是第一个版本"</span></span></span><br></pre></td></tr></table></figure><p>我们使用 <code>git log</code> 这个指令查看版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前历史区版本信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><ul><li><p>我们使用 <code>git reset --hard 版本编号</code> 进行历史回退</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 回退到上一次提交的版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回退到上上次提交的版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^^</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD~2</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/img/git-img/image-20220908074740564.png" alt="image-20220908074740564" style="zoom:67%;float:left"></p><h5 id="6-git-revert-与-git-reset"><a href="#6-git-revert-与-git-reset" class="headerlink" title="6.git revert 与 git reset"></a>6.git revert 与 git reset</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/git-img/image-20220908075826032.png" alt="image-20220908075826032" title="">                </div>                <div class="image-caption">image-20220908075826032</div>            </figure><ul><li>git reset 是回滚到对应的commit-id，相当于是删除了commit-id以后的所有的提交，并且不会产生新的commit-id记录，如果要推送到远程服务器的话，需要强制推送-f</li><li>git revert 是反做撤销其中的commit-id，然后重新生成一个commit-id。本身不会对其他的提交commit-id产生影响，如果要推送到远程服务器的话，就是普通的操作git push就好了</li></ul><h4 id="三-Git-分支"><a href="#三-Git-分支" class="headerlink" title="三. Git 分支"></a>三. Git 分支</h4><h5 id="1-初识分支"><a href="#1-初识分支" class="headerlink" title="1.初识分支"></a>1.初识分支</h5><ul><li><code>git</code> 分支，就是我们自己把我们的整个文件夹分成一个一个独立的区域</li><li><p>比如我在开发 <strong>登录</strong> 功能的时候，可以放在 <code>login</code> 分支下进行开发</p><ul><li>开发 <strong>列表</strong> 功能的时候，可以放在 <code>list</code> 分支下进行开发</li><li>大家互不干扰，每一个功能都是一个独立的功能分支</li></ul></li><li>这样开发就会好很多</li><li><code>git</code> 在初始化的时候，会自动生成一个分支，叫做 <code>master</code> </li><li>是表示主要分支的意思</li><li>我们就可以自己开辟出很多独立分支</li></ul><h5 id="2-创建分支"><a href="#2-创建分支" class="headerlink" title="2.创建分支"></a>2.创建分支</h5><ul><li><p>开辟一个分支使用 <code>git branch 分支名称</code> 指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开辟一个 login 分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch login</span></span><br></pre></td></tr></table></figure></li><li><p>查看一下当前分支情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前分支情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure><ul><li>会看到，当前有两个分支了</li><li>一个是 <code>master</code>，一个是 <code>login</code></li><li>前面有个 <code>*</code> 号，并且有高亮显示的，表示你当前所处的分支</li></ul></li></ul><h5 id="3-切换分支"><a href="#3-切换分支" class="headerlink" title="3.切换分支"></a>3.切换分支</h5><ul><li><p>我们对 <strong>登录</strong> 功能的开发要移动到 <code>login</code> 分支去完成</p></li><li><p>我们切换所处分支使用 <code>git checkout 分支名称</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到 login 分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout login</span></span><br></pre></td></tr></table></figure></li><li><p>然后我们在整个分支上进行 <strong>登录</strong> 功能的开发</p></li><li><p>开发完毕以后，我们就在当前分支上进行提交</p></li><li><p>提交以后我们进行分支切换</p><ul><li>发现 <code>master</code> 上面还是最初始的状态</li><li>而 <code>login</code> 分支上有我们新写的 <strong>登录</strong> 功能的代码</li></ul></li><li><p>我们按照分支把所有功能都开发完毕了以后</p><ul><li>只要把所有代码都合并到 <code>master</code> 主分支上就行了</li></ul></li></ul><h5 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4.合并分支"></a>4.合并分支</h5><ul><li><p><code>git</code> 的合并分支，只能是把别的分支的内容合并到自己的分支上</p></li><li><p>使用的指令是 <code>git merge</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到 master 分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把 login 的内容合并到自己的分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge login</span></span><br></pre></td></tr></table></figure></li><li><p>这个时候，我们刚才在 <code>login</code> 上开发的东西就都来到了 <code>master</code> 主分支上</p></li><li><p>如果是有多个分支的话，那么所有的最后都合并到 <code>master</code> 分支上的时候</p></li><li><p>我们的主分支上就有完整网站的所有页面</p><ul><li>各个分支上都是单独的页面和功能</li></ul></li></ul><h5 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5.删除分支"></a>5.删除分支</h5><ul><li><p>这个时候我们开辟的分支就没有什么用了，就可以删除分支了</p><ol><li><p>先切换到别的分支</p></li><li><p>使用指令 <code>git branch -d 分支名称</code> 来删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先切换到别的分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 login 分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d login</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="四-远程仓库"><a href="#四-远程仓库" class="headerlink" title="四.远程仓库"></a>四.远程仓库</h4><ul><li>我们的所有内容已经全部保留在了本地历史区</li><li>理论上是不会丢失了<ul><li>但是如果把文件夹删除了，还是没有了</li></ul></li><li>所以我们要使用 <code>git</code> 把我们所有的内容推送到 <code>github</code> 上面保存起来</li><li>那么就本地文件夹就算删除了，那么远程上面还有一份，还可以拿回来使用</li><li>所以我们现在就要把本地内容推送到远程</li><li>这个时候我们接需要一个 <code>github</code> 的账号了</li><li>先去 <a href="https://github.com/" target="_blank" rel="noopener">github官网</a> 注册一个账号</li></ul><h5 id="1-创建一个远程仓库"><a href="#1-创建一个远程仓库" class="headerlink" title="1.创建一个远程仓库"></a>1.创建一个远程仓库</h5><ul><li><p>有了 <code>github</code>  账号以后</p></li><li><p>我们就登录 <code>github</code> 网站，开辟一个远程仓库</p></li><li><p><code>github</code> 的远程也是以一个仓库一个仓库的形式来保存代码</p><ul><li>我们可以在一个 <code>github</code> 上保存很多的项目</li><li>只要一个项目一个仓库就可以了</li></ul></li><li><p>按照下面步骤开辟仓库</p><ol><li><p>先点击新建仓库</p><p><img src="/img/git-img/github%E5%BC%80%E8%BE%9F%E4%BB%93%E5%BA%931.png" alt=""></p></li></ol></li></ul><h5 id="2-添加仓库地址"><a href="#2-添加仓库地址" class="headerlink" title="2.添加仓库地址"></a>2.添加仓库地址</h5><ul><li><p>接下来，要使用 <code>git</code> 上传代码了</p></li><li><p>我们先要告诉 <code>git</code> 上传到哪里</p></li><li><p>也就是给 <code>git</code> 添加一个上传的地址</p></li><li><p>我们还是来到我们的项目文件夹</p></li><li><p>使用 <code>git remote add origin 仓库地址</code> 来添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在项目文件夹下打开 git base</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加仓库地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin *********************</span></span><br></pre></td></tr></table></figure><ul><li>remote：远程的意思</li><li>add：添加的意思</li><li>origin：是一个变量名（就是指代后面一长串的地址）</li></ul></li></ul><h5 id="3-git-push"><a href="#3-git-push" class="headerlink" title="3.git push"></a>3.git push</h5><ul><li><p>上传到哪里的地址我们已经添加好了</p></li><li><p>接下来就是上传内容了</p><ul><li>上传要保证 <strong>历史区</strong> 里面有内容</li><li>上传的过程会把 <strong>历史区</strong> 里面所有的内容上传到远端</li></ul></li><li><p>我们使用 <code>git push</code> 指令来上传</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示把内容上传到 origin 这个地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master 是上传到远程的 master 分支</span></span><br></pre></td></tr></table></figure><ul><li>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</li></ul></li></ul><ul><li><p>第二次上传</p><ul><li><p>第二次上传的时候，因为有刚才的记录，就不需要再写 <code>origin</code> 和 <code>master</code> 了</p></li><li><p>会默认传递到 <code>origin</code> 这个地址的 <code>master</code> 分支上</p></li><li><p>除非你要传递到别的分支上的时候再进行书写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第二次上传</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>到这里，就完成了一次 <code>git</code> 推送</p></li><li><p>这个时候本地的文件夹就真的可以删除了</p></li><li><p>因为远程有一份我们的内容，本地的删除了，可以直接把远程的拉回来就行</p></li></ul><h5 id="4-git-clone"><a href="#4-git-clone" class="headerlink" title="4.git clone"></a>4.git clone</h5><ul><li><p><code>git</code> 克隆是指把远程仓库里面的内容克隆一份到本地</p></li><li><p>可以克隆别人的 <strong>公开</strong> 的仓库，也可以克隆自己的仓库</p></li><li><p>克隆别人的仓库，我们只能拿下来用，修改后不能从新上传</p></li><li><p>克隆自己的仓库，我们修改后还可以再次上传更新</p></li></ul><ul><li><p>输入克隆指令 <code>git clone 仓库地址</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接克隆仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> *************</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="5-git-pull"><a href="#5-git-pull" class="headerlink" title="5.git pull"></a>5.git pull</h5><ul><li><p>当人家的代码更新以后，你想获得最新的代码</p></li><li><p>我们不需要从新克隆</p></li><li><p>只要拉取一次代码就可以了</p></li><li><p>直接在项目文件夹里面使用指令下拉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取远程最新代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure></li><li><p>这样一来，你本地的仓库就可远程的仓库同步了</p></li></ul><h4 id="五-VScode集成Git"><a href="#五-VScode集成Git" class="headerlink" title="五.VScode集成Git"></a>五.VScode集成Git</h4><p>VSCode内置版本控制机制，并自带对Git和Github的支持，你也可以安装插件以支持其他控制软件，如SVN(需要先安装 SVN )等。</p><ol><li><p>初始化</p><p><img src="/img/git-img/image-20220910091354495.png" alt="image-20220910091354495" style="zoom:50%;float:left;"></p></li><li><p>可视化界面管理项目<br> <img src="/img/git-img/image-20220910091438534.png" alt="image-20220910091438534" style="zoom:67%;float:left;"></p></li></ol><h4 id="六-gitignore"><a href="#六-gitignore" class="headerlink" title="六. gitignore"></a>六. gitignore</h4><blockquote><p>在一些项目中，我们不想让本地仓库的所有文件都上传到远程仓库中，而是有选择的上传，比如：一些依赖文件（node_modules下的依赖）、bin 目录下的文件、测试文件等。一方面将一些依赖、测试文件都上传到远程传输量很大，另一方面，一些文件对于你这边是可用的，在另一个人那可能就不可用了，比如：本地配置文件。</p></blockquote><ul><li><p>空行不匹配任何文件；</p></li><li><p>如果本地仓库文件已被跟踪，那么即使在 .gitignore 中设置了忽略，也不起作用。</p></li><li><p>.gitignore 文件也会被上传的到远程仓库，所以，同一个仓库的人可以使用同一个.gitignore 文件。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># See https://help.github.com/articles/ignoring-files/ for more about ignoring files.</span><br><span class="line"># dependencies</span><br><span class="line"># #开头的便是注释</span><br><span class="line"></span><br><span class="line"># 忽略文件和目录</span><br><span class="line">/node_modules</span><br><span class="line">/.pnp</span><br><span class="line">.pnp.js</span><br><span class="line"></span><br><span class="line"># testing</span><br><span class="line">/coverage</span><br><span class="line"></span><br><span class="line"># production</span><br><span class="line">/build</span><br><span class="line"></span><br><span class="line"># misc</span><br><span class="line">.DS_Store</span><br><span class="line">.env.local</span><br><span class="line">.env.development.local</span><br><span class="line">.env.test.local</span><br><span class="line">.env.production.local</span><br><span class="line"></span><br><span class="line"># 使用通配符</span><br><span class="line">npm-debug.log*</span><br><span class="line">yarn-debug.log*</span><br><span class="line">yarn-error.log*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-走入Git&quot;&gt;&lt;a href=&quot;#一-走入Git&quot; class=&quot;headerlink&quot; title=&quot;一. 走入Git&quot;&gt;&lt;/a&gt;一. 走入Git&lt;/h4&gt;&lt;h5 id=&quot;1-Git介绍&quot;&gt;&lt;a href=&quot;#1-Git介绍&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="git" scheme="https://heima0.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Cache</title>
    <link href="https://heima0.github.io/2020/07/12/HTTP-Cache/"/>
    <id>https://heima0.github.io/2020/07/12/HTTP-Cache/</id>
    <published>2020-07-12T12:32:58.000Z</published>
    <updated>2022-11-12T14:02:35.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简析强制缓存和协商缓存"><a href="#简析强制缓存和协商缓存" class="headerlink" title="简析强制缓存和协商缓存"></a>简析强制缓存和协商缓存</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>  浏览器和服务器进行交互的过程， 时间开销的瓶颈往往出现在数据的传输的过程之中。</p><p>  这个场景类似介于 A城 到 B城 之间只有一座 “通道” ， 每次想从A城 到 B城 ，必须按照人数交付高昂的路费， 那么如果要减少这种高昂的路费开销的话， 核心思想就是尽可能的减少通过这座 “通道” 的次数又或者减少通过这座通道的“人数”。基于这种理念，在 http协议的基础上， 提出了一种协议缓存， 这种协议缓存又可以细分为 强制缓存 和 协商缓存 两种，分别对应上述减少过桥次数和减少过桥人数的理念。</p><h2 id="http缓存机制简介"><a href="#http缓存机制简介" class="headerlink" title="http缓存机制简介"></a>http缓存机制简介</h2><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>  强制缓存的思想是，在浏览器内置数据库中缓存每次请求中 “可以被缓存” （受到一些关键字的管控）的静态资源如 image, css, js 文件， 当第二次请求被缓存过的资源时候，会通过校验两个字段 Expires 和 Cache-Control 的max-age字段（注意，Expires 是 http1.0 的产物， Cache-Control 则是 http1.1 的产物。 两者同时存在， 或者只存在其中之一， 都可以触发强制缓存）</p><p>  当满足字段约束的情况下， 浏览器就不会向服务器发送请求而是直接从服务器返回数据， 同时其状态码为 200</p><p>  当不满足字段约束的情况下， 浏览器则会向服务器正常发送请求</p><p>  强制缓存主要取决于两个字段 Expires 和 Cache-Control 中的 max-age 字段， 在两个响应头都存在的情况下， Cache-Control 中的 max-age 字段字段优先级会稍微高一点， 当 Cache-Control 中的 max-age 字段校验成功，会直接返回浏览器内置数据库的缓存， 失效时才会将决策权传递给 Expires 字段判断。</p><p>  这样设计的原因，大概是因为 Expires 字段在设计时存在了这么一个缺陷——Expires字段返回的是服务器的时间， 而非客户端的本机时间。 当存在时差， 或者客户修改本地时间的情况下 Expires 字段会存在失效的可能性，比如 当同一时刻下的服务器时间为 2022/4/26 06:00:00 客户端时间为 2022/4/26 12:00:00 过期时间为两个小时之后， 则服务器会返回 2022/4/26 08:00:00 这个时间对应的值。由于浏览器运行在客户环境下，对于客户而言， 这个缓存已经过期了，虽然缓存确实有效， 但是对于浏览器而言这个缓存确确实实是 “过期了”， 这会导致强制缓存永远不会生效！</p><p>  那么为了解决这个问题， http 1.1 协议中添加了 Cache-Control 中的 max-age， 他是一个相对值， 即客户端获取到这个文件多少秒后失效， 其判别权力全权交由浏览器， 这会相对更准确些。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>  协商缓存主要由 ETag 和 Last-Modified 两个字段来实现</p><p>  ETag 是一个用于映射 web 资源的映射 token，这个 token 应该满足唯一对应到一 个web服务器上的静态资源（具体实现通常是提取文件相关信息进行hash和base64编码等操作）</p><p>  Last-Modified 则通常是文件最后更新的日期时间戳</p><p>  （通过上述两个字段就可以判断当前文件是否是最新的数据）</p><p>  与上述两个字段配对的分别是 If-None-Match 和 If-Modified-Since 这两个字段</p><p>  浏览器首次向服务器请求数据 A， 服务器正常返回数据，同时在响应头中放入 ETag 和 Last-Modified 两个新字段。</p><p>  当浏览器第二次向服务器请求数据 A 时， 浏览器会自动地在请求头附上 If-None-Match 和 If-Modified-Since 两个字段（分别对应的是 ETag 和 Last-Modified 的值，两两相等）， 然后由服务器端进行校验， 校验通过的话（表明数据有效）， 服务器会直接返回 状态码 304 ，且不携带响应体的报文段， 这相当于告诉浏览器：当前缓存有效， 可以直接使用！ 校验失败则会和首次请求一样， 返回状态码为200且携带数据响应体的报文段， 同时这个响应头会带上新的ETag 和Last-Modified， 为下一次协商缓存做好铺垫 。</p><blockquote><p>注意， 在不用框架的情况下， 协商缓存需要由后端开发人员手动实现，因此 ETag 和 Last-Modified 两个字段的优先级取决于开发者， 但是 Last-Modified 这个字段可以记录的时间戳精确度是有一定限制的，如果连续多次数据更新在精确度范围外， 会产生精确度丢失， 因此通常会让ETag 的优先级高于 Last-Modified 字段（类似于Cache-control中max-age一样， 属于是后续改进协议的一个新字段， 因此优先级一般会高点）</p></blockquote><h4 id="强制缓存-协商缓存"><a href="#强制缓存-协商缓存" class="headerlink" title="强制缓存 + 协商缓存"></a>强制缓存 + 协商缓存</h4><ol><li><p>默认情况下， 浏览器会优先考量强制缓存的情况， 当强制缓存生效的情况下， 请求并不会到达服务器， 因此也就不会触发协商缓存。 当强制缓存失效的时候， 浏览器便会将请求传递到服务器， 于是服务器又会开始校验 If-Modified-Since 和 If-None-math 两个字段， 重复上述协商缓存的一个执行流程</p></li><li><p>乍一看，两者并存的情况， 有点像是两个协议的简单叠加，此时的协商缓存更像是强制缓存的兜底策略， 很可能协商缓存很长一段时间都不会生效（强制缓存过期时间设置过长的情况下）， 因为强制缓存的优先级是要高于协商缓存的。 当然这并不是我们想看到的， 比方说当后端数据确实变更了， 而此时的浏览器由于使用了强制缓存，则会出现数据不一致的情况， 因此在这里引入了请求头中的两个字段 no-cache， 当使用了 no-cache 字段的时候， 浏览器将不再使用强制缓存， 而是直接去请求服务器， 这个时候就会用到协商缓存了（顺带一提的是， 还有一个 no-store 字段， 用了这个字段浏览器则不会在使用缓存的数据也不缓存数据，即强制缓存和协商缓存都失效了）</p></li></ol><h4 id="缓存机制之间的一些区别"><a href="#缓存机制之间的一些区别" class="headerlink" title="缓存机制之间的一些区别"></a>缓存机制之间的一些区别</h4><ul><li>强制缓存在缓存有效的情况下不会去请求服务器， 其数据来源则是浏览缓存的本地磁盘。而协商缓存会向服务器请求，但是在协商缓存成功的情况下， 服务器只会返回一个不带响应体的报文，结合开头的背景来说 强制缓存选择“减少过桥次数”的策略， 而协商缓存则是采用 ‘减少过桥人数’的策略</li><li>强制缓存在浏览器强制刷新的情况下不会生效， 而协商缓存则不受影响。（调试代码测试时候，要注意）</li><li>强制缓存返回的报文状态码为 200， 协商缓存返回的报文状态码为 304 （前端使用fetch请求的情况， 协商缓存的 状态码304 会转成 200）</li><li>强制缓存发生在浏览器端， 协商缓存发生在服务器端</li></ul><h2 id="使用小结"><a href="#使用小结" class="headerlink" title="使用小结"></a>使用小结</h2><p>  强制缓存和协商缓存需要具体条件下来用</p><ul><li>强制缓存存在一个瓶颈， 当浏览器用户强刷新时，浏览器会直接跳过强制缓存， 这点不注意很容易会被忽视掉。</li><li>强制缓存不适合 SPA 应用的入口文件， 因为重新部署后， 用户如果没有强制刷新， 则无法在第一时间内看到新的网页内容。</li><li>作为一个前端开发者可以通过设置请求头中的 no-cache 和 no-store 字段选择使用协商缓存或者不使用缓存！！！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简析强制缓存和协商缓存&quot;&gt;&lt;a href=&quot;#简析强制缓存和协商缓存&quot; class=&quot;headerlink&quot; title=&quot;简析强制缓存和协商缓存&quot;&gt;&lt;/a&gt;简析强制缓存和协商缓存&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="浏览器" scheme="https://heima0.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存" scheme="https://heima0.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>标签marquee</title>
    <link href="https://heima0.github.io/2018/04/10/%E6%A0%87%E7%AD%BEmarquee/"/>
    <id>https://heima0.github.io/2018/04/10/标签marquee/</id>
    <published>2018-04-10T08:36:59.000Z</published>
    <updated>2022-11-12T14:02:35.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML-marquee-元素-（用来插入一段滚动的文字。你可以使用它的属性控制当文本到达容器边缘发生的事情。）"><a href="#HTML-marquee-元素-（用来插入一段滚动的文字。你可以使用它的属性控制当文本到达容器边缘发生的事情。）" class="headerlink" title="HTML marquee 元素  （用来插入一段滚动的文字。你可以使用它的属性控制当文本到达容器边缘发生的事情。）"></a>HTML marquee 元素 <marquee> （用来插入一段滚动的文字。你可以使用它的属性控制当文本到达容器边缘发生的事情。）</marquee></h2><ul><li><p>使用marquee标记不仅可以移动文字，也可以移动图片，表格等.</p></li><li><p>语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee&gt;...&lt;/marquee&gt;</span><br></pre></td></tr></table></figure></li><li><p>说明：在标记之间添加要进行滚动的内容。</p><h3 id="重要属性："><a href="#重要属性：" class="headerlink" title="重要属性："></a>重要属性：</h3></li><li><p>滚动方向direction（设置 marquee 内文本滚动的方向。可选值有 left, right, up and down。如果未指定值，默认值为 left。）</p></li></ul><p>　　+ 语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee direction=&quot;滚动方向&quot;&gt;...&lt;/marquee&gt;</span><br></pre></td></tr></table></figure></code></pre><ul><li>滚动方式behavior（scroll:循环滚动，默认效果； slide:只滚动一次就停止； alternate:来回交替进行滚动）</li></ul><p>　　+ 语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee behavior=&quot;滚动方式&quot;&gt;...&lt;/marquee&gt;</span><br></pre></td></tr></table></figure></code></pre><ul><li>滚动速度scrollamount（设置每次滚动时移动的长度（以像素为单位）。默认值为 6。）</li></ul><p>　　+ 语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee scrollamount=&quot;5&quot;&gt;...&lt;/marquee&gt;</span><br></pre></td></tr></table></figure></code></pre><ul><li>滚动延迟scrolldelay（设置每次滚动时的时间间隔（以毫秒为单位）。默认值为 85。请注意， 除非指定 truespeed 值，否则将忽略任何小于 60 的值，并改为使用 60。）</li></ul><p>　　+语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee scrolldelay=&quot;100&quot;&gt;...&lt;/marquee&gt;</span><br></pre></td></tr></table></figure></code></pre><ul><li>滚动循环loop（设置 marquee 滚动的次数。如果未指定值，默认值为 −1，表示 marquee 将连续滚动.）</li></ul><p>　　+ 语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee loop=&quot;2&quot;&gt;...&lt;/marquee&gt;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>滚动范围width、height</p></li><li><p>滚动背景颜色bgcolor</p></li><li><p>空白空间hspace、vspace</p></li></ul><h3 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; charset=utf-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;marquee&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;marquee direction=&quot;up&quot; behavior=&quot;alternate&quot; scrollamount=&quot;5&quot; scrolldelay=&quot;0&quot; loop=&quot;-1&quot; width=&quot;1000&quot; height=&quot;50&quot; bgcolor=&quot;#0099FF&quot; hspace=&quot;10&quot; vspace=&quot;10&quot;&gt;</span><br><span class="line">        up:Marquee对齐方式; scroll:设置滚动的方式;</span><br><span class="line">        scrollamount:设置每次滚动时移动的长度（以像素为单位）。默认值为 6;</span><br><span class="line">      &lt;/marquee&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>### 官方建议不使用—  &lt;marquee&gt; 元素已经 过时，请不要再使用。尽管一些浏览器仍然支持它，但它不是必须的。此外，使用这个元素基本上是你可以对你的用户做最糟糕的事情之一，所以请不要这样做。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML-marquee-元素-（用来插入一段滚动的文字。你可以使用它的属性控制当文本到达容器边缘发生的事情。）&quot;&gt;&lt;a href=&quot;#HTML-marquee-元素-（用来插入一段滚动的文字。你可以使用它的属性控制当文本到达容器边缘发生的事情。）&quot; class=
      
    
    </summary>
    
    
      <category term="html" scheme="https://heima0.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>数组filter方法</title>
    <link href="https://heima0.github.io/2018/04/07/%E6%95%B0%E7%BB%84filter%E6%96%B9%E6%B3%95/"/>
    <id>https://heima0.github.io/2018/04/07/数组filter方法/</id>
    <published>2018-04-07T02:30:29.000Z</published>
    <updated>2022-11-12T14:02:35.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-Array-filter-方法"><a href="#JavaScript-Array-filter-方法" class="headerlink" title="JavaScript Array filter() 方法"></a>JavaScript Array filter() 方法</h2><h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><ul><li><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><ul><li><p>注意： filter() 不会对空数组进行检测。</p></li><li><p>注意： filter() 不会改变原始数组。</p></li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.filter(function(value,index,arr), thisValue)</span><br></pre></td></tr></table></figure><h3 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">  &#123; id: 1, text: &apos;aa&apos;, done: true &#125;,</span><br><span class="line">  &#123; id: 2, text: &apos;bb&apos;, done: false &#125;</span><br><span class="line">]</span><br><span class="line">console.log(arr.filter(function (item) &#123;</span><br><span class="line">  return item.done;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>返回一个新数组，打印的值 [{ id: 1, text: ‘aa’, done: true }]</li><li>新数组中的值为return true的value。return后面判断结果，取布尔值，true的话就添入新的filter数组中，false的话，不会添进filter的数组中</li></ul><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>  兼容主流浏览器，其中IE9/IE9+</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-Array-filter-方法&quot;&gt;&lt;a href=&quot;#JavaScript-Array-filter-方法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Array filter() 方法&quot;&gt;&lt;/a&gt;JavaSc
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue-11</title>
    <link href="https://heima0.github.io/2018/03/15/vue-11/"/>
    <id>https://heima0.github.io/2018/03/15/vue-11/</id>
    <published>2018-03-15T12:12:31.000Z</published>
    <updated>2022-11-12T14:02:35.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h6 id="简单路由实现："><a href="#简单路由实现：" class="headerlink" title="简单路由实现："></a>简单路由实现：</h6><ol><li><p>引入vue-router，如果是在脚手架中，引入VueRouter之后，需要通过Vue.use来注册插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">Vue.use(Router)</span><br></pre></td></tr></table></figure></li><li><p>创建router路由器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Router(options)</span><br></pre></td></tr></table></figure></li><li><p>创建路由表并配置在路由器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var routes = [</span><br><span class="line">    &#123;path,component&#125;//path为路径，component为路径对应的路由组件</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">new Router(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在根实例里注入router,目的是为了让所有的组件里都能通过this.$router、this.$route来使用路由的相关功能api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">router,</span><br><span class="line">template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>利用router-view来指定路由切换的位置</p></li><li><p>使用router-link来创建切换的工具，会渲染成a标签，添加to属性来设置要更改的path信息，且会根据当前路由的变化为a标签添加对应的router-link-active/router-link-exact-active（完全匹配成功）类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;main&quot;&gt;main&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;news&quot;&gt;news&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">.router-link-active&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由:"></a>多级路由:</h6><p>在创建路由表的时候，可以为每一个路由对象创建children属性，值为数组，在这个里面又可以配置一些路由对象来使用多级路由，注意：一级路由path前加’/‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;path:&apos;/main&apos;,component:AppMain&#125;,</span><br><span class="line">  &#123;path:&apos;/news&apos;,component:AppNews,children:[</span><br><span class="line">    &#123;path:&apos;inside&apos;,component:AppNewsInside&#125;,</span><br><span class="line">    &#123;path:&apos;outside&apos;,component:AppNewsOutside&#125;</span><br><span class="line">  ]&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>二级路由组件的切换位置依然由router-view来指定（指定在父级路由组件的模板中）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&apos;inside&apos;&gt;inside&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&apos;outside&apos;&gt;outside&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h6 id="默认路由和重定向："><a href="#默认路由和重定向：" class="headerlink" title="默认路由和重定向："></a>默认路由和重定向：</h6><p>当我们进入应用，默认像显示某一个路由组件，或者当我们进入某一级路由组件的时候想默认显示其某一个子路由组件，我们可以配置默认路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;path:&apos;&apos;,component:Main&#125;</span><br></pre></td></tr></table></figure></p><p>当我们需要进入之后进行重定向到其他路由的时候，或者当url与路由表不匹配的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;path:&apos;&apos;,redirect:&apos;/main&apos;&#125;</span><br><span class="line">///...放在最下面</span><br><span class="line">&#123;path:&apos;**&apos;,redirect:&apos;/main&apos;&#125;,</span><br></pre></td></tr></table></figure></p><h6 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h6><p>我们可以给路由对象配置name属性，这样的话，我们在跳转的时候直接写name:main就会快速的找到此name属性对应的路由，不需要写大量的urlpath路径了</p><h6 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h6><p>有的时候我们需要在路由跳转的时候跟上参数，路由传参的参数主要有两种：路径参数、queryString参数</p><p>路由参数需要在路由表里设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;path:&apos;/user/:id&apos;,component:User&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是给User路由配置接收id的参数，多个参数继续在后面设置</p><p>在组件中可以通过this.$route.params来使用</p><p>queryString参数不需要在路由表设置接收，直接设置？后面的内容，在路由组件中通过this.$route.query接收</p><h6 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h6><p><router-link> 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 <a> 标签，可以通过配置 tag 属性生成别的标签.。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。</a></router-link></p><p>router-link的to属性，默认写的是path（路由的路径），可以通过设置一个对象，来匹配更多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:to=&apos;&#123;name:&quot;detail&quot;,params:&#123;id:_new.id&#125;,query:&#123;content:_new.content&#125;&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>name是要跳转的路由的名字，也可以写path来指定路径，但是用path的时候就不能使用params传参，params是传路径参数，query传queryString参数</p><p>replace属性可以控制router-link的跳转不被记录\</p><p>active-class属性可以控制路径切换的时候对应的router-link渲染的dom添加的类名</p><h5 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h5><p>有的时候需要在跳转前进行一些动作，router-link直接跳转，需要在方法里使用$router的方法</p><p>router.push = router-link:to<br>router.replace = router-link:to.replace<br>router.go() = window.history.go</p><h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><p>路由有两种模式：hash、history，默认会使用hash模式，但是如果url里不想出现丑陋hash值，在new VueRouter的时候配置mode值为history来改变路由模式，本质使用H5的histroy.pushState方法来更改url，不会引起刷新，但是需要后端进行路由的配置</p><h5 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h5><p>在某些情况下，当路由跳转前或跳转后、进入、离开某一个路由前、后，需要做某些操作，就可以使用路由钩子来监听路由的变化</p><p>全局路由钩子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    //会在任意路由跳转前执行，next一定要记着执行，不然路由不能跳转了</span><br><span class="line">  console.log(&apos;beforeEach&apos;)</span><br><span class="line">  console.log(to,from)</span><br><span class="line">  //</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">//</span><br><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">    //会在任意路由跳转后执行</span><br><span class="line">  console.log(&apos;afterEach&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>单个路由钩子：<br>只有beforeEnter，在进入前执行，to参数就是当前路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">   &#123;</span><br><span class="line">     path: &apos;/foo&apos;,</span><br><span class="line">     component: Foo,</span><br><span class="line">     beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">       // ...</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></p><p>路由组件钩子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">  // 不！能！获取组件实例 `this`</span><br><span class="line">  // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">  // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">  // 导航离开该组件的对应路由时调用</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h5><p>有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置（带上 s）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        default: Foo,//默认的，没有name的router-view</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="prop将路由与组件解耦"><a href="#prop将路由与组件解耦" class="headerlink" title="prop将路由与组件解耦"></a>prop将路由与组件解耦</h5><p>在组件中接收路由参数需要this.$route.params.id,代码冗余，现在可以在路由表里配置props：true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;path:&apos;detail/:id&apos;,component:AppNewsDetail,name:&apos;detail&apos;,props:true&#125;</span><br></pre></td></tr></table></figure></p><p>在路由自己中可以通过props接收id参数去使用了</p><p>props:[‘id’]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot;路由&quot;&gt;&lt;/a&gt;路由&lt;/h2&gt;&lt;h6 id=&quot;简单路由实现：&quot;&gt;&lt;a href=&quot;#简单路由实现：&quot; class=&quot;headerlink&quot; title=&quot;简单路由实现：&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-10</title>
    <link href="https://heima0.github.io/2018/01/30/vue-10/"/>
    <id>https://heima0.github.io/2018/01/30/vue-10/</id>
    <published>2018-01-30T11:16:51.000Z</published>
    <updated>2022-11-12T14:02:35.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="钩子函数、vue-cli脚手架"><a href="#钩子函数、vue-cli脚手架" class="headerlink" title="钩子函数、vue-cli脚手架"></a>钩子函数、vue-cli脚手架</h2><h5 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h5><p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cn.vuejs.org/images/lifecycle.png" alt="生命周期图示" title="">                </div>                <div class="image-caption">生命周期图示</div>            </figure><ol><li><p>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载ね，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</p></li><li><p>挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</p></li><li><p>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</p></li><li><p>接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情…</p></li><li><p>当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</p></li><li><p>当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</p></li><li><p>当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</p></li><li><p>组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以</p></li></ol><h5 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h5><p>现在使用前端工程化开发项目是主流的趋势，也就是说，我们需要使用一些工具来搭建vue的开发环境，一般情况下我们使用webpack来搭建，在这里我们直接使用vue官方提供的，基于webpack的脚手架工具：vue-cli</p><p>安装方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">npm install --global vue-cli</span><br><span class="line"># 创建一个基于 webpack 模板的新项目</span><br><span class="line">vue init webpack my-project</span><br><span class="line">//init之后可以定义模板的类型</span><br><span class="line"># 安装依赖，走你</span><br><span class="line">cd my-project</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>模板类型：</p><p>simple 对应的是一个超级简单的html文件</p><p>webpack 在配置的时候可以选择是否需要vue-router</p><p>注意的是，模板创建的时候会询问使用需要使用ESLINT来标准化我们的代码</p><p>在脚手架中，开发目录是src文件夹，build负责打包的，config是负责配置（内置服务器的端口、proxy代理），static是静态目录，test是测试</p><p>src中main.js是入口文件，在里面创建了一个根实例，根实例的模板就是根组件App的模板，其他的组件都在根组件里面进行嵌套实现。</p><p>每一个组件都是一个单文件组件，这种文件会被webpack利用vue-loader的工具进行编译</p><p>template部分负责写组件的模板内容，script中创建组件。style里写组件的样式</p><p>assets目录也是静态目录，在这个目标中的文件我们使用相对路径引入,而static目录中的文件使用绝对地址来引入</p><p>在style上添加scoped能使这个style里的样式只作用于当前的组件，不加scoped就是全局样式</p><p>习惯于在App.vue根组件的style里写全局样式，而每个组件的style最好都是局部的</p><p>配置sass编译环境</p><p>vue-cli没有内置sass编译，我们需要自己修改配置</p><ol><li><p>下载对应工具：node-sass(4.0.0) sass-loader</p></li><li><p>在build目录下的webpack.base.conf.js中的module.rule里添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.scss$/,</span><br><span class="line">    loader:&apos;style-loader!css-loader!sass-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在需要使用scss代码的组件的style标签中添加 lang=’scss’</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;钩子函数、vue-cli脚手架&quot;&gt;&lt;a href=&quot;#钩子函数、vue-cli脚手架&quot; class=&quot;headerlink&quot; title=&quot;钩子函数、vue-cli脚手架&quot;&gt;&lt;/a&gt;钩子函数、vue-cli脚手架&lt;/h2&gt;&lt;h5 id=&quot;组件的生命周期&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-9</title>
    <link href="https://heima0.github.io/2018/01/18/vue-9/"/>
    <id>https://heima0.github.io/2018/01/18/vue-9/</id>
    <published>2018-01-18T01:13:55.000Z</published>
    <updated>2022-11-12T14:02:35.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="slot-transition-渲染函数和jsx"><a href="#slot-transition-渲染函数和jsx" class="headerlink" title="slot-transition-渲染函数和jsx"></a>slot-transition-渲染函数和jsx</h2><h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><p>vue里提供了一种将父组件的内容和子组件的模板整合的方法：内容分发，通过slot插槽来实现</p><ol><li>匿名插槽<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;aaa&gt;abc&lt;/aaa&gt;</span><br><span class="line"></span><br><span class="line">template:&quot;&lt;h1&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/h1&gt;&quot;</span><br></pre></td></tr></table></figure></li></ol><p>在父组件中使用子组件的时候，在子组件标签内部写的内容，在子组件的模板中可以通过<slot></slot>来使用</p><ol start="2"><li>具名插槽</li></ol><p>父组件在子组件标签内写的多个内容我们可以给其设置slot属性来命名，在子组件的模板通过通过使用带有name属性的slot标签来放置对应的slot，当slot不存在的时候，slot标签内写的内容就出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-button&gt;提交&lt;/my-button&gt;</span><br><span class="line">&lt;my-button&gt;重置&lt;/my-button&gt;</span><br><span class="line">&lt;my-button&gt;&lt;/my-button&gt;</span><br><span class="line"></span><br><span class="line">template:&quot;&lt;button&gt;&lt;slot&gt;按钮&lt;/slot&gt;&lt;/button&gt;&quot;</span><br></pre></td></tr></table></figure></p><h5 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h5><p>Vue提供了transition组件来帮助我们实现过渡效果，依据就是在控制元素显示隐藏的时候为dom在指定的时刻添加上对应的类名</p><p>而我们只要在这些类名里写上对应的css样式</p><p>在进入/离开的过渡中，会有 6 个 class 切换(v代表的是transition的name属性的值)。</p><p>v-enter：定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</p><p>v-enter-active：定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</p><p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效 (于此同时 v-enter 被删除)，在 transition/animation 完成之后移除。</p><p>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</p><p>v-leave-active：定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</p><p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效 (于此同时 v-leave 被删除)，在 transition/animation 完成之后移除。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cn.vuejs.org/images/transition.png" alt="className" title="">                </div>                <div class="image-caption">className</div>            </figure><p>如果有多个元素需要用transition-group包裹，并且需要有key值做标记</p><p>animate.css:</p><p>引入animate.css之后，按照下面的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">    leave-active-class=&quot;animated fadeOut&quot;</span><br><span class="line">    enter-active-class=&quot;animated slideInLeft&quot;&gt;</span><br><span class="line">        &lt;p v-if=&quot;isShow&quot; class=&quot;box&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><h5 id="渲染函数和jsx"><a href="#渲染函数和jsx" class="headerlink" title="渲染函数和jsx"></a>渲染函数和jsx</h5><p>在vue中我们可以不用template来指定组件的模板，而是用render函数来创建虚拟dom结构，用这种方法优点就是性能高，缺点就是使用成本高，代码可读性较低，可以使用jsx来在render函数中创建，这样既提高了性能，又减少了成本</p><p>但是，我们在使用了vue-cli脚手架之后，因为脚手架中有对template标签转换虚拟dom的处理，所以，不需要使用jsx，我们也能高效的转换为createElement形式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;slot-transition-渲染函数和jsx&quot;&gt;&lt;a href=&quot;#slot-transition-渲染函数和jsx&quot; class=&quot;headerlink&quot; title=&quot;slot-transition-渲染函数和jsx&quot;&gt;&lt;/a&gt;slot-transitio
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-8</title>
    <link href="https://heima0.github.io/2017/10/24/vue-8/"/>
    <id>https://heima0.github.io/2017/10/24/vue-8/</id>
    <published>2017-10-24T12:43:04.000Z</published>
    <updated>2022-11-12T14:02:35.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h6 id="prop-传递数据"><a href="#prop-传递数据" class="headerlink" title="prop 传递数据"></a>prop 传递数据</h6><p>组件实例的作用域是孤立的,父组件不能直接使用子组件的数据，子组件也不能直接使用父组件的数据</p><p>父组件在模板中使用子组件的时候可以给子组件传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bbb money=&quot;2&quot;&gt;&lt;/bbb&gt;</span><br></pre></td></tr></table></figure><p>子组件需要通过props属性来接收后才能使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;bbb&apos;:&#123;</span><br><span class="line">    props:[&apos;money&apos;]</span><br></pre></td></tr></table></figure><p>如果父组件传递属性给子组件的时候键名有’-‘，子组件接收的时候写成小驼峰的模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bbb clothes-logo=&apos;amani&apos; clothes-price=&quot;16.58&quot;&gt;&lt;/bbb&gt;</span><br><span class="line">////</span><br><span class="line">props:[&apos;clothesLogo&apos;,&apos;clothesPrice&apos;]</span><br></pre></td></tr></table></figure></p><p>我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件</p><h6 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h6><p>Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。</p><p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</p><p>在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p><ol><li><p>Prop 作为初始值传入后，子组件想把它当作局部数据来用；</p></li><li><p>Prop 作为原始数据传入，由子组件处理成其它数据输出。<br>对这两种情况，正确的应对方式是：</p></li></ol><p>定义一个局部变量，并用 prop 的值初始化它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;initialCounter&apos;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123; counter: this.initialCounter &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义一个计算属性，处理 prop 的值并返回：</span><br><span class="line">props: [&apos;size&apos;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p></blockquote><h6 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h6><p>我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用</p><p>验证主要分为：类型验证、必传验证、默认值设置、自定义验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    //类型验证:</span><br><span class="line">    str:String,</span><br><span class="line">    strs:[String,Number],</span><br><span class="line">    //必传验证</span><br><span class="line">    num:&#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        required:true</span><br><span class="line">    &#125;,</span><br><span class="line">    //默认数据</span><br><span class="line">    bool:&#123;</span><br><span class="line">        type:Boolean,</span><br><span class="line">        // default:true,</span><br><span class="line">        default:function()&#123;</span><br><span class="line"></span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //自定义验证函数</span><br><span class="line">    nums:&#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        validator: function (value) &#123;</span><br><span class="line">            return value %2 == 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当父组件传递数据给子组件的时候，子组件不接收，这个数据就会挂载在子组件的模板的根节点上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件间通信&quot;&gt;&lt;a href=&quot;#组件间通信&quot; class=&quot;headerlink&quot; title=&quot;组件间通信&quot;&gt;&lt;/a&gt;组件间通信&lt;/h2&gt;&lt;h6 id=&quot;prop-传递数据&quot;&gt;&lt;a href=&quot;#prop-传递数据&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>时间戳——&gt;时间</title>
    <link href="https://heima0.github.io/2017/09/10/%E6%97%B6%E9%97%B4%E6%88%B3%E2%80%94%E2%80%94-%E6%97%B6%E9%97%B4/"/>
    <id>https://heima0.github.io/2017/09/10/时间戳——-时间/</id>
    <published>2017-09-10T03:55:12.000Z</published>
    <updated>2022-11-12T14:02:35.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><pre><code>- 时间戳 --&gt; 日期  yyyy-mm-dd hh:mm:ss<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function formatDate(ns)&#123;</span><br><span class="line">    if(ns==0 || isNaN(ns)) &#123; return &apos;&apos; &#125;</span><br><span class="line">    var date = new Date(parseInt(ns) * 1000);</span><br><span class="line">        Y = date.getFullYear() + &apos;-&apos;;</span><br><span class="line">        M = (date.getMonth()+1 &lt; 10 ? &apos;0&apos;+(date.getMonth()+1) : date.getMonth()+1) + &apos;-&apos;;</span><br><span class="line">        D = (date.getDate() &lt; 10 ? &apos;0&apos;+ date.getDate() : date.getDate())+ &apos; &apos;;</span><br><span class="line">        h = (date.getHours() &lt; 10 ? &apos;0&apos;+ date.getHours() : date.getHours()) + &apos;:&apos;;</span><br><span class="line">        m = (date.getMinutes() &lt; 10 ? &apos;0&apos;+ date.getMinutes() : date.getMinutes()) + &apos;:&apos;;</span><br><span class="line">        s = (date.getSeconds() &lt; 10 ? &apos;0&apos;+ date.getSeconds() : date.getSeconds());  </span><br><span class="line">    return Y+M+D+h+m+s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>+ 如果 ns是13位数，那么就不用 *1000 。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时间戳&quot;&gt;&lt;a href=&quot;#时间戳&quot; class=&quot;headerlink&quot; title=&quot;时间戳&quot;&gt;&lt;/a&gt;时间戳&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- 时间戳 --&amp;gt; 日期  yyyy-mm-dd hh:mm:ss
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue-7</title>
    <link href="https://heima0.github.io/2017/08/20/vue-7/"/>
    <id>https://heima0.github.io/2017/08/20/vue-7/</id>
    <published>2017-08-20T04:04:09.000Z</published>
    <updated>2022-11-12T14:02:35.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟dom以及组件化"><a href="#虚拟dom以及组件化" class="headerlink" title="虚拟dom以及组件化"></a>虚拟dom以及组件化</h2><h5 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h5><p>频繁且复杂的dom操作通常是前端性能瓶颈的产生点，Vue提供了虚拟dom的解决办法</p><p>虚拟的DOM的核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作。这句话，也许过于抽象，却基本概况了虚拟DOM的设计思想</p><p>(1) 提供一种方便的工具，使得开发效率得到保证<br>(2) 保证最小化的DOM操作，使得执行效率得到保证</p><p>也就是说，虚拟dom的框架/工具都是这么做的：</p><ol><li>根据现有的真实dom来生成一个完整的虚拟dom树结构</li><li>当数据变化，或者说是页面需要重新渲染的时候，会重新生成一个新的完整的虚拟dom</li><li>拿新的虚拟dom来和旧的虚拟dom做对比（使用diff算法），。得到需要更新的地方之后，更新内容</li></ol><p>这样的话，就能大量减少真实dom的操作,提高性能</p><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>模块化就是将系统功能分离成独立的功能部分的方法，一般指的是单个的某一种东西，例如js、css</p><p>而组件化针对的是页面中的整个完整的功能模块划分，组件是一个html、css、js、image等外链资源，这些部分组成的一个聚合体</p><p>优点：代码复用，便于维护</p><p>划分组件的原则：复用率高的，独立性强的</p><p>组件应该拥有的特性：可组合，可重用，可测试，可维护</p><h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><p>在vue中，我们通过Vue.extend来创建Vue的子类，这个东西其实就是组件</p><p>也就是说Vue实例和组件的实例有差别但是差别不带，因为毕竟一个是父类一个是子类</p><p>一般的应用，会拥有一个根实例，在根实例里面都是一个一个的组件</p><p>因为组件是要嵌入到实例或者父组件里的，也就是说，组件可以互相嵌套，而且，所有的组件最外层必须有一个根实例，所以组件分为：全局组件和局部组件</p><p>全局组件在任意的实例、父级组件中都能使用，局部组件只能在创建自己的父级组件或者实例中使用</p><p>组件通过不同的注册方法成为全局、局部组件</p><p>创建组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.extend(options)</span><br></pre></td></tr></table></figure></p><p>全局注册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var App = Vue.extend(&#123;</span><br><span class="line">    template:&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(&apos;my-app&apos;,App)</span><br></pre></td></tr></table></figure></p><p>简便写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建组件构造器和注册组件合并一起  </span><br><span class="line"> Vue.component(&apos;hello&apos;,&#123;//Vue会自动的将此对象给Vue.extend</span><br><span class="line">     template:&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><p>组件通过template来确定自己的模板,template里的模板必须有根节点，标签必须闭合</p><p>组件的属性挂载通过：data方法来返回一个对象作为组件的属性，这样做的目的是为了每一个组件实例都拥有独立的data属性</p><p>局部注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &apos;my-app&apos;:App</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;hello&apos;:&#123;</span><br><span class="line">        template:&quot;&lt;h1&gt;asdasdasdasdasdas&lt;/h1&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例或者组件中注册另一个组件，这个时候，被注册的组件只能在注册它的实例或组件的模板中使用，一个组件可以被多个组件或实例注册</p><h6 id="注意浏览器规则"><a href="#注意浏览器规则" class="headerlink" title="注意浏览器规则"></a>注意浏览器规则</h6><p>因为vue在解析模板的时候会根据某些html的规则，例如，在table里只能放tr,td,th..，如果放入组件不会解析 这个时候我们可以放入tr使用is方式来标识这个tr其实是组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;tr is=&quot;hello&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h6 id="template"><a href="#template" class="headerlink" title="template"></a>template</h6><p>我们可以在html的某个地方通过template标签来定义组件的模板，在组件的template属性中通过选择器指定对应的template标签内容就可以了,注意，需要给template标签加id来指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;my-hello&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;hahahah&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//组件中</span><br><span class="line">template:&quot;#my-hello&quot;</span><br></pre></td></tr></table></figure></p><h6 id="is切换"><a href="#is切换" class="headerlink" title="is切换"></a>is切换</h6><p>在实例、组件的模板中的某一个标签上，可以通过is属性来指定为另一个目标的组件，这个时候我们一般会使用component标签来占位、设置is属性来指定目标组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line">//组件中</span><br><span class="line">data:&#123;</span><br><span class="line">    type:&apos;aaa&apos;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;aaa&apos;:&#123;template:&quot;&lt;h1&gt;AAAAAAAAAAAAA&lt;/h1&gt;&quot;&#125;,</span><br><span class="line">    &apos;bbb&apos;:&#123;template:&quot;&lt;h1&gt;BBBBBBBBBBBBB&lt;/h1&gt;&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h6><p>应用中划分的组件可能会很多，为了更好的实现代码复用，所以必然会存在组件的嵌套关系</p><p>组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;虚拟dom以及组件化&quot;&gt;&lt;a href=&quot;#虚拟dom以及组件化&quot; class=&quot;headerlink&quot; title=&quot;虚拟dom以及组件化&quot;&gt;&lt;/a&gt;虚拟dom以及组件化&lt;/h2&gt;&lt;h5 id=&quot;虚拟dom&quot;&gt;&lt;a href=&quot;#虚拟dom&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-6</title>
    <link href="https://heima0.github.io/2017/08/09/vue-6/"/>
    <id>https://heima0.github.io/2017/08/09/vue-6/</id>
    <published>2017-08-09T13:06:56.000Z</published>
    <updated>2022-11-12T14:02:35.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><ul><li>这个方式 还未深入了解</li></ul><ul><li><p>在Vue中，我们可以通过定义多个mixin来实现代码抽离复用，便于维护，提升页面的逻辑性</p><p>要注意的是：data属性不要使用mixin，因为从逻辑上来说，每一个实例、组件的数据都应该是独立的</p><p>一个mixin其实就是一个纯粹的对象，上面挂载着抽离出来的配置，在某一个实例中，通过mixins选项（数组）导入后，此实例就拥有导入的mixin的配置</p><p>且导入的配置不会覆盖原有的，而是合并到一起</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mixin&quot;&gt;&lt;a href=&quot;#mixin&quot; class=&quot;headerlink&quot; title=&quot;mixin&quot;&gt;&lt;/a&gt;mixin&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这个方式 还未深入了解&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在Vue中，我们可以通过定义多个m
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-5</title>
    <link href="https://heima0.github.io/2017/07/23/vue-5/"/>
    <id>https://heima0.github.io/2017/07/23/vue-5/</id>
    <published>2017-07-23T09:29:45.000Z</published>
    <updated>2022-11-12T14:02:35.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过滤器-条件渲染"><a href="#过滤器-条件渲染" class="headerlink" title="过滤器 条件渲染"></a>过滤器 条件渲染</h2><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>vue中可以设置filter(过滤器)来实现数据格式化，双花括号插值和 v-bind 表达式中使用</p><p>vue1.0的有默认的过滤器，但是在2.0的时候全部给去掉了</p><p>所以在vue中如果想要使用过滤器就需要自定义</p><p>自定义的方法有两种：全局定义和局部定义，全局定义的过滤器在任意的实例、组件中都可以使用，局部定义就是在实例、组件中定义，只能在这个实例或组件中使用</p><ol><li><p>全局定义</p><p> Vue.filter(name,handler)</p><p> name是过滤器的名字，handler是数据格式化处理函数，接收的第一个参数就是要处理的数据，返回什么数据，格式化的结果就是什么</p><p> 在模板中通过 | (管道符) 来使用,在过滤器名字后面加（）来传参，参数会在handler函数中第二个及后面的形参来接收</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;msg | firstUpper(3,2)&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">Vue.filter(&apos;firstUpper&apos;,function (value,num=1,num2) &#123;</span><br><span class="line">    console.log(num2)</span><br><span class="line">    return value.substr(0,num).toUpperCase()+value.substr(num).toLowerCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>局部定义</p><p> 在实例、组件的配置项中设置 filters，键名为过滤器名，值为handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">    firstUpper:function (value,num=1,num2) &#123;</span><br><span class="line">    console.log(num2)</span><br><span class="line">    return value.substr(0,num).toUpperCase()+value.substr(num).toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意：</p><pre><code>过滤器只能在mustache插值、v-bind里使用，其他的指令等地方都不能用</code></pre><h5 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h5><p>在Vue中可以使用v-if来控制模板里元素的显示和隐藏，值为true就显示，为false就隐藏</p><p>v-if控制的是是否渲染这个节点</p><p>当我们需要控制一组元素显示隐藏的时候，可以用template标签将其包裹，将指令设置在template上，等等vm渲染这一组元素的时候，不会渲染template</p><p>当有else分支逻辑的时候，可以给该元素加上v-else指令来控制，v-else会根据上面的那个v-if来控制，效果与v-if相反，注意，一定要紧挨着</p><p>还有v-else-if指令可以实现多分支逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;mode&quot;&gt;  </span><br><span class="line">  &lt;template  v-if=&quot;mode==&apos;A&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;1.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第一个P标签&lt;/p&gt;  </span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else-if=&quot;mode==&apos;B&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;2.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第二个P标签&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else-if=&quot;mode==&apos;C&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;3.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第三个P标签&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;p&gt;不好意思，输入有误&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br></pre></td></tr></table></figure><p>需要注意的另一个地方是：Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这样确实能使Vue变得更快，性能更高，但是有的时候我们需要让实例去更新dom而不是复用，就需要给dom加上不同的key属性，因为vue在判断到底渲染什么的时候，包括哪些dom可以复用，都会参考key值，如果dom表现基本一致，符合复用的条件，但是key值不同，依然不会复用</p><p>Vue还提供了v-show指令，用法和v-if基本一样，控制的是元素的css中display属性，从而控制元素的显示和隐藏 ， 不能和v-else配合使用,且不能使用在template标签上，因为template不会渲染，再更改它的css属性也不会渲染，不会生效</p><h6 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h6><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过滤器-条件渲染&quot;&gt;&lt;a href=&quot;#过滤器-条件渲染&quot; class=&quot;headerlink&quot; title=&quot;过滤器 条件渲染&quot;&gt;&lt;/a&gt;过滤器 条件渲染&lt;/h2&gt;&lt;h5 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-4</title>
    <link href="https://heima0.github.io/2017/06/13/vue-4/"/>
    <id>https://heima0.github.io/2017/06/13/vue-4/</id>
    <published>2017-06-13T01:19:45.000Z</published>
    <updated>2022-11-12T14:02:35.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算属性、监听"><a href="#计算属性、监听" class="headerlink" title="计算属性、监听"></a>计算属性、监听</h2><h5 id="计算属性、监听-1"><a href="#计算属性、监听-1" class="headerlink" title="计算属性、监听"></a>计算属性、监听</h5><pre><code>有的时候我们需要在模板中使用数据a，这个时候就需要用到表达式，但是有的地方我们需要对a数据进行一些简单的处理后才能使用，那么我们就会在表达式中写一些js逻辑运算<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>这样我们的维护就会非常困难，也不便于阅读那め我们就可以在methods里设置一个方法，在模板的表达式中使用这个方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是这个时候，只要vm中有数据变化，这个变化的数据可能和我们关注的数据无关，但是vm都会重新渲染模板，这个时候表达式中的方法就会重新执行，大大的影响性能这个时候其实我们可以使用监听器里完成：在vm实例中设置watch属性，在里面通过键值对来设置一些监听，键名为数据名，值可以是一个函数，这个函数在数据改变之后才会执行，两个参数分别是性格前的值和更改后的值</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: function (val, oldVal) &#123;</span><br><span class="line">    console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>值还可以是一个方法名字，当数据改变的时候这个方法会执行当数据为object的时候，object的键值对改变不会被监听到（数组的push等方法可以）,这个时候需要设置深度监听：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c: &#123;</span><br><span class="line">    deep:true,</span><br><span class="line">    handler:function (val, oldVal) &#123;</span><br><span class="line">        console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><pre><code>监听的handler函数前面的这几种写法都是在数据变化的时候才会执行，初始化的时候不会执行，但是如果设置immediate为true就可以了</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num:&#123;</span><br><span class="line">    immediate:true,</span><br><span class="line">    handler:function(val)&#123;</span><br><span class="line">        this.nums = val*2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>我们在回到上面的问题，用监听器加上immediate属性就可以做到该效果，但是大家可以看到的是逻辑稍稍有点复杂watch还可以通过实例对象直接使用:vm.$watch，返回一个取消监听的函数，这个函数执行之后会取消监听我们一般都会用到一个叫计算属性的东西来解决：计算属性就是在实例配置项中通过computed来为vm设置一个新的数据，而这个新数据会拥有一个依赖（一条已经存在的数据），当依赖发送变化的时候，新数据也会发送变化与方法的方式相比，它性能更高，计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。与watch相比，写起来简单，逻辑性更清晰，watch一般多用于，根据数据的变化而执行某些动作，而至于这些动作是在干什么其实无所谓，而计算属性更有针对性，根据数据变化而更改另一个数据计算属性也拥有getter和setter，默认写的是getter，设置setter执行可以当此计算属性数据更改的时候去做其他的一些事情，相当于watch这个计算属性</code></pre><pre><code>xm:{    get:function(){//getter 当依赖改变后设置值的时候        return this.xing+&apos;丶&apos;+this.ming    },    set:function(val){//setter 当自身改变后执行        this.xing = val.split(&apos;丶&apos;)[0]        this.ming = val.split(&apos;丶&apos;)[1]    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算属性、监听&quot;&gt;&lt;a href=&quot;#计算属性、监听&quot; class=&quot;headerlink&quot; title=&quot;计算属性、监听&quot;&gt;&lt;/a&gt;计算属性、监听&lt;/h2&gt;&lt;h5 id=&quot;计算属性、监听-1&quot;&gt;&lt;a href=&quot;#计算属性、监听-1&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-3</title>
    <link href="https://heima0.github.io/2017/06/08/vue-3/"/>
    <id>https://heima0.github.io/2017/06/08/vue-3/</id>
    <published>2017-06-08T02:44:56.000Z</published>
    <updated>2022-11-12T14:02:35.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue-数据改变-重新渲染问题"><a href="#vue-数据改变-重新渲染问题" class="headerlink" title="vue 数据改变 重新渲染问题"></a>vue 数据改变 重新渲染问题</h2><ul><li><p>当无关数据进行改变时，Vue根元素内部还会渲染<br>解决办法：watch监听、计算属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">button @click=&quot;a++&quot; button</span><br><span class="line">&#123;&#123;a&#125;&#125;</span><br><span class="line">&#123;&#123;ab()&#125;&#125;</span><br><span class="line"></span><br><span class="line">input type=&quot;text&quot; v-model=&quot;message&quot; name=&quot;&quot;</span><br><span class="line">&#123;&#123;message&#125;&#125;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: null,</span><br><span class="line">        message: &apos;&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ab: function()&#123;</span><br><span class="line">          return this.a*2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      a: function(val,oldval)&#123;</span><br><span class="line">        console.log(&apos;watch&apos;);</span><br><span class="line">        this.b = val*2 + 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>当点击button a的值变化，会打印‘watch’,但是当无关数据message改变时，同样会触发ab();<br>这样肯定不是我们想要的，所以可以用watch监听 a的变化，在函数中进行一些操作，这样就不会影响了。<br>这样做有个小弊端，就是我们需要定义一个变量名‘b’来接受，如果要改变名字 需要改2处地方，当然这个因素基本可以忽略。</p></li><li><p>Vue给了我们最完美的方法，就是通过计算属性computed来进行操作</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue-数据改变-重新渲染问题&quot;&gt;&lt;a href=&quot;#vue-数据改变-重新渲染问题&quot; class=&quot;headerlink&quot; title=&quot;vue 数据改变 重新渲染问题&quot;&gt;&lt;/a&gt;vue 数据改变 重新渲染问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当无关数据进行改变
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-2</title>
    <link href="https://heima0.github.io/2017/06/05/vue-2/"/>
    <id>https://heima0.github.io/2017/06/05/vue-2/</id>
    <published>2017-06-05T05:12:14.000Z</published>
    <updated>2022-11-12T14:02:35.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue-指令、模板语法"><a href="#vue-指令、模板语法" class="headerlink" title="vue 指令、模板语法"></a>vue 指令、模板语法</h2><h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>这是一个指令，只要有v-的就是指令（directive 操作dom ）</p><p>在vue中可以通过v-for来循环数据的通知循环dom，语法是item in/of items，接收第二个参数是索引 (item,index) of items,还可以循环键值对，第一个参数是value，第二个是key，第三个依然是索引</p><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>在vue中还有v-on来为dom绑定事件，在v-on：后面加上要绑定的事件类型，值里可以执行一些简单javascript表达式：++ – = …</p><p>可以将一些方法设置在methods里，这样就可以在v-on:click的值里直接写方法名字可以，默认会在方法中传入事件对象，当写方法的时候加了()就可以传参，这个时候如果需要事件对象，那就主动传入$event</p><p>v-on绑定的事件可以是任意事件,v-on:可以缩写为@</p><p>为什么在 HTML 中监听事件?</p><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol><h5 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h5><p>在vue中，我们使用mustache插值 花括号 来将数据渲染在模板中</p><p>使用v-once指令可以控制只能插入一次值，当数据变化的时候，模板对应的视图不更新</p><p>使用v-html指令可以解析html格式的数据</p><p>在html标签属性里不能使用mustache插值，这个时候给元素添加动态属性的时候使用v-bind来绑定属性，可以缩写成:</p><p>在使用v-bind绑定class和内联样式的时候，vue做了一些优化，可以使用对象语法和数组的语法来控制</p><p>防止表达式闪烁：</p><ol><li><p>v-cloak</p><p> 给模板内的元素添加v-cloak属性后，元素在vue没有加载完的时候就有这个属性，当vue加载完成后这个属性就消失了，所以我们可以给这个属性设置css样式为隐藏</p></li></ol><ol start="2"><li><p>v-text/v-html</p><p> v-text会指定将模板内元素的textContent属性替换为指令值所代表的数据，也可以用于防止闪烁<br> v-html可以解析标签，更改元素的innerHTML，性能比v-text较差</p></li><li><p>v-pre</p><p> 跳过元素和其子元素的编译过程，可以用来显示mustache</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue-指令、模板语法&quot;&gt;&lt;a href=&quot;#vue-指令、模板语法&quot; class=&quot;headerlink&quot; title=&quot;vue 指令、模板语法&quot;&gt;&lt;/a&gt;vue 指令、模板语法&lt;/h2&gt;&lt;h5 id=&quot;v-for&quot;&gt;&lt;a href=&quot;#v-for&quot; class
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-1</title>
    <link href="https://heima0.github.io/2017/05/17/vue-1/"/>
    <id>https://heima0.github.io/2017/05/17/vue-1/</id>
    <published>2017-05-17T07:58:49.000Z</published>
    <updated>2022-11-12T14:02:35.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue的介绍、性能"><a href="#Vue的介绍、性能" class="headerlink" title="Vue的介绍、性能"></a>Vue的介绍、性能</h2><h3 id="与AngularJS的对比"><a href="#与AngularJS的对比" class="headerlink" title="与AngularJS的对比"></a>与AngularJS的对比</h3><p>Vue的很多api、特性都与angularJS相似，其实是因为Vue在开发的时候借鉴了很多AngularJS中的特点，而AngularJS中固有的缺点，在Vue中已经解决，也就是青出于蓝而胜于蓝，Vue的学习成本比AngularJS低很多，因为复杂性就低</p><p>AngularJS是强主张的，而Vue更灵活</p><p>Vue的数据流是单向的，数据流行更清晰</p><p>Angular里指令可以是操作dom的，也可以封装一段结构逻辑代码，例如：广告展示模块</p><p>Vue中的指令只是操作dom的，用组件来分离结构逻辑</p><p>AngularJS的性能比不上Vue</p><h3 id="Vue的使用"><a href="#Vue的使用" class="headerlink" title="Vue的使用"></a>Vue的使用</h3><p>Vue不支持IE8，因为使用了ES5的很多特性</p><p>可以直接通过script标签来引入vue.js，有开发版本和生产版本，开发版本一般我们在开发项目的时候引入，当最后开发完成上线的时候引入生产版本，开发版本没有压缩的，并且有很多提示，而生产版本全部删掉了</p><p>在Vue中提供了一个脚手架（命令行工具）可以帮我们快速的搭建基于webpack的开发环境…</p><h4 id="Vue的实例"><a href="#Vue的实例" class="headerlink" title="Vue的实例"></a>Vue的实例</h4><p>每一个应用都有一个根实例，在根实例里我们通过组件嵌套来实现大型的应用</p><p>也就是说组件不一定是必须的，但是实例是必须要有的</p><p>在实例化实例的时候我们可以传入一个；配置项，在配置项中设置很多属性方法可以实现复杂的功能</p><p>在配置中可以设置el的属性，el属性代表的是此实例的作用范围</p><p>在配置中同过设置data属性来为实例绑定数据</p><h3 id="mvc-mvvm"><a href="#mvc-mvvm" class="headerlink" title="mvc/mvvm"></a>mvc/mvvm</h3><p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">阮大神博客</a></p><p>mvc 分为三层，其实M层是数据模型层，它是真正的后端数据在前端js中的一个映射模型，他们的关系是：数据模型层和视图层有映射关系，model改变，view展示也会更改，当view产生用户操作或会反馈给controller，controller更改model，这个时候view又会进行新的数据渲染</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://image.beekka.com/blog/2015/bg2015020105.png" alt="MVC" title="">                </div>                <div class="image-caption">MVC</div>            </figure><p>这是纯纯的MVC的模式，但是很多框架都会有一些更改</p><p>前端mvc框架，如angularjs，backbone：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://image.beekka.com/blog/2015/bg2015020108.png" alt="前端MVC" title="">                </div>                <div class="image-caption">前端MVC</div>            </figure><p>会发现，用户可以直接操作controller（例如用户更改hash值，conrtoller直接监听hash值变化后执行逻辑代码，然后通知model更改）</p><p>控制器可以直接操作view，如果，让某一个标签获得进入页面获得焦点，不需要model来控制，所以一般会直接操作（angularJS，指令）</p><p>view可以直接操作model （数据双向绑定）</p><p>MVP:</p><p><a href="http://image.beekka.com/blog/2015/bg2015020109.png" target="_blank" rel="noopener">mvp</a></p><p>view和model不能直接通信，所有的交互都由presenter来做，其他部分的通信都是双向的</p><p>view较薄 ，presenter较为厚重</p><p>MVVM：</p><p><a href="http://image.beekka.com/blog/2015/bg2015020110.png" target="_blank" rel="noopener">mvvm</a></p><p>MVVM和MVP及其相似，只是view和viewmodel的通信是双向绑定，view的操作会自动的像viewmodel通过</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue的介绍、性能&quot;&gt;&lt;a href=&quot;#Vue的介绍、性能&quot; class=&quot;headerlink&quot; title=&quot;Vue的介绍、性能&quot;&gt;&lt;/a&gt;Vue的介绍、性能&lt;/h2&gt;&lt;h3 id=&quot;与AngularJS的对比&quot;&gt;&lt;a href=&quot;#与AngularJS的对
      
    
    </summary>
    
    
      <category term="vue" scheme="https://heima0.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>浅谈tap-highlight-color与::selection</title>
    <link href="https://heima0.github.io/2017/04/27/%E6%B5%85%E8%B0%88tap-highlight-color/"/>
    <id>https://heima0.github.io/2017/04/27/浅谈tap-highlight-color/</id>
    <published>2017-04-27T04:16:50.000Z</published>
    <updated>2022-11-12T14:02:35.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tap-highlight-color：&lt;color&gt;</span><br></pre></td></tr></table></figure>- 默认值：由user agent决定- 适用于：所有元素- 继承性：有- 动画性：是</code></pre><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><pre><code>- 设置或检索对象的轻按时高亮。- 当用户轻按一个链接或者JavaScript可点击元素时给元素覆盖一个高亮色- 如果想取消这个高亮，将值设置为全透明即可，比如transparent- 对应的脚本特性为textHighlightColor。</code></pre><h2 id="问题指向"><a href="#问题指向" class="headerlink" title="问题指向"></a>问题指向</h2><pre><code>- CSS3 修改和去除移动端点击事件出现的背景框- 设定元素在移动设备（如Adnroid、iOS）上被触发点击事件时，响应的背景框的颜色。- 例：在Adnroid版本的微信中，点击a标签时将会出现一个橙色的小框表示点击的响应。此时，如果对元素设置了tap-highlight-color值，例如:-webkit-tap-highlight-color: rgba(240,240,240,0.7);则可改变元素被点击时背景框的颜色。如果需要背景框不显示，则可以将rgba中的alpha值设为0即可，例如rgba(0,0,0,0)</code></pre><h2 id="selection-选择器问题"><a href="#selection-选择器问题" class="headerlink" title="::selection 选择器问题"></a>::selection 选择器问题</h2><pre><code>- 应用场景：通常我们选中文字时的背景色是黑色，文字颜色是白色。我们可以用以下样式去设置网页的选中内容的样式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::selection         &#123; background:#000; color:#fff; &#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection    &#123; background:#000; color:#fff; &#125;</span><br><span class="line"></span><br><span class="line">::-webkit-selection &#123; background:#000; color:#fff;&#125;</span><br></pre></td></tr></table></figure>- 官方参考文档---http://www.w3school.com.cn/cssref/selector_selection.asp</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法：&quot;&gt;&lt;a href=&quot;#语法：&quot; class=&quot;headerlink&quot; title=&quot;语法：&quot;&gt;&lt;/a&gt;语法：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
    
      <category term="css" scheme="https://heima0.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Es6+babel</title>
    <link href="https://heima0.github.io/2017/01/23/Es6-babel/"/>
    <id>https://heima0.github.io/2017/01/23/Es6-babel/</id>
    <published>2017-01-23T10:51:20.000Z</published>
    <updated>2022-11-12T14:02:35.945Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Ecmascript 6 + Babel</li><li>npm scripts</li><li>Express</li></ul><h2 id="Babel-Register"><a href="#Babel-Register" class="headerlink" title="Babel Register"></a>Babel Register</h2><p>第一：在项目根目录下创建一个 <code>.babelrc</code> 文件，写入以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二：安装对应的转码规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES2015转码规则</span></span><br><span class="line">$ npm install --save-dev babel-preset-es2015</span><br><span class="line"></span><br><span class="line"><span class="comment"># react转码规则</span></span><br><span class="line">$ npm install --save-dev babel-preset-react</span><br><span class="line"></span><br><span class="line"><span class="comment"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</span></span><br><span class="line">$ npm install --save-dev babel-preset-stage-0</span><br><span class="line">$ npm install --save-dev babel-preset-stage-1</span><br><span class="line">$ npm install --save-dev babel-preset-stage-2</span><br><span class="line">$ npm install --save-dev babel-preset-stage-3</span><br></pre></td></tr></table></figure><p>第三：将 <code>.babelrc</code> 文件中修改为以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"es2015"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步（从第四步开始，前三部必不可少）：</p><ul><li>babel-cli：命令行转码</li><li>babel-node：babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境</li><li>babel-register：实时转码，所以只适合在开发环境使用</li><li>babel-core：如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块</li></ul><p>babel-cli：</p><p>一种使用方式就是全局安装：<code>npm install -g babel-cli</code>（可以通过 <code>npm root -g</code> 查看全局包安装目录），<br>只要全局安装了 <code>babel-cli</code>，则会在命令行中多出一个命令：<code>babel</code>。</p><p>这里如果使用全局安装的 <code>babel-cli</code> 进行转码是没有问题的，但是问题是如果一旦项目给了别人，<br>别人不知道你使用了这个转码工具，所以解决方式就是将 <code>babel-cli</code> 安装到本地项目中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure><p>这种第三方命令行工具如果安装到本地项目，会在 <code>node_modules</code> 中生成一个目录：<code>.bin</code>，<br>然后第三方命令行工具会将对应的可执行文件放到该目录中。</p><p>这样的话，就可以直接在本地项目中使用该第三方命令行工具了。</p><p>对于如何使用，则可以通过配置 <code>package.json</code> 文件中的 <code>scripts</code> 字段来配置使用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"babel-demo"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"babel demo1.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-cli"</span>: <span class="string">"^6.22.2"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-es2015"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-react"</span>: <span class="string">"^6.22.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>babel-register（适合开发阶段，实时编码转换）:</p><p>第一：安装 babel-register</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-register</span><br></pre></td></tr></table></figure><p>第二：添加一个傀儡文件(main.js)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'你的核心功能代码入口文件模块'</span>)</span><br></pre></td></tr></table></figure><p>第三：使用 node 执行 <code>main.js</code>，而不是你的入口文件.</p><h3 id="–save-和-–save-dev"><a href="#–save-和-–save-dev" class="headerlink" title="–save 和 –save-dev"></a>–save 和 –save-dev</h3><p>通过 <code>--save</code> 参数安装的包，是将依赖项保存到 package.json 文件中的 dependencies 选项中。<br>通过 <code>--save-dev</code> 参数安装的包，是将依赖项保存到 package.json 文件中的 devDependencies 选项中。</p><p>无论是 <code>--save</code> 或者 <code>--save-dev</code> 安装的包，通过执行 <code>npm install</code> 都会将对应的依赖包安装进来。</p><p>但是，在开发阶段会有一些仅仅用来辅助开发的一些第三方包或是工具，然后最终上线运行（到了生产环境），<br>这些开发依赖项就不再需要了，就可以通过 <code>npm install --production</code> 命令仅仅安装 <code>dependencies</code> 中的<br>依赖项。</p><hr><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><h3 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h3><p>根据不同的请求路径分发到具体的请求处理函数</p><h3 id="处理静态资源"><a href="#处理静态资源" class="headerlink" title="处理静态资源"></a>处理静态资源</h3><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h3 id="Express-API"><a href="#Express-API" class="headerlink" title="Express API"></a>Express API</h3><ul><li>express()</li><li>Application</li><li>Request</li><li>Response</li><li>Router</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Ecmascript 6 + Babel&lt;/li&gt;
&lt;li&gt;npm scripts&lt;/li&gt;
&lt;li&gt;Express&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Babel-Register&quot;&gt;&lt;a href=&quot;#Babel-Register&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Ecmascript6-阮一峰</title>
    <link href="https://heima0.github.io/2017/01/18/Ecmascript6-%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
    <id>https://heima0.github.io/2017/01/18/Ecmascript6-阮一峰/</id>
    <published>2017-01-18T00:44:25.000Z</published>
    <updated>2022-11-12T14:02:35.944Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Ecmascript 6-阮一峰</li></ul><h2 id="Ecmascript-6"><a href="#Ecmascript-6" class="headerlink" title="Ecmascript 6"></a>Ecmascript 6</h2><ul><li>ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。</li><li>Ecmascript 是 JavaScript 语言的标注规范</li><li>JavaScript 是 Ecmascript 规范的具体实现<ul><li>具体实现取决于各大浏览器厂商的支持进度</li></ul></li><li>Ecmascript 6 也被称作 Ecmascript 2015</li><li>各大浏览器厂商对于最新的 Ecmascript 6 标准支持可以参照：<ul><li><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a></li></ul></li><li>对于不支持 ES6 的环境，可以使用一些编译转码工具做转换处理再使用<ul><li>例如 babel</li></ul></li></ul><h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><ul><li>let 类似于 var，也是用来定义变量的</li><li>通过 let 定义的变量是块级作用域，只在当前代码块有效</li><li>const 也类似于 var，用来定义常量</li><li>通过 const 定义的常量，定义的时候必须初始化</li><li>const 定义的变量一旦定义，不能修改</li><li>let 和 const 都没有作用域提升</li><li>let 和 const 在一个块级作用域中都不能重复定义</li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>数组解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="number">123</span> <span class="number">456</span> <span class="number">789</span></span><br></pre></td></tr></table></figure><p>对象解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name, age) Jack <span class="number">18</span></span><br></pre></td></tr></table></figure><p>函数参数解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">p1, &#123; p2 = <span class="string">'aa'</span>, p3 = <span class="string">'bb'</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p1, p2, p3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="string">'p1'</span>, &#123; <span class="attr">p2</span>: <span class="string">'p2'</span> &#125;) p1 p2 bb</span><br></pre></td></tr></table></figure><p>字符串解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d, e) h e l l o</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>模板字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 将一个伪数组转为一个真正的数</span><br><span class="line">Array.from()</span><br><span class="line"></span><br><span class="line">// Array.of方法用于将一组值，转换为数组</span><br><span class="line">Array.of()</span><br><span class="line"></span><br><span class="line">// 查找某个元素</span><br><span class="line">Array.find()</span><br><span class="line"></span><br><span class="line">// 查找某个元素的索引下标</span><br><span class="line">Array.findIndex()</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Ecmascript 6-阮一峰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Ecmascript-6&quot;&gt;&lt;a href=&quot;#Ecmascript-6&quot; class=&quot;headerlink&quot; title=&quot;Ecmascript 6&quot;&gt;&lt;/a&gt;Ecmascript 6&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Git-bash、Git基本命令</title>
    <link href="https://heima0.github.io/2016/08/13/Git-bash%E3%80%81Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://heima0.github.io/2016/08/13/Git-bash、Git基本命令/</id>
    <published>2016-08-13T10:50:04.000Z</published>
    <updated>2022-11-12T14:02:35.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-bash、Git基本命令"><a href="#Git-bash、Git基本命令" class="headerlink" title="Git-bash、Git基本命令"></a>Git-bash、Git基本命令</h1><hr><h2 id="Git-bash-文件操作相关命令"><a href="#Git-bash-文件操作相关命令" class="headerlink" title="Git-bash 文件操作相关命令"></a>Git-bash 文件操作相关命令</h2><ul><li>touch：创建文件</li><li>cat：查看文件</li><li>less：查看大文本文件</li><li>vi：visual interface<ul><li>Esc 退出到命令模式</li><li>i 进入插入模式</li><li>:q 退出vi</li><li>:w 保存编辑</li><li>:wq 保存并退出</li><li>:q! 强制退出不保存修改</li><li>vi 的所有操作基本全部是命令，这里掌握基本使用基于可以了</li><li>有时候使用 git commit 进行提交的时候希望能多写几行提交日志，这时候可以省略 -m 参数进入 vi 编辑模式</li></ul></li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li>git init</li><li>git status</li><li>git add</li><li>git commit</li><li>git log</li></ul><h3 id="添加-删除文件"><a href="#添加-删除文件" class="headerlink" title="添加/删除文件"></a>添加/删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h3 id="回退撤销"><a href="#回退撤销" class="headerlink" title="回退撤销"></a>回退撤销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>默认在 git 的仓库中，会有个分支的原点：master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于当前分支新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于当前分支新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支，交替和上一个分支进行切换</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br></pre></td></tr></table></figure><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载一个远程仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">git push [remote] --force</span><br></pre></td></tr></table></figure><h3 id="Git-工作流程：分支策略"><a href="#Git-工作流程：分支策略" class="headerlink" title="Git 工作流程：分支策略"></a>Git 工作流程：分支策略</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">Git 工作流程</a></li></ul><h4 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h4><h4 id="Github-Collabrators"><a href="#Github-Collabrators" class="headerlink" title="Github Collabrators"></a>Github Collabrators</h4><p>这种方式公司团队项目使用居多</p><h4 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h4><p>这种方式开源项目使用居多</p><ul><li>fork</li><li>clone 到你的本地</li><li>在clone下来的项目中拉出一个新的分支<ul><li>修改的时候最好是基于 master 拉出一个修改的分支，例如这个分支是用来添加某个功能的</li></ul></li><li>在新分支上开发或者修改完成之后，提交到本地仓库，然后 push 推到自己的账户中 fork 过来的仓库</li><li>最后，在 Github 上你 fork 过来的仓库界面中找到 New Pull Request 发起提交请求</li><li>对方就会在仓库的 Pull Requests 中收到你发起的提交请求<ul><li>然后双方就可以使用社会化交流方式进行沟通协作</li><li>例如 Code Review 代码审查</li></ul></li><li>最后对方审查通过没有问题之后，选择 Merge Request</li><li>到此，一个完整的 Github 工作流结束</li><li>这种方式开源项目更多一些（大家都不认识）</li></ul><h4 id="Gitlab-flow"><a href="#Gitlab-flow" class="headerlink" title="Gitlab flow"></a>Gitlab flow</h4><h3 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h3><p>对于第三方代码仓库托管服务有很多，其中 Github 最火，但是如果想要托管私有项目收费比较高，<br>而且在国内受限于网络环境影响，鲜少有公司使用。</p><p>也有的公司，例如京东、淘宝这种级别的公司，也不太常用别的第三方的托管服务。</p><p>Gitlab 是一个开源的类似于 Github 的一个系统，开源免费部署到自己的公司内容。</p><hr><h2 id="与-Github-进行多人协作"><a href="#与-Github-进行多人协作" class="headerlink" title="与 Github 进行多人协作"></a>与 Github 进行多人协作</h2><h3 id="Collaborators"><a href="#Collaborators" class="headerlink" title="Collaborators"></a>Collaborators</h3><h3 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-bash、Git基本命令&quot;&gt;&lt;a href=&quot;#Git-bash、Git基本命令&quot; class=&quot;headerlink&quot; title=&quot;Git-bash、Git基本命令&quot;&gt;&lt;/a&gt;Git-bash、Git基本命令&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Git-
      
    
    </summary>
    
    
      <category term="git" scheme="https://heima0.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>版本控制（SVN、Git）和Github整理</title>
    <link href="https://heima0.github.io/2016/08/11/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%EF%BC%88SVN%E3%80%81Git%EF%BC%89%E5%92%8CGithub%E6%95%B4%E7%90%86/"/>
    <id>https://heima0.github.io/2016/08/11/版本控制（SVN、Git）和Github整理/</id>
    <published>2016-08-11T04:45:03.000Z</published>
    <updated>2022-11-12T14:02:35.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本控制（SVN、Git）和Github整理"><a href="#版本控制（SVN、Git）和Github整理" class="headerlink" title="版本控制（SVN、Git）和Github整理"></a>版本控制（SVN、Git）和Github整理</h1><hr><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>版本控制</li><li>SVN</li><li>Git</li><li>Github</li></ul><hr><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="问题1：历史记录"><a href="#问题1：历史记录" class="headerlink" title="问题1：历史记录"></a>问题1：历史记录</h3><h3 id="问题2：多人协作"><a href="#问题2：多人协作" class="headerlink" title="问题2：多人协作"></a>问题2：多人协作</h3><h3 id="解决问题：软件"><a href="#解决问题：软件" class="headerlink" title="解决问题：软件"></a>解决问题：软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">版本  用户  说明                   日期</span><br><span class="line">    张三  删除了软件服务条款5    7/12 10:38</span><br><span class="line">    张三  增加了License人数限制  7/12 18:09</span><br><span class="line">    李四  财务部门调整了合同金额 7/13 9:51</span><br><span class="line">    张三  延长了免费升级周期     7/14 15:17</span><br></pre></td></tr></table></figure><h3 id="什么是版本控制？"><a href="#什么是版本控制？" class="headerlink" title="什么是版本控制？"></a>什么是版本控制？</h3><p>版本管理就是管理更新的历史记录，<br>它给我们提供了一些在软件开发过程中必不可少的功能，例如：</p><ul><li>记录一款软件添加或更改源代码的过程</li><li>回滚到特定阶段，恢复误删除的文件</li><li>合并多人协作的文件等</li><li>多人协同，文件传输</li></ul><h3 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h3><ul><li>集中式<ul><li>SVN</li></ul></li><li>分布式<ul><li>Git</li></ul></li></ul><hr><h2 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h2><p>SVN 全称 Apache Subversion，是一个开放源代码的集中式版本管理系统。<br>在 2000 年由 CollabNet 开发，现已发展成为 Apache 软件基金会的一个开源项目。</p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><h3 id="SVN-交互协作流程"><a href="#SVN-交互协作流程" class="headerlink" title="SVN 交互协作流程"></a>SVN 交互协作流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./img/svn交互流程.png" alt="集中式版本管理" title="">                </div>                <div class="image-caption">集中式版本管理</div>            </figure><h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p>早期的版本管理就是以 <code>Apache Subversion</code> 为代表的集中式版本管理，<br>集中式版本管理将所有的数据集中存放在服务器中，这是有便于统一管理的优点。<br>但是一旦开发者所处的环境不能连接服务器，就无法获取最新源代码，开发也就无法进行。<br>服务器宕机时也是同样的道理，而且万一服务器故障导致数据丢失，<br>恐怕开发者就再也见不到最新的源代码了。</p><p>简而言之：</p><ul><li>中央服务器好比是一个图书馆</li><li>你要改一本书，必须先从图书馆借出来（checkout）</li><li>然后回到家自己改，改完了，再放到图书馆（commit）</li></ul><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul><li>源代码库（repository）：源代码统一存放的地方</li><li>检出（checkout）：当你手上没有源代码的时候，就需要从 responsive checkout 一份</li><li>提交（commit）：当你已经修改了代码，就需要 commit 到 repository</li><li>更新（update）：当你已经 checkout 了一份源代码，Update 一下就可以和 repository 上的源代码同步，你手上的代码就会有最新的变更</li></ul><h3 id="使用-VisualSVN-搭建-SVN-服务器"><a href="#使用-VisualSVN-搭建-SVN-服务器" class="headerlink" title="使用 VisualSVN 搭建 SVN 服务器"></a>使用 VisualSVN 搭建 SVN 服务器</h3><p>SVN 服务器：运行 Subversion 服务的计算机。</p><p>为了方便，我们这里使用比较流行的图形化工具 <a href="https://www.visualsvn.com/" target="_blank" rel="noopener">VisualSVN</a><br>来搭建我们的 SVN 服务。</p><p>安装完毕之后，基本使用流程如下：</p><ul><li>创建用户</li><li>创建版本仓库</li><li>设定用户权限</li></ul><h3 id="使用-TortoiseSVN-作为-SVN-客户端"><a href="#使用-TortoiseSVN-作为-SVN-客户端" class="headerlink" title="使用 TortoiseSVN 作为 SVN 客户端"></a>使用 TortoiseSVN 作为 SVN 客户端</h3><p>SVN 客户端：用户通过SVN客户端同SVN服务器交互</p><p>这里我们使用最流行的 <a href="https://tortoisesvn.net/" target="_blank" rel="noopener">TortoiseSVN</a></p><p><a href="https://DESKTOP-40UMEJI:8443/svn/jd" target="_blank" rel="noopener">https://DESKTOP-40UMEJI:8443/svn/jd</a></p><p><a href="https://192.168.133.25:8443/svn/jd" target="_blank" rel="noopener">https://192.168.133.25:8443/svn/jd</a></p><h3 id="TortoiseSVN-客户端基本操作流程"><a href="#TortoiseSVN-客户端基本操作流程" class="headerlink" title="TortoiseSVN 客户端基本操作流程"></a>TortoiseSVN 客户端基本操作流程</h3><ul><li>检出项目：<code>checkout</code><ul><li>在没有源代码的前提下，需要通过 tortoise-svn 客户端下载</li></ul></li><li>提交修改：<code>commit</code><ul><li>帮你记录当前开发的软件的状态</li></ul></li><li>更新文件或目录：<code>update</code>（更新）<ul><li>别的开发人员在已有源代码的前提下可以通过 update 更新服务器上最新的版本</li></ul></li><li>查看版本日志：<code>log</code>（日志）</li></ul><h3 id="关于冲突"><a href="#关于冲突" class="headerlink" title="关于冲突"></a>关于冲突</h3><p>假设 A、B 两个用户都在版本号为 100 的时候，更新了 kingtuns.txt 这个文件，<br>A 用户在修改完成之后提交 kingtuns.txt 到服务器， 这个时候提交成功，<br>这个时候 kingtuns.txt 文件的版本号已经变成 101 了。<br>同时B用户在版本号为 100 的 kingtuns.txt 文件上作修改， 修改完成之后提交到服务器时，<br>由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。</p><p>良好的使用习惯就是，提交之前，先更新。</p><p>为了避免冲突，别人的文件你最好不要动，<br>万一你要修改公共的文件或者是别人的文件，<br>跟别人最好口头沟通好，就是你改动的时候，<br>别人最好不要去改动，这样才能最大程度上避免冲突的问题。</p><p>多人协作时，同个目录或同个文件需要不同成员共同开发，<br>这个时候 commit 和 update 就可能出现冲突。</p><ul><li>两个程序员只要不是修改了同一行程序，SVN 可以通过 update 自动合并修改</li><li>但是如果两个程序员修改了同一行程序， SVN 会提示文件 conflict，需要手动确定</li></ul><p>如何解决？</p><p>第一种解决方法：手动合并冲突的内容</p><p>第二种解决方法：每次修改某个文件的时候对文件上锁，这样你在修改的过程中别人就无法更新这个文件</p><p>建议：</p><ul><li>一个文件最好同一时间只被一个人修改提交</li><li>多跟团队成员沟通</li><li>不要随便去修改别人的文件</li></ul><h3 id="版本管理使用建议"><a href="#版本管理使用建议" class="headerlink" title="版本管理使用建议"></a>版本管理使用建议</h3><ul><li>不要频繁的提交版本<ul><li>一般有比较成熟的功能模块的时候，再去提交</li><li>修复了功能性 bug 的时候再去提交</li><li>提交的代码最好无 bug</li></ul></li><li>每次 commit 之前都要 update<ul><li>因为你在编辑这个文件的时候，可能比人已经编辑并提交了某个版本</li><li>所以先 update，目的是为了检查一下服务器上有没有最新版，如果有，直接更新<ul><li>更新的过程中如果遇到冲突，不要慌，去手动解决</li></ul></li></ul></li><li>每次 commit 的时候都务必要写提交日志<ul><li>这个提交日志就好比你保存副本的时候加的一个标记</li><li>目的是为了日后做版本的回退查找以及查看记录更新状态</li></ul></li></ul><h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><ul><li>版本控制管理系统</li><li>源代码仓库 repository</li><li>检出代码 checkout</li><li>更新最新源代码 update</li><li>提交修改 commit</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><a href="http://holy2010.blog.51cto.com/1086044/645944" target="_blank" rel="noopener">清除svn保存的username用户名和paasword密码(windows和linux)</a></li><li><a href="http://www.runoob.com/svn/svn-tutorial.html" target="_blank" rel="noopener">菜鸟教程 - SVN 教程</a></li></ul><hr><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/Git" target="_blank" rel="noopener">维基百科 - Git</a></p></blockquote><h3 id="学习资源介绍"><a href="#学习资源介绍" class="headerlink" title="学习资源介绍"></a>学习资源介绍</h3><ul><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">Git教程 - 廖雪峰</a></li><li><a href="http://git.oschina.net/progit/" target="_blank" rel="noopener">Pro Git</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git - 简明指南</a></li><li><a href="http://backlogtool.com/git-guide/cn/" target="_blank" rel="noopener">猴子都能懂的GIT入门</a></li></ul><h3 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h3><ul><li>是什么<ul><li>Git 也是一个版本控制管理软件</li></ul></li><li>有什么用，可以解决什么问题<ul><li>保存历史记录</li><li>多人协作</li></ul></li><li>有了 SVN，为啥要学 Git<ul><li>Git 火</li><li>Git 相对于 SVN 来说，更强大，用户也非常多</li></ul></li><li>怎么用</li><li>Git 的诞生<ul><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000</a></li></ul></li></ul><h3 id="Git-使用交互流程"><a href="#Git-使用交互流程" class="headerlink" title="Git 使用交互流程"></a>Git 使用交互流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/git交互模型.png" alt="git交互模型" title="">                </div>                <div class="image-caption">git交互模型</div>            </figure><h3 id="安装和配置-Git-环境"><a href="#安装和配置-Git-环境" class="headerlink" title="安装和配置 Git 环境"></a>安装和配置 Git 环境</h3><ul><li>下载地址：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></li></ul><h4 id="git-bash-常用命令"><a href="#git-bash-常用命令" class="headerlink" title="git-bash 常用命令"></a>git-bash 常用命令</h4><ul><li>pwd</li><li>ls<ul><li>ls -a</li></ul></li><li>cd</li><li>mkdir</li><li>clear</li><li>rmdir<ul><li>只能删除空目录</li></ul></li><li>rm<ul><li>rm 文件名</li><li>rm -rf 目录名<ul><li>注：很强大，可以删除非空目录，以及一些比较顽固的文件或者目录</li></ul></li></ul></li></ul><h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置用户名</span></span><br><span class="line">git config --global user.name <span class="string">"你的名字"</span></span><br><span class="line"><span class="comment"># 配置用户邮箱</span></span><br><span class="line">git config --global user.email <span class="string">"你的常用邮箱"</span></span><br><span class="line"><span class="comment"># 设置 gitk 图形查看工具中文显示默认编码（防止乱码）</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line"><span class="comment"># 查看配置列表项</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><code>git init</code><ul><li>初始化一个 Git 仓库</li></ul></li><li><code>git status</code><ul><li>查看当前工作区、暂存区、本地仓库的状态</li></ul></li><li><code>git add</code></li><li><code>git commit</code><ul><li>示例：<code>git commit -m &quot;日志说明&quot; --author=&quot;操作者姓名 &lt;邮箱&gt;&quot;</code></li><li>执行 <code>git commit</code> 的时候，Git 会要求具有用户名和邮箱的参数选项</li><li>可以通过 <code>git config</code> 命令配置一下用户名和邮箱</li></ul></li><li><code>git log</code></li><li><code>gitk</code></li></ul><p>总结：操作 Git 的基本工作流程就是先修改文件，然后执行 <code>git add</code> 命令。<br><code>git add</code> 命令会把文件加入到暂存区，接着就可以执行 <code>git commit</code> 命令，将文件存入文档库，<br>从而形成一次历史记录。</p><ul><li>问题1：关于 Git-bash 中文问题</li><li><a href="https://github.com/msysgit/msysgit/wiki/Git-for-Windows-Unicode-Support" target="_blank" rel="noopener">Git for Windows Unicode Support</a></li><li>问题2：执行 commit 的时候一大堆的信息</li><li>问题3：配置 user.name 和 user.email 问题</li></ul><h3 id="工作区、暂存区、本地仓库"><a href="#工作区、暂存区、本地仓库" class="headerlink" title="工作区、暂存区、本地仓库"></a>工作区、暂存区、本地仓库</h3><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git rm --cached &lt;file&gt;</span></span><br><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><ul><li>remote</li><li>push</li><li>pull</li></ul><h3 id="在线仓库托管服务"><a href="#在线仓库托管服务" class="headerlink" title="在线仓库托管服务"></a>在线仓库托管服务</h3><blockquote><p>一个不知道 github、stackoverflow 的程序员想想都是可悲的</p></blockquote><ul><li>github</li><li>码云</li><li>coding</li></ul><hr><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><blockquote><p>Github 就是程序员的新浪微博<br>它可以让你使用社交化的方式进行编程协作、</p><pre><code>- 点赞- 评论- 转发- etc.</code></pre><p>主要作用：可以免费在线托管你的仓库<br>可以实现多人协作<br>提供了一个可视化界面（Web Page）让你能直观清晰的了解你的项目源代码</p></blockquote><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>注册</li><li>登陆</li><li>创建远程仓库</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;版本控制（SVN、Git）和Github整理&quot;&gt;&lt;a href=&quot;#版本控制（SVN、Git）和Github整理&quot; class=&quot;headerlink&quot; title=&quot;版本控制（SVN、Git）和Github整理&quot;&gt;&lt;/a&gt;版本控制（SVN、Git）和Github
      
    
    </summary>
    
    
      <category term="git" scheme="https://heima0.github.io/tags/git/"/>
    
      <category term="svn" scheme="https://heima0.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>Express-MongoDB-package.json</title>
    <link href="https://heima0.github.io/2016/06/01/Express-MongoDB-package-json/"/>
    <id>https://heima0.github.io/2016/06/01/Express-MongoDB-package-json/</id>
    <published>2016-06-01T04:38:01.000Z</published>
    <updated>2022-11-12T14:02:35.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express、-MongoDB、-package-json的介绍"><a href="#Express、-MongoDB、-package-json的介绍" class="headerlink" title="Express、 MongoDB、 package.json的介绍"></a>Express、 MongoDB、 package.json的介绍</h1><hr><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>Express</li><li>MongoDB</li></ul><h2 id="package-json-文件"><a href="#package-json-文件" class="headerlink" title="package.json 文件"></a>package.json 文件</h2><p>package.json 文件一般用来描述项目的一些基本信息，例如入口文件、依赖项、项目介绍、开发作者等数据。</p><p>目前已知的两个非常重要的属性：</p><ul><li>main<ul><li>main 和模块化中的第三方包加载规则有关系</li></ul></li><li>dependencies<ul><li>dependencies 和 npm 命令行工具有关系</li><li>当你安装包的时候，如果加上 <code>--save</code> 参数，则npm会自动把这个第三方包依赖信息写入到 <code>package.json</code> 文件中的 <code>dependencies</code> 字段中</li><li>当你执行 <code>npm install</code> 的时候，npm 会找到当前项目中的 <code>package.json</code> 文件中的 <code>dependencies</code> 依赖项，然后依次将所有的依赖下载下来</li></ul></li></ul><p>这个文件最好每一个项目都有，保存一些项目的基本信息。</p><p>这个文件可以通过 <code>npm init</code> 以向导的形式生成，也可以加上 <code>-y</code> 参数，一步生成。</p><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><blockquote><p>一个基于 Node 开发的一个快速 Web 开发框架<br>主要用来构建 Server</p></blockquote><ul><li><a href="http://expressjs.com/" target="_blank" rel="noopener">http://expressjs.com/</a></li><li><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a></li></ul><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 调用 express 方法，得到一个类似于 server 的实例</span></span><br><span class="line"><span class="comment">//    一般称作 app</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过 app 根据不同的请求方法及请求路径设定具体的处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户以 GET 请求 / 的时候，执行对应的回调处理函数</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户以 GET 请求 /login 的时候，执行对应的回调处理函数</span></span><br><span class="line">app.get(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'hello login'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动监听</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务器已启动，请访问：http://127.0.0.1:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="处理静态资源"><a href="#处理静态资源" class="headerlink" title="处理静态资源"></a>处理静态资源</h3><blockquote><p>参考文档：<a href="http://www.expressjs.com.cn/starter/static-files.html" target="_blank" rel="noopener">http://www.expressjs.com.cn/starter/static-files.html</a></p></blockquote><p>通过 Express 内置的 <code>express.static</code> 可以方便地托管静态文件，<br>例如图片、CSS、JavaScript 文件等。</p><p>配置规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'路径访问前缀'</span>, express.static(<span class="string">'资源目录路径'</span>))</span><br></pre></td></tr></table></figure><p>以下是一些配置示例：</p><ul><li>将目录 static 资源暴露出来，可以通过 <code>/static/*</code> 的形式进行访问<ul><li><code>app.use(&#39;/static/&#39;, express.static(&#39;static目录的绝对路径&#39;))</code></li><li><code>/static/css/a.css</code></li><li><code>/static/css/b.css</code></li><li><code>/static/img/ab2.jpg</code></li></ul></li><li>将目录 public 资源暴露出来，不需要任何前缀就可以访问<ul><li><code>app.use(express.static(&#39;public 目录的绝对路径&#39;))</code></li><li><code>/css/bb.css</code></li><li><code>/img/a.jpg</code></li></ul></li><li>将目录 demo 资源暴露出来，可以通过 <code>/aa/*</code> /aa前缀的形式进行访问<ul><li><code>app.use(&#39;/aa/&#39;, express.static(&#39;demo 目录的绝对路径&#39;))</code></li><li><code>/aa/css/a.css</code></li><li><code>/aa/**/*.*</code></li></ul></li><li>将目录 static 资源暴露出来，可以通过 <code>/static/*</code> 或者 <code>/aa/*</code> 的形式进行访问 <ul><li><code>app.use(&#39;/aa/&#39;, express.static(&#39;static 目录的绝对路径&#39;))</code></li><li><code>app.use(&#39;/static/&#39;, express.static(&#39;static 目录的绝对路径&#39;))</code></li><li>上面的形式就是把 static 目录中的资源提供了两种形式，既能以 <code>/static/</code> 为前缀进行访问也可以以 <code>/aa/</code> 的前缀进行访问</li></ul></li></ul><h3 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h3><h3 id="在-Express-配置使用-ejs-模板引擎"><a href="#在-Express-配置使用-ejs-模板引擎" class="headerlink" title="在 Express 配置使用 ejs 模板引擎"></a>在 Express 配置使用 ejs 模板引擎</h3><p>Express 这个框架很精简，默认是不支持模板引擎的，需要配合一些第三方的模板引擎来结合使用，<br>例如这里将 <code>ejs</code> 和 <code>express</code> 结合起来使用：</p><p>第一：安装 <code>ejs</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save ejs</span><br></pre></td></tr></table></figure><p>第二：在代码中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">'views'</span>, 模板文件存储路径) <span class="comment">// 注意，这里可以不配置，因为 Express 默认会去项目中的 `views` 目录进行查找</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>) <span class="comment">// 这里表示让 Express 中的 res.render 方法使用 ejs 模板引擎，这里的 ejs 就是你安装的那个模板引擎的包名</span></span><br></pre></td></tr></table></figure><p>只要经过了上面这种配置，然后 res 对象上就会自动多出一个方法：<code>res.render</code> ,使用方式和咱们之前<br>自己封装的一样：<code>res.render(&#39;视图名称&#39;, {要解析替换的对象数据})</code></p><p>注意：使用了 ejs 模板引擎，默认视图文件后缀名必须是 <code>.ejs</code>，否则 render 方法找不到。<br>如果想要修改，可以像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.set('view enginge', 'ejs')</span></span><br><span class="line"><span class="comment">// 将上面这句配置改为下面的形式，就修改了默认的 .ejs 后缀名</span></span><br><span class="line">app.engine(<span class="string">'.html'</span>, <span class="built_in">require</span>(<span class="string">'ejs'</span>).__express)</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'html'</span>)</span><br></pre></td></tr></table></figure><h3 id="在-Express-中配置使用-body-parser-插件解析处理表单-POST-请求体"><a href="#在-Express-中配置使用-body-parser-插件解析处理表单-POST-请求体" class="headerlink" title="在 Express 中配置使用 body-parser 插件解析处理表单 POST 请求体"></a>在 Express 中配置使用 <code>body-parser</code> 插件解析处理表单 POST 请求体</h3><p>第一步：安装 <code>body-parser</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save body-parser</span><br></pre></td></tr></table></figure><p>第二步，在代码中进行配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br></pre></td></tr></table></figure><p>只要经过上面的安装配置，则在任意的 post 处理函数中都可以直接通过 <code>req.body</code> 来获取表单 POST 请求体数据。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里可以直接通过 req.body 来获取表单 POST 请求体数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h3><blockquote><p>数据库：一个电子化的文件柜</p></blockquote><p>数据库就是为我们方便的管理数据的一个平台，例如对数据的存储、修改、查询等都非常的方便。</p><h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><p>数据库产品有很多，以下是一些常见的数据库产品：</p><ul><li>MySQL</li><li>Oracle</li><li>DB2</li><li>SqlServer</li><li>MongoDB</li><li>etc.</li></ul><p>数据库没有排名之分，各有各的应用场景，这里说的是 MongoDB 数据库。</p><h3 id="MongoDB-数据库"><a href="#MongoDB-数据库" class="headerlink" title="MongoDB 数据库"></a>MongoDB 数据库</h3><blockquote><p>为了更好的学习 MongoDB 数据库，可以参考菜鸟教程上的 MongoDB 数据库教程文档，<br>链接地址：<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-tutorial.html</a></p></blockquote><h3 id="MongoDB-数据库存储结构"><a href="#MongoDB-数据库存储结构" class="headerlink" title="MongoDB 数据库存储结构"></a>MongoDB 数据库存储结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="img/mongodb数据存储结构.png" alt="mongodb数据存储结构" title="">                </div>                <div class="image-caption">mongodb数据存储结构</div>            </figure><h3 id="安装与配置-MongoDB-数据库环境"><a href="#安装与配置-MongoDB-数据库环境" class="headerlink" title="安装与配置 MongoDB 数据库环境"></a>安装与配置 MongoDB 数据库环境</h3><h3 id="启动-MongoDB-服务实例"><a href="#启动-MongoDB-服务实例" class="headerlink" title="启动 MongoDB 服务实例"></a>启动 MongoDB 服务实例</h3><p>可以通过使用安装程序中的 <code>mongod</code> CLI应用程序来启动 MongoDB 服务。</p><p>直接在控制台输入：<code>mongod</code> 敲回车即可。</p><p>在启动的时候，可以通过 <code>--dbpath</code> 指定数据服务存储数据的目录，<br>如果不指定该目录，默认 <code>mongod</code> 会去 <code>c:/data/db</code> 作为自己的数据存储目录。</p><p>64 位版本启动 MongoDB 数据服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath C:\data\db</span><br></pre></td></tr></table></figure><p>32 位版本使用下面的命令启动数据服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1</span><br></pre></td></tr></table></figure><p>提示：如果不加 <code>--dbpath</code>, mongod 会自动使用 <code>C:\data\db</code> 目录作为自己的数据存储路径，<br>所以，如果你已经有了 <code>C:\data\db</code> 目录了，可以省略 <code>--dbpath</code>。</p><p>执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了，<br>千万不要关闭，否则无法连接，如果对数据库的操作结束，可以打开该控制台通过 <code>Ctrl + C</code> 关闭。</p><h3 id="连接-MongoDB-数据服务"><a href="#连接-MongoDB-数据服务" class="headerlink" title="连接 MongoDB 数据服务"></a>连接 MongoDB 数据服务</h3><p><strong>注意：在进行连接之前请确保你的服务实例是开启状态的（不要关闭刚才开启的数据服务实例）。</strong></p><p>打开一个新的控制台，在控制台输入以下命令用来连接本机的 MongoDB 服务实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p>mongo 命令默认去连接本机上的 MongoDB 服务实例：<code>127.0.0.1:27017</code>，可以通过下面的命令<br>指定连接的主机名和端口号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --host 127.0.0.1 --port 27017</span><br></pre></td></tr></table></figure><p>如果看到类似于如下的字样说明连接成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MongoDB shell version v3.4.0</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017</span><br><span class="line">MongoDB server version: 3.4.0</span><br><span class="line">Server has startup warnings:</span><br><span class="line">2017-01-18T18:49:53.865+0800 I CONTROL  [initandlisten]</span><br><span class="line">2017-01-18T18:49:53.865+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.</span><br><span class="line">2017-01-18T18:49:53.866+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</span><br><span class="line">2017-01-18T18:49:53.866+0800 I CONTROL  [initandlisten]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>如果提示 “无法连接主机”，请检查你的 MongoDB 数据服务实例是否开启。</p><h3 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h3><ul><li><code>show dbs</code><ul><li>查看当前服务实例上所有的数据库</li></ul></li><li><code>use 数据库名称</code><ul><li>这个命令表示切换到指定的数据库</li><li>如果没有，也不会创建</li><li>如果已经有了，则表示切换到这个数据库对该数据库进行操作</li></ul></li><li><code>db</code><ul><li>查看当前所处的数据库</li></ul></li><li><code>db.集合名称.insert(数据文档)</code></li><li><code>show collections</code><ul><li>查看当前数据库中所有的集合</li></ul></li><li><code>db.集合名称.find()</code><ul><li>查询指定集合中所有的数据</li><li>可以通过 <code>db.集合名称.find().pretty()</code> 美化输出格式</li><li>默认是查询所有，可以通过：<code>db.集合名称.find({查询条件})</code> 按条件查询集合中的数据</li></ul></li><li><code>db.集合名称.update({更新条件}, {要更新的字段})</code><ul><li>更新指定集合数据</li></ul></li><li><code>db.集合名称.remove({删除条件})</code><ul><li>删除指定集合中的数据</li></ul></li></ul><h2 id="使用-Node-操作-MongoDB"><a href="#使用-Node-操作-MongoDB" class="headerlink" title="使用 Node 操作 MongoDB"></a>使用 Node 操作 MongoDB</h2><p>安装 MongoDB 官方提供的驱动包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save mongodb</span><br></pre></td></tr></table></figure><p>具体操作方式请参考官方文档：<a href="https://www.npmjs.com/package/mongodb" target="_blank" rel="noopener">https://www.npmjs.com/package/mongodb</a></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>能概述 package.json 文件的作用并能列举出至少两个该文件内成员的名称及作用</li><li>能掌握 Express 的基本使用（配置处理静态资源、配置使用ejs模板引擎、解析处理表单POST请求体）</li><li>能完成将 Hacker-News 案例改为 Express 版本</li><li>能掌握 MongoDB 数据库的基本使用（添加、删除、修改、查询）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Express、-MongoDB、-package-json的介绍&quot;&gt;&lt;a href=&quot;#Express、-MongoDB、-package-json的介绍&quot; class=&quot;headerlink&quot; title=&quot;Express、 MongoDB、 package.
      
    
    </summary>
    
    
      <category term="node" scheme="https://heima0.github.io/tags/node/"/>
    
      <category term="express" scheme="https://heima0.github.io/tags/express/"/>
    
      <category term="mongodb" scheme="https://heima0.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>对Node的理解以及简单使用</title>
    <link href="https://heima0.github.io/2016/05/21/%E5%AF%B9Node%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://heima0.github.io/2016/05/21/对Node的理解以及简单使用/</id>
    <published>2016-05-21T04:48:44.000Z</published>
    <updated>2022-11-12T14:02:35.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node理解、npm使用"><a href="#Node理解、npm使用" class="headerlink" title="Node理解、npm使用"></a>Node理解、npm使用</h1><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 是一个平台，Node 是一个框架，基于 Ecmascript 语言，在这个平台（或者说框架）之上<br>给 Ecmascript 提供了很多操作系统级别的编程接口。</p><p>做 Node 编程实际上就是通过 Ecmascript、Node平台内置的核心模块、第三方社区提供的模块构建高度模块化的程序。</p><h3 id="REPL：Node-中类似于浏览器中的-Console-控制台"><a href="#REPL：Node-中类似于浏览器中的-Console-控制台" class="headerlink" title="REPL：Node 中类似于浏览器中的 Console 控制台"></a>REPL：Node 中类似于浏览器中的 Console 控制台</h3><ul><li>Read</li><li>Eval</li><li>Print</li><li>Loop</li></ul><h2 id="Node-中的-JavaScript"><a href="#Node-中的-JavaScript" class="headerlink" title="Node 中的 JavaScript"></a>Node 中的 JavaScript</h2><ul><li>Ecmascript</li><li><em>console</em></li><li><em>setInterval(callback, delay[, …args])</em></li><li><em>setTimeout(callback, delay[, …args])</em></li><li><em>clearInterval(intervalObject)</em></li><li><em>clearTimeout(timeoutObject)</em></li><li>clearImmediate(immediateObject)</li><li>setImmediate(callback[, …args])</li><li>__dirname<ul><li>用于获取当前文件所属目录的绝对路径</li><li>使用场景：常用语将相对路径转为绝对路径，防止执行node命令所处的目录影响路径的问题</li></ul></li><li>__filename<ul><li>作用：获取当前文件的绝对路径</li></ul></li><li>process<ul><li>process 是Node中一个进程对象，可以用来访问当前运行进程的一些信息</li></ul></li><li>global<ul><li>类似于浏览器中的 window，是一个全局对象</li><li>唯一的区别在于浏览器中的 window 是全局对象，默认在全局声明的变量成员都属于 window</li><li>Node 中是模块作用域</li><li>在一个模块系统中，所有的模块都共享一个 global</li><li>也就是说可以通过给 global 显示的挂载成员在多个模块之间全局共享</li><li>虽然可以这样做，了解即可，尽量不要使用</li></ul></li><li>模块成员<ul><li>module<ul><li>module 是一个模块对象，里面包含了当前模块的一些信息</li><li>例如 exports 就是当前模块对外的导出接口对象</li></ul></li><li>exports<ul><li>在每一个模块中，同时还提供了一个接口成员：<code>exports</code></li><li><code>exports</code> 是 <code>module.exports</code> 接口对象的一个引用</li><li>也就是可以把 <code>module.exports.foo=xxx</code> 的形式简写为 <code>exports.foo=xxx</code></li><li>注意：注重向外的暴露的接口对象是：<code>module.exports</code></li></ul></li><li>require()<ul><li>执行被加载模块中的代码</li><li>拿到被加载模块中的 <code>module.exports</code> 接口对象</li></ul></li></ul></li></ul><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h3><ul><li>开发生产效率高</li><li>可维护性好</li></ul><p>每一个模块默认都是一个私有的作用域，互相独立，内部实现某一个具体的功能职责，<br>暴露接口成员，通过特定的规则将不同的模块组织到一起，就构成了一个<br>完整的模块系统。</p><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>以下是Node中的一些核心模块及作用：</p><table><thead><tr><th>核心模块名</th><th>作用</th></tr></thead><tbody><tr><td>fs</td><td>文件操作</td></tr><tr><td>http</td><td>网络操作</td></tr><tr><td>net</td><td>更底层的网络操作</td></tr><tr><td>os</td><td>操作系统相关</td></tr><tr><td>path</td><td>文件路径操作</td></tr><tr><td>querystring</td><td>查询字符串处理</td></tr><tr><td>url</td><td>url操作处理</td></tr></tbody></table><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><h3 id="模块加载机制规则"><a href="#模块加载机制规则" class="headerlink" title="模块加载机制规则"></a>模块加载机制规则</h3><p>require 方法中传递的参数叫做模块标识，其中涉及三种情况：</p><ul><li>以 <code>./</code> 后者 <code>../</code> 或者 <code>/</code> 或者 <code>C:/demo/a.js</code> 这种形式的文件模块</li><li>加载核心模块<ul><li>核心模块是Node内置的，例如：<code>fs</code>、<code>http</code>、<code>url</code> 等</li><li>已经别编译到了可执行文件中了</li><li>用的时候，必须通过一个特定的核心模块标识名称加载使用</li></ul></li><li>加载第三方模块<ul><li>通过 npm 下载的模块或者说包</li><li>加载第三方模块也是通过指定第三方模块的标识名称加载的</li><li>Node 会判定如果不是文件路径形式的模块，也不是核心模块</li><li>Node 会基于当前文件模块同级目录中的 node_modules 目录去查找该第三方模块标识对应的目录</li><li>如果在 node_modules 目录中能找到对应的目录，例如 mime</li><li>则 Node 去 mime 目录下找 <code>package.json</code> 文件</li><li>如果找到 <code>package.json</code> 文件，则找该文件中的 <code>main</code> 属性，然后根据该属性指向的文件模块进行加载</li><li>如果上述条件某一个环节不成立，则 Node 进入上一级目录中的 <code>node_modules</code> 进行查找，规则同上</li><li>如果一直到当前文件模块所属的磁盘根目录下都没有找到对应的 node_modules 中的第三方模块<ul><li>则最后报错：<code>can not find module xxx</code></li></ul></li></ul></li></ul><h3 id="包与Npm"><a href="#包与Npm" class="headerlink" title="包与Npm"></a>包与Npm</h3><p>将一些相关功能的文件模块组织到一起就形成了一个包。</p><hr><h2 id="通过模块化改造-Hacker-News-案例"><a href="#通过模块化改造-Hacker-News-案例" class="headerlink" title="通过模块化改造 Hacker News 案例"></a>通过模块化改造 Hacker News 案例</h2><hr><h2 id="总结基础概念"><a href="#总结基础概念" class="headerlink" title="总结基础概念"></a>总结基础概念</h2><hr><h2 id="使用-Npm-安装全局命令行工具"><a href="#使用-Npm-安装全局命令行工具" class="headerlink" title="使用 Npm 安装全局命令行工具"></a>使用 Npm 安装全局命令行工具</h2><p>在 npm 社区中，除了有可以在项目中使用的第三方包之外，还有一些特殊的包：<br>这些特殊的包被称之为命令行工具，不是用于项目的，而是可以安装到计算机中，<br>然后通过命令行中的命令的形式来使用，这种工具有很多，例如：<code>http-server</code>、<code>gulp</code>、<br><code>browser-sync</code>、<code>nodemon</code> 等等等等很多。</p><p>安装方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global 第三方命令行工具名字</span><br></pre></td></tr></table></figure><p>卸载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall --global 第三方命令行工具名称</span><br></pre></td></tr></table></figure><p>查看全局命令行安装目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root --global</span><br></pre></td></tr></table></figure><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>能掌握 Node 中模块化交互 API（require、exports、module.exports）并解释每一个API的作用</li><li>能详细概述 Node 中模块的分类以及加载规则（自己写的模块、核心模块、第三方模块）</li><li>能完成将 Hacker-News 案例改造为模块化的形式并解释每一个模块的作用</li><li>能掌握在Node中处理表单 POST 提交并详细概述在post类型表单中点击submit之后发生的事情（客户端与服务端都做了什么）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node理解、npm使用&quot;&gt;&lt;a href=&quot;#Node理解、npm使用&quot; class=&quot;headerlink&quot; title=&quot;Node理解、npm使用&quot;&gt;&lt;/a&gt;Node理解、npm使用&lt;/h1&gt;&lt;h2 id=&quot;Node&quot;&gt;&lt;a href=&quot;#Node&quot; cla
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
      <category term="node" scheme="https://heima0.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>npm介绍</title>
    <link href="https://heima0.github.io/2016/05/15/npm%E4%BB%8B%E7%BB%8D/"/>
    <id>https://heima0.github.io/2016/05/15/npm介绍/</id>
    <published>2016-05-15T04:44:19.000Z</published>
    <updated>2022-11-12T14:02:35.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm介绍"><a href="#npm介绍" class="headerlink" title="npm介绍"></a>npm介绍</h1><h2 id="npm是什么"><a href="#npm是什么" class="headerlink" title="npm是什么"></a>npm是什么</h2><h3 id="两层含义"><a href="#两层含义" class="headerlink" title="两层含义"></a>两层含义</h3><ul><li>npm 是一个网站，这个网站上托管了几十万个使用 JavaScript 开发的功能模块库</li><li>npm 是一个基于Node开发的一个终端命令行包管理工具<ul><li>可以使用这个工具去 npm 网站上下载对应的库</li></ul></li></ul><h3 id="npm-安装"><a href="#npm-安装" class="headerlink" title="npm 安装"></a>npm 安装</h3><p>只要安装了 node 就有了 npm。</p><p>通过 <code>npm -v</code> 测试是否有 npm 工具。</p><h3 id="使用-npm-安装包"><a href="#使用-npm-安装包" class="headerlink" title="使用 npm 安装包"></a>使用 npm 安装包</h3><ol><li>找到能解决自己问题的包，看文档使用说明</li><li>通过 <code>npm install 包名</code> 下载到当前项目中的根目录</li><li>在代码中通过 <code>require(&#39;第三方包名&#39;)</code> 使用你下载的包</li></ol><p>通过 <code>npm install 包名</code> 安装的包会自动下载到当前目录下的 <code>node_modules</code> 目录，<br>如果该目录不存在，则直接创建，如果已存在，则直接将文件下载进去。</p><hr><h2 id="Node-中的模块化"><a href="#Node-中的模块化" class="headerlink" title="Node 中的模块化"></a>Node 中的模块化</h2><h3 id="模块通信交互规则"><a href="#模块通信交互规则" class="headerlink" title="模块通信交互规则"></a>模块通信交互规则</h3><ul><li>一个 JavaScript 文件就是一个模块</li><li>模块天生就是一个私有的作用域，默认模块内定义的变量等成员只能被模块内部访问</li><li>每一个模块中都有一个 <code>module.exports</code> 编程接口对象，默认是一个空对象<ul><li>可以通过给 <code>module.exports</code> 编程接口对象添加成员向外暴露内部成员</li><li>例如：<code>var foo = &#39;bar&#39; module.exports.foo = foo</code></li><li>上面示例标识当前模块向外部暴露了一个接口对象，内部有一个 foo 成员，值是 bar</li></ul></li><li><code>require</code> 方法可以用来加载模块，该方法是同步加载执行的，主要做两件事儿<ul><li><ol><li>执行被加载模块中所有的代码</li></ol></li><li><ol start="2"><li>拿到被加载模块中的 <code>module.exports</code> 接口对象</li></ol></li></ul></li></ul><h3 id="用户自定义模块"><a href="#用户自定义模块" class="headerlink" title="用户自定义模块"></a>用户自定义模块</h3><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块就是 Node 提供的模块，例如 <code>fs</code>、<code>http</code>、<code>path</code>。。。，<br>这些模块其实也是文件模块，核心模块一般都是通过一个固定的标识名称进行加载的，<br>也就是说不能写错，固定的。用什么就加载什么，无论是程序执行效率还是可维护性都非常好。</p><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><p>也就是npm社区提供的第三方包，用的时候，先下载，然后也是通过 <code>require</code> 进行加载，<br>加载第三方模块的时候，就是通过 <code>require(&#39;第三方模块标识名&#39;)</code>，所以第三方模块不可能有和<br>核心模块重名的名称。</p><p>第三方加载模块有自己的一套加载规则，node 会按照对应的加载机制去加载。<br>具体明天上午会给大家详细解析。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>能掌握基本的Web开发思想（没有Web容器、url只是标识、处理页面资源和静态资源）</li><li>能掌握在Node中使用模板引擎（服务端渲染）</li><li>能掌握解析处理表单 GET 提交并详细概述点击提交按钮之后发生的事情（客户端做了什么，后台如何解析处理的）</li><li>能掌握基本的模块化交互规则（require、module.exports）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;npm介绍&quot;&gt;&lt;a href=&quot;#npm介绍&quot; class=&quot;headerlink&quot; title=&quot;npm介绍&quot;&gt;&lt;/a&gt;npm介绍&lt;/h1&gt;&lt;h2 id=&quot;npm是什么&quot;&gt;&lt;a href=&quot;#npm是什么&quot; class=&quot;headerlink&quot; title=&quot;n
      
    
    </summary>
    
    
      <category term="npm" scheme="https://heima0.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>node介绍</title>
    <link href="https://heima0.github.io/2016/05/12/node.js%E4%BB%8B%E7%BB%8D/"/>
    <id>https://heima0.github.io/2016/05/12/node.js介绍/</id>
    <published>2016-05-12T04:37:42.000Z</published>
    <updated>2022-11-12T14:02:35.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-介绍"><a href="#Node-js-介绍" class="headerlink" title="Node.js 介绍"></a>Node.js 介绍</h1><h2 id="1-了解node-js"><a href="#1-了解node-js" class="headerlink" title="1. 了解node.js"></a>1. 了解node.js</h2><h3 id="1-1-网站开发模型（BS）"><a href="#1-1-网站开发模型（BS）" class="headerlink" title="1.1 网站开发模型（BS）"></a>1.1 网站开发模型（BS）</h3><ul><li>Server<ul><li>为客户端提交接口：数据</li><li>Java、.Net、Ruby、Python、PHP、Go、Swift、Lua</li><li>学 Node 本质不是在学 Node，在学 服务器（Web后台）编程</li><li>请求<ul><li>处理</li></ul></li><li>响应</li><li>大前端时代：JavaScript 语言也可以运行在服务器端</li><li>使用 JavaScript 这门语言也可以进行服务器编程</li><li>JavaScript 通过 Node.js 运行在服务器端</li></ul></li><li>Browser<ul><li>客户端：把一坨用户看不懂的数据变成友好的形式给用户体验</li></ul></li></ul><h3 id="1-2-什么是-Node-js？"><a href="#1-2-什么是-Node-js？" class="headerlink" title="1.2 什么是 Node.js？"></a>1.2 什么是 Node.js？</h3><blockquote><p>简单的说 Node.js 就是运行在服务端的 JavaScript<br>Node开发就是利用 Ecmascript + 第三方开源库 + Node平台环境API进行编程</p></blockquote><ul><li><p>什么是 JavaScript</p><ul><li>JavaScript 一个运行在浏览器端的脚本原因</li><li>运行时：浏览器</li><li>Ecmascript：JavaScript 基本语法：var、if-else、for、Array、Object、String、function</li><li>BOM<ul><li>Window</li><li>DOM</li></ul></li><li>渲染引擎</li><li>JavaScript 解析执行引擎<ul><li>在所有浏览器中，Google Chrome 的 V8 引擎是最快的 JS 脚本代码解析执行引擎</li></ul></li><li>通过 V8 引擎解析和执行 JavaScript 代码</li></ul></li><li><p>Node 官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p></li><li><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. </p><ul><li>Node.js 是一个构建与 Chrome V8 引擎之上的一个 JavaScript 运行时（执行环境）</li><li>Node 使用 JavaScript 进行编程</li><li>Node 采用了 Chrome 的 V8 引擎解析和执行 JavaScript 脚本代码</li><li>Node 不是一种语言，Node 可以用来解析和执行 JavaScript 代码</li><li>在 Node 没有 DOM、BOM 了，也不用去关心样式、结构问题了</li><li>Node 在基本的 JavaScript 语言之上，或者在 Node 平台给 Ecmascript 提供了大量的底层编程接口<ul><li>例如文件IO</li><li>例如网络IO</li><li>处理数据</li><li>操作数据库</li><li>构建网络服务</li><li>。。。</li></ul></li></ul></li><li>Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. <ul><li>event-driven：事件驱动<ul><li>在 Node 中，也采用了类似于浏览器端的编程思想，事件模型编程思想</li></ul></li><li>non-blocking I/O model：非阻塞IO模型<ul><li>Node 中大量的通过类似于浏览器中 ajax 的方式进行编程</li><li>绝大多数代码都是异步编程模型</li></ul></li><li>lightweight &amp; efficient：轻量和高效</li></ul></li><li>Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.<ul><li>Node.js 包生态系统 Npm 是世界上最大的开源库生态系统</li><li>largest ecosystem：最大的开源库生态系统</li></ul></li></ul><h3 id="1-3-使用-Node-可以做什么？"><a href="#1-3-使用-Node-可以做什么？" class="headerlink" title="1.3 使用 Node 可以做什么？"></a>1.3 使用 Node 可以做什么？</h3><ul><li>开发网站服务器</li><li>游戏服务器</li><li>开发命令行工具<ul><li>软件分为两种：</li><li>GUI：看得见，鼠标点点点</li><li>CLI：命令窗口，各种命令，选项参数等</li></ul></li></ul><h3 id="1-4-Node-发展史"><a href="#1-4-Node-发展史" class="headerlink" title="1.4 Node 发展史"></a>1.4 Node 发展史</h3><ul><li>Node.js 由 Ryan Dahl 和一些其他的开发者于2009年在 Joyent 工作时发明</li><li>Node 作者当初只是想做一个类似于 Apache 的服务器而已，最初的时候起的名字叫：webjs</li><li>2009年2月，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。</li><li>2009年5月，Ryan Dahl在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用。</li><li>2009年11月和2010年4月，两届JSConf大会都安排了Node.js的讲座。</li><li>2010年年底，Node.js获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node.js的发展。</li><li>2011年7月，Node.js在微软的支持下发布Windows版本。[2] </li></ul><h3 id="1-5-学习资源推荐"><a href="#1-5-学习资源推荐" class="headerlink" title="1.5 学习资源推荐"></a>1.5 学习资源推荐</h3><ul><li>国内NodeJS开发者社区：<a href="https://cnodejs.org/" target="_blank" rel="noopener">https://cnodejs.org/</a></li><li>《深入浅出Node.js》：作者：阿里巴巴.朴灵</li></ul><hr><h2 id="2-快速上手"><a href="#2-快速上手" class="headerlink" title="2. 快速上手"></a>2. 快速上手</h2><h3 id="2-1-环境安装"><a href="#2-1-环境安装" class="headerlink" title="2.1 环境安装"></a>2.1 环境安装</h3><ul><li><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></li></ul><h3 id="2-2-Hello-World"><a href="#2-2-Hello-World" class="headerlink" title="2.2 Hello World"></a>2.2 Hello World</h3><ul><li>当你在控制台输入：<code>node 01-hello-world.js</code> 之后</li><li>实际上通过你安装目录下的那个 <code>node.exe</code> 可执行程序读取了 <code>01-hello-world.js</code> 文件中的源代码</li><li>然后解析和执行文件中的代码</li><li>最后将结果打印输出到了控制台中</li></ul><h3 id="2-3-path-环境变量"><a href="#2-3-path-环境变量" class="headerlink" title="2.3 path 环境变量"></a>2.3 path 环境变量</h3><ul><li>目的：就是为了在终端的任意目录中都可以找到该可执行文件</li><li>配置方式：<ul><li>一种在 path 中写路径，通过英文分号分隔</li><li>一种先定义变量，给一个变量值，然后在 path 中通过英文分号进行分隔，使用 <code>%变量名%</code> 引用该变量</li></ul></li></ul><h3 id="2-4-文件操作"><a href="#2-4-文件操作" class="headerlink" title="2.4 文件操作"></a>2.4 文件操作</h3><h3 id="2-5-HTTP-服务"><a href="#2-5-HTTP-服务" class="headerlink" title="2.5 HTTP 服务"></a>2.5 HTTP 服务</h3><h3 id="2-6-文件版留言本"><a href="#2-6-文件版留言本" class="headerlink" title="2.6 文件版留言本"></a>2.6 文件版留言本</h3><hr><h2 id="3-Node-基础"><a href="#3-Node-基础" class="headerlink" title="3. Node 基础"></a>3. Node 基础</h2><h3 id="3-1-Node-中的-JavaScript"><a href="#3-1-Node-中的-JavaScript" class="headerlink" title="3.1 Node 中的 JavaScript"></a>3.1 Node 中的 JavaScript</h3><ul><li><em>console</em></li><li><em>setInterval(callback, delay[, …args])</em></li><li><em>setTimeout(callback, delay[, …args])</em></li><li><em>clearInterval(intervalObject)</em></li><li><em>clearTimeout(timeoutObject)</em></li><li>clearImmediate(immediateObject)</li><li>setImmediate(callback[, …args])</li><li>__dirname</li><li>__filename</li><li>module</li><li>exports</li><li>global</li><li>process</li><li>require()</li></ul><h3 id="3-2-模块化"><a href="#3-2-模块化" class="headerlink" title="3.2 模块化"></a>3.2 模块化</h3><h3 id="3-3-自定义模块（用户自己编写的模块）"><a href="#3-3-自定义模块（用户自己编写的模块）" class="headerlink" title="3.3 自定义模块（用户自己编写的模块）"></a>3.3 自定义模块（用户自己编写的模块）</h3><ul><li>require</li><li>module.exports</li><li>exports</li></ul><h3 id="3-4-核心模块（Node-提供）"><a href="#3-4-核心模块（Node-提供）" class="headerlink" title="3.4 核心模块（Node 提供）"></a>3.4 核心模块（Node 提供）</h3><blockquote><p>在线文档地址：<a href="https://nodejs.org/dist/latest-v6.x/docs/api/" target="_blank" rel="noopener">https://nodejs.org/dist/latest-v6.x/docs/api/</a></p></blockquote><p>以下是常用的核心模块及作用：</p><table><thead><tr><th>核心模块名</th><th>作用</th></tr></thead><tbody><tr><td>fs</td><td>文件操作</td></tr><tr><td>http</td><td>网络操作</td></tr><tr><td>net</td><td>更底层的网络操作</td></tr><tr><td>os</td><td>操作系统相关</td></tr><tr><td>path</td><td>文件路径操作</td></tr><tr><td>querystring</td><td>查询字符串处理</td></tr><tr><td>url</td><td>url操作处理</td></tr></tbody></table><h3 id="3-5-第三方模块（也称作包）"><a href="#3-5-第三方模块（也称作包）" class="headerlink" title="3.5 第三方模块（也称作包）"></a>3.5 第三方模块（也称作包）</h3><h3 id="3-6-包与-Npm"><a href="#3-6-包与-Npm" class="headerlink" title="3.6 包与 Npm"></a>3.6 包与 Npm</h3><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>能掌握path环境变量的配置</li><li>能掌握基本的文件读写操作</li><li>能掌握基本的 http 服务构建（路径、静态资源、页面资源）</li><li>能掌握在 Node 中处理表单 GET 提交</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node-js-介绍&quot;&gt;&lt;a href=&quot;#Node-js-介绍&quot; class=&quot;headerlink&quot; title=&quot;Node.js 介绍&quot;&gt;&lt;/a&gt;Node.js 介绍&lt;/h1&gt;&lt;h2 id=&quot;1-了解node-js&quot;&gt;&lt;a href=&quot;#1-了解node-j
      
    
    </summary>
    
    
      <category term="node" scheme="https://heima0.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node的知识点整理</title>
    <link href="https://heima0.github.io/2016/05/10/node%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://heima0.github.io/2016/05/10/node的知识点整理/</id>
    <published>2016-05-10T04:35:24.000Z</published>
    <updated>2022-11-12T14:02:35.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将之前学习过的node知识简单整理一下"><a href="#将之前学习过的node知识简单整理一下" class="headerlink" title="将之前学习过的node知识简单整理一下"></a>将之前学习过的node知识简单整理一下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块有点多，自己按着自己的记忆大概梳理一下</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;将之前学习过的node知识简单整理一下&quot;&gt;&lt;a href=&quot;#将之前学习过的node知识简单整理一下&quot; class=&quot;headerlink&quot; title=&quot;将之前学习过的node知识简单整理一下&quot;&gt;&lt;/a&gt;将之前学习过的node知识简单整理一下&lt;/h3&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="node" scheme="https://heima0.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>JS原生框架-6</title>
    <link href="https://heima0.github.io/2016/03/21/JS%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-6/"/>
    <id>https://heima0.github.io/2016/03/21/JS原生框架-6/</id>
    <published>2016-03-21T00:46:21.000Z</published>
    <updated>2022-11-12T14:02:35.948Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>常见问题<br> 这几个模块的js文件，除了第一个core.js，其他的沙箱是不是不需要暴露接口了</p><pre><code>这几个模块就存在了一个依赖关系iquery.core.js</code></pre><p> 去重函数为什么不能是实例方法而是工具方法不太明白</p><pre><code>一般情况, 需要实现某些通用功能的时候, 都是实现一个静态方法, 然后再用这个静态方法实现一个实例方法, 类似于 map 或 each.上次的案例有一个算法上的缺陷.    iQuery.unique = function ( array ) {        var arr = [];        // 循环, 将唯一的元素加到 这个数组中        return arr;    }iquery 对象包含: [ i ] 索引元素外, 还有 prevObject, 其他方法, ...如果一定要实现, 必须保证保留 除 索引元素外的所有数据    iQUery.unique = function ( iObj ) {        var iTmp, arr = [];        iObj.each( function ( i, v ) {            if ( arr.indexOf( v ) == -1 ) {                arr.push( v );            }        });        iTmp = iQuery( arr );        iTmp.prevObject = iObj.prevObject;        return iTmp;    };    iQuery.fn.unique = function () {        return iQUery.unique( this );    };</code></pre><p> pushStack 与 end</p><pre><code>var o1 = { name: &apos;jim&apos; };假如有一个功能 func( o1, name ) 返回的对象 名字就改了, 改成传入的名字要求, 返回新对象, 同时要求可以记录旧对象.    function func( o, name ) {        o.name = name;        return o;    }如何记录以前的信息呢? 在当前对象中记录以前的信息    function func( o, name ) {        o.prevName = o.name;        o.name = name;        return o;    }如果要访问以前的名字, 即访问 prevName 属性即可.如果要访问以前的名字: o.prevName || o.name我们的逻辑是在链发生改变的时候记录下以前的对象    var oldObj = ...;    // 新元素一定是一个由数组构成的对象    var arr = [ ... ];    var newObj = iQuery( arr );    newObj.prevObject = oldObj;    return newObj;$( &apos;div&apos; ).css( &apos;border&apos;, &apos;1px solid red&apos; )          .css( &apos;width&apos;, &apos;100px&apos; )          .css( ... )</code></pre></li></ol><ol start="2"><li><p>推荐书籍<br> 1, dom 程序xxx的艺术<br> 2, js 语言精粹<br> 3, js 权威指南( 犀牛 )<br> 4, js 模式</p></li><li><p>事件操作<br> 在 jq 中如何使用事件?<br> 以 点击事件为例</p><pre><code>$( &apos;.btn&apos; ).click( function () {     ...});$( &apos;#btn&apos; ).on( &apos;click&apos;, function () {});</code></pre><p> iQuery.fn.on = function ( type, callback ) {</p><pre><code>return this.each(function () {    this.addEventListener( type, callback );});</code></pre><p> }<br> iQuery.fn.off = function ( type, callback ) {</p><pre><code>return this.each(function () {    this.removeEventListener( type, callback );});</code></pre><p> }</p><p> iQuery.fn.click = function ( callback ) {</p><pre><code>return this.on( &apos;click&apos;, callback );</code></pre><p> }</p></li><li><p>属性操作与样式操作<br> 常用的方法:</p><pre><code>.attr(  ).prop(  ).html(  ).text(  ).val(  ) .css(  ).addClass().removeClass().hasClass().toggleClass()</code></pre></li></ol><ol start="5"><li><p>压缩合并代码<br> 前段发展的有一批工具可以被使用, 这里的所有工具有一个共同的特征, 就是需要 node 平台</p><p> 谷歌给出了世界上最快的 js 解析引擎, chrome v8</p><p> 将 v8 引擎分离出来, 是的 js 可以脱离 浏览器来运行, 这个就是 node 平台</p><p> 安装 node 环境<br> 1) 在网站 nodejs.org 中下载对应的版本<br> 2) 双击安装<br> 3) 在命令行中输入</p><pre><code>node -v和npm -v检查是否安装成功</code></pre></li></ol><pre><code>压缩的准备工作-&gt; npm, node 的包管理器    包 package, 就是 js 库    使用         npm install 包名          安装包, 安装到当前目录的 node_modules 文件夹中        如果没有梯子, 就是用:             npm install 包名 --registry=https://registry.npm.taobao.org        如果是 mac 系统, 会在 家目录下( ~ ) 创建一个 node_modules 会下载到这来. 如果            想要下载到当前目录, 需要手动创建 node_modules 文件夹    还可以将包安装到全局        npm install -g 包名        一般将可执行的或通用的一些包安装到全局-&gt; 构建工具    这些工具都是开源的有很多种, grunt, gulp, webpack 等    在这里我们使用 gulp 来实现    gulp官网:        www.gulpjs.com.cn        www.gulpjs.com-&gt; gulp 的基本使用    -&gt; 安装        1. 安装全局 gulp 项目            npm install -g gulp        2. 安装本地的依赖项            npm install gulp    -&gt; 使用        1. 在当前目录下建一个文件 命名为 gulpfile.js        2. 在里面编写需要处理的代码    -&gt; 首先        var gulp = require( &apos;gulp&apos; );        相当于 html 文件中的 script 标签        gulp.task( 名字, function () {            // 处理代码        });</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;常见问题&lt;br&gt; 这几个模块的js文件，除了第一个core.js，其他的沙箱是不是不需要暴露接口了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这几个模块就存在了一个依赖关系
iquery.core.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 去重函数为什么不能是实例方法而
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS原生框架-5</title>
    <link href="https://heima0.github.io/2016/03/15/JS%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-5/"/>
    <id>https://heima0.github.io/2016/03/15/JS原生框架-5/</id>
    <published>2016-03-15T10:46:00.000Z</published>
    <updated>2022-11-12T14:02:35.948Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>常见问题<br> 1&gt; 代码结构<br> 2&gt; 总结:</p><pre><code>$( &apos;&lt;div&gt;123&lt;/div&gt;&apos; ).appendTo( $( &apos;div&apos; ) )1) 如果左边的html字符串是多个元素什么结果, 规律是什么2) 如果右边的选择器得到的是多个元素, 结果又是什么, 有什么规律3) 如果两边都是多个元素, 又是什么结果, 什么规律</code></pre><p> 3&gt; 实现代码 appendTo() 参数为 dom 数组的情况<br> 4&gt; dom 操作整理</p></li><li><p>jq 案例<br> <div id="dv"></div><br> …<br> // 鼠标移入的时候有颜色高亮, 鼠标移开的时候颜色恢复<br> $( ‘#dv’ ).mouseenter(function () {</p><pre><code>$( this ).addClass...</code></pre><p> }).mouseleave(function () {</p><pre><code>$( this ). ...</code></pre><p> });</p><p> iQuery.select = function ( selector ) { </p><pre><code>return slice.call( document.querySelectorAll( selector ) ); </code></pre><p> };<br> //这里直接return document.querySelectorAll( selector)行吗？一定要返回一个真数组吗？ </p><p> //构造函数中push.apply(this, iQuery.select(selector));传入伪数组也是可以的吧？</p><p> var init = iQuery.prototype.init = function (selector) { </p><pre><code>return [].push.apply(this, iQuery.select(selector)); </code></pre><p> }<br> iQuery.select = function (selector) { </p><pre><code>return [].slice.call(document.querySelectorAll(selector)); </code></pre><p> }<br> 为什么要分成两步，直接[].push.apply(this,document.querySelectorAll(selector))不就好了，<br> 为什么[].slice.call(document.querySelectorAll(selector))转换成真数组再<br> [].push.apply(this, iQuery.select(selector))</p></li></ol><pre><code>核心结构中    iQuery.fn = iQuery.prototype = {};     iQuery.prototype.init.prototype = iQuery.fn; 这两句连写成iQuery.prototype.init.prototype = iQuery.fn = iQuery.prototype = {}; 会报错Cannot set property &apos;prototype&apos; of undefined，为什么？ parseHTMl方法中为什么不使用Children？ 当用childNodes时，如果传入的字符串‘ &lt;div&gt;&lt;/div&gt; ’两端有空格，得到的数组就会有文本节点存在，难道不会造成使用问题和性能问题吗？iQuery.select = function(selector){    slice.call(document.querySelectorAll(selector));}用来获取dom对象, var init = iQuery.fn.init = function(){    push.apply(this,iQuery);}用来初始化函数,是不是多此一举?为什么不直接: var init = iQuery.fn.init = function(){    slice.apply(this,document.querySelectorAll(selector));}不是一样么?</code></pre><ol start="3"><li><p>如果appendTo方法右边是多个元素, 如何处理</p> <div></div><br> <div></div><p> …<br> $( ‘</p><p>ppp</p>‘ ).appendTo( ‘div’ );<p></p><p> 首先实现 假如 appendTo 方法的参数为 div 数组的时候, 如何处理</p><p> 处理了 dom 元素, 简答<br> 处理了 dom 数组, 相对容易, 而且就解决了 传入的是 iQuery 对象的情况</p><p> appendTo 还可以使用 字符串选择器</p><p> function appendTo( selector ) {</p><pre><code>&lt;!--if ( selector.nodeType ) {} else if( selecto.length &gt;=0 ) {} else if ( typeof selector == &apos;string&apos; ) {    var iObj = iQuery( selector )}--&gt;</code></pre></li></ol><pre><code>    var IObj= iQuery( selector );}</code></pre><ol start="4"><li><p>说明<br>  appendTo: function ( array ) {</p><pre><code>var that = this;</code></pre></li></ol><pre><code>    var arr = I.map( array, function ( v, i ) {        return that.map(function ( v1, i1 ) {            var node = i === array.length - 1 ? v1                                               : v1.cloneNode( true );              v.appendChild( node );            return node;        });    });    arr = arr.concat,apply( [],  arr ); // [ [] ] -&gt; []    return iQuery( arr );}</code></pre><ol start="5"><li><p>实现 prepend 与 prependTo 方法<br> 区别:</p><pre><code>1&gt; appendTo 和 prependTo $( &apos;&lt;div&gt;&lt;/div&gt;&apos; ).appendTo( &apos;div&apos; ); 将新创建的 div 加到页面中已有的 div 中的子元素中的结尾处( 追加 ) $( &apos;&lt;div&gt;&lt;/div&gt;&apos; ).prependTo( &apos;div&apos; ); 将新创建的 div 标签加到页面中已有的 div 中的子元素的最前面.2&gt; append 和 prepend  $( &apos;div&apos; ).append( &apos;&lt;p&gt;ppp&lt;/p&gt;&apos; ) $( &apos;div&apos; ).prepend( &apos;&lt;p&gt;ppp&lt;/p&gt;&apos; )</code></pre></li><li><p>insertBefore 等方法<br> 用法:</p><pre><code>$( &apos;&lt;p&gt;pppp&lt;/p&gt;&apos; ).insertBefore( &apos;div&apos; );将新创建的 p 标签, 插入到 页面中的 所有的 div 元素的前面    如果是单个元素:        div.parentNode.insertBefore( newNode, div ); -&gt; f( div, newNode )    如果是一个数组        div[ i ].parentNode.insertBefore( newNodes[ j ], div[ i ] )</code></pre></li><li><p>insertAfter<br> 用法:</p><pre><code>$( &apos;&lt;p&gt;pppp&lt;/p&gt;&apos; ).insertAfter( &apos;div&apos; );首先判断是不是最后一个元素: parent.lastChild === currentNode如果是最后一个元素则 append如果不是则找到后一个元素, 往前加: currentNode.nextSibling... insertBefore...</code></pre></li><li><p>after 与 before</p></li></ol><ol start="9"><li>其他的亲属节点访问方法<br> .parent()<br> .next()<br> .nextAll()<br> .prev()<br> .prevAll()<br> .siblings()</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;常见问题&lt;br&gt; 1&amp;gt; 代码结构&lt;br&gt; 2&amp;gt; 总结:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$( &amp;apos;&amp;lt;div&amp;gt;123&amp;lt;/div&amp;gt;&amp;apos; ).appendTo( $( &amp;apos;div&amp;apos; ) )
1)
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS原生框架-4</title>
    <link href="https://heima0.github.io/2016/03/09/JS%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-4/"/>
    <id>https://heima0.github.io/2016/03/09/JS原生框架-4/</id>
    <published>2016-03-09T02:40:48.000Z</published>
    <updated>2022-11-12T14:02:35.947Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>常见问题<br>  var name = ‘…’<br>  // 张三丰 -&gt; 张*<em><br>  // 李四 -&gt; 李</em><br>  function convert( name ) {</p><pre><code>var firstName = name.charAt( 0 ); // 遍历 百家姓// 如果是复姓 indexOf( ... ) == 0var lastName = &apos;**********&apos;.slice( 0, name.length - 1 );return firstName + lastName;</code></pre><p>  }</p><p>  在 ES6 中引入了箭头函数( 简单的说: 函数的简写形式 )<br>  arr.forEach( function ( v, i ) {</p><pre><code>// ...</code></pre><p>  });<br>  1) 删去 function 关键字<br>  2) 利用 =&gt; 链接参数与函数体, 符号 =&gt; 读作 goes to<br>  arr.forEach( ( v, i ) =&gt; {</p><pre><code>// ...</code></pre><p>  });<br>  注意:<br>  1) 如果参数只有一个, 那么圆括号可以省略</p><pre><code>arr.forEach( v =&gt; {    console.log( v );});</code></pre><p>  2) 如果方法体只有一句话, {} 可以省略, return 也可以省略</p><pre><code>// 例如将数组元素扩大一倍返回arr.map(function ( v ) {    return v * 2;});// 如果使用箭头函数arr.map( v =&gt; v*2 );</code></pre><p>  3) 在 箭头函数中, 函数内的 this 不再具有新的作用域. </p></li></ol><ol start="2"><li>问题<br> ([|!^$~]?=) 分析<pre><code>[|!^$~]?=因此它是匹配 = 或 xxx=[|!^$~] 匹配 | 或者 ! 或者 ^ 或者 $ 或者 ~因此正则表达式是在匹配    =, |=, !=, ^=, $=, ~=</code></pre></li></ol><pre><code>            &lt;div class=&quot;main-app aap1 app2 app3&quot;&gt;&lt;/div&gt;            [class |= main]function replace( str, regex, callback ) {    var arr = regex.exec( str ); // [ 0, 1, ... ]    callback.apply( null, arr )    // 字符串拼接}^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$分析    (&lt;[\w\W]+&gt;)[^&gt;]*    01234567890123    &lt;div&gt;123&lt;/div&gt;    &apos;   &lt;div&gt; .... &lt;/div&gt;     &apos;    #([\w-]*)    #名字</code></pre><ol start="3"><li><p>核心结构<br> 1) 代码应该写在 单独的文件中<br> 2) 应该具有的成员有什么呢? 构造函数, 暴露的函数接口, 原型, each 和 map</p></li><li><p>框架的 扩展<br> 所谓的扩展就是给原型或构造方法( iQuery ) 提供新的成员<br> 就是在给一个对象增加新的成员</p><p> 可以使用混合式. 其思想就是将几个对象的成员混合到一起</p><p> extend 扩展</p><p> 需求:<br> 1) 实现 extend 方法<br> 2) 使得代码尽可能短</p><p> // 对原型的处理<br> iQuery.fn.extend = function ( options ) {</p><pre><code>for ( var k in options ) {    this[ k ] = options[ k ];}</code></pre><p> }</p><p> // 对 iQuery 处理<br> iQuery.extend = function( options ) {</p><pre><code>for ( var k in options ) {    this[ k ] = options[ k ];}</code></pre><p> }</p><p> //<br> iQuery.extend = iQuery.fn.extend = function ( options ) {</p><pre><code>for ( var k in options ) {    this[ k ] = options[ k ];}</code></pre><p> };</p><p> 将来在扩展功能的时候怎么用呢?<br> 1) 扩展实例方法</p><pre><code>iQuery.fn.extend({    method: function ...});</code></pre><p> 2) 扩展静态方法</p><pre><code>iQuery.extend( ... )</code></pre></li><li><p>DOM 操作<br> appendTo<br> append<br> prependTo<br> prepend<br> insertBefore<br> insertAfter<br> before</p><p> parent<br> next<br> nextAll<br> prev<br> prevAll<br> siblings</p><p> parseHTML   </p><p> 要实现一个方法<br> 1) 如何定义其参数与返回值( 返回以dom作为元素的数组 )<br> 2) 具体的代码实现</p><p> ‘<div><div></div></div>‘<br> ‘<div></div><div></div>‘<br> function parseHTML ( htmlStr ) {</p><p> }<br> // 思路: 只需要创建一个 div, 将 字符串赋值给 div 的 innerHTML 属性即可</p><p> function parseHTML ( htmlStr ) {</p><pre><code>var div = document.createElement( &apos;div&apos; );div.innerHTML = htmlStr; // 转换// 要返回数组 // return div.childNodes;return [].slice.call( div.childNodes );</code></pre><p> }</p><p> // 思考题: 这里有一个 bug</p></li><li><p>问题<br> 所有的 dom 元素只允许有一个父元素. 因此将一个 dom 元素<br> 追加到另一个元素里时, 会自动的从原有的父元素中移除.</p><p> <div></div></p><pre><code>&lt;div&gt;123&lt;/div&gt;&lt;div&gt;456&lt;/div&gt;</code></pre><p> <br> 将 第 0 个 div 追加到 body 上的时候, 会从原有的位置移除<br> <div></div></p><pre><code>&lt;div&gt;456&lt;/div&gt;</code></pre><p> <br> 此时 childNodes 的长度也会自动的 -1, 原来排在第 1 号<br> 位置的 div 也会变成 第 0 号.</p></li><li><p>将 parseHTML 引入到 框架结构中<br> 修改构造函数, 判断一下, 如果是 字符串结构, 就采用 parseHTML<br> 如果不是字符串结构就用 qsa 方法</p><p> 在 jq 构造函数中, 参数可以是很多东西</p><pre><code>1) 字符串: 1&gt;选择器, 2&gt;HTML 字符串2) DOM 元素3) 函数: 相当于 onload 事件4) jquery 元素    $( &apos;&lt;div /&gt;&apos; ).appendTo( $( &apos;body&apos; ) );    $( &apos;&lt;div /&gt;&apos; ).appendTo( &apos;body&apos; );5) 可以是 空...</code></pre><p> 在 init 构造函数中准备一套 if else 结构<br> 处理每一个情况</p></li><li><p>引入 appendTo 方法<br> 问题:<br> 1&gt; 方法写在哪里?  加到原型中<br> 2&gt; 参数与返回值?  参数: 字符串, dom, iquery<br> 3&gt; 具体的逻辑实现? </p><p> 实现:<br> 1) 参数为 dom 对象<br> 2) dom 数组怎么处理( *** )<br> 3) 一般情况</p></li><li><p>问题<br> 1&gt; 代码结构<br> 2&gt; 总结:</p><pre><code>$( &apos;&lt;div&gt;123&lt;/div&gt;&apos; ).appendTo( $( &apos;div&apos; ) )1) 如果左边的html字符串是多个元素什么结果, 规律是什么2) 如果右边的选择器得到的是多个元素, 结果又是什么, 有什么规律3) 如果两边都是多个元素, 又是什么结果, 什么规律</code></pre><p> 3&gt; 实现代码 appendTo() 参数为 dom 数组的情况<br> 4&gt; dom 操作整理</p></li></ol><ol start="10"><li><p>js 数据类型<br>-&gt; 简单类型: number, string, boolean. 变量存储数据本身.<br>-&gt; 复合类型: 由简单类型或复合类型组合得到是数据类型.</p><pre><code>对象: String, Number, Boolean,      [], {}, /.+/, ...函数由于结构特征, 一二引用数据无法直接确定需要占据多大内存, 因此理论上变量不能直接存储数据本身. 系统一般会在内存的一个独立区域存储数据本身,而变量仅仅存储的是 这个数据的 &quot;内存地址&quot;. 常常称为引用.</code></pre></li></ol><pre><code>-&gt; 空类型: null, undefinedvar number1 = 123;var number2 = number1;number1 = 456;var person = {    name: &apos;jim&apos;,    age: 19,    gender: &apos;男&apos;,    scores: {        chinese: 95,        english: 80,        math: 70    }};var stu = person;// 凡是看到等号, 就是将 等号右边的盒子中 的数据 拷贝一份// 存储到 左边的这个盒子中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;常见问题&lt;br&gt;  var name = ‘…’&lt;br&gt;  // 张三丰 -&amp;gt; 张*&lt;em&gt;&lt;br&gt;  // 李四 -&amp;gt; 李&lt;/em&gt;&lt;br&gt;  function convert( name ) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fir
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS原生框架-3</title>
    <link href="https://heima0.github.io/2016/02/14/JS%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-3/"/>
    <id>https://heima0.github.io/2016/02/14/JS原生框架-3/</id>
    <published>2016-02-14T02:44:45.000Z</published>
    <updated>2022-11-12T14:02:35.947Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>每天坚持多看看</p><h6 id="今天主要内容：复习经常会遇到的问题"><a href="#今天主要内容：复习经常会遇到的问题" class="headerlink" title="今天主要内容：复习经常会遇到的问题"></a>今天主要内容：复习经常会遇到的问题</h6><h6 id="整理一下正则表达式的用法"><a href="#整理一下正则表达式的用法" class="headerlink" title="整理一下正则表达式的用法"></a>整理一下正则表达式的用法</h6></li><li><p>问题<br>  1.为什么 forEach 中的回调函数有第三个参数 </p><pre><code>arr.forEach( function ( v, i, arr ) { ... } )1) 代码要运行就会被解析, 已解析就会创建对象    for ( var i = 0; i &lt; 10; i++  ){        var o = {};    } 2) forEach 与 setInterval 等函数一样, 回调函数会被多次解析    因此会造成一定的 性能问题, 因此应该考虑将函数独立的书写在外面,    使用的时候作为参数传入.    // 设置一个非常限制级的条件    // ...    function getFoo () {        return function foo( v, i, arr ) {            // 可以访问到被遍历的数组么?        }    }    // ...    function mainFunc( foo ) {        // ...        arr.forEach( foo );    }     // ...    mainFunc( getFoo() )</code></pre></li></ol><pre><code>2.jq 中 map 与 each 中回调函数的参数为什么不同   1) 数组中的参数全部都是 v, i   2) jq 中 map 是 v, i; each 是 i, v   arr.forEach(function ( v, i ) {       // 操作元素       // 使用 v   })   jq 中 map 也是因为使用的频率, 所以 i 在后面, v 在前面   但是 each 呢? 因为 this 就是遍历的对象, 开发的时候基本不会写参数   $.each( nodeList, function () {       this.style...   } )3.$(&quot;&lt;p/&gt;&quot;).appendTo(&quot;div&quot;).addClass(&quot;test&quot;).end().addClass(&quot;test2&quot;)   执行过程       $(&quot;&lt;p/&gt;&quot;)           创建 DOM 对象 -&gt; 包装成 jq 对象       .appendTo(&quot;div&quot;)    追加到页面中的 div 中( 注意: 标签的拷贝 )       .addClass(&quot;test&quot;)   将所有的 p 标签增加 class 演示       .end()              恢复最近的一次破坏, 即一个 p 标签的情况       .addClass(&quot;test2&quot;)  给这一个 p 标签, 添加 类演示    链式编程就是工厂的流水线</code></pre><ol start="3"><li><p>工具<br> everything<br> rquickExpr=/^(?:\s<em>(&lt;[\w\W]+&gt;)[^&gt;]</em>|#([\w-]*))$/, 老师这个正则表达式能不能讲讲<br> 正则表达式( regular expression )<br> RegExp<br> 用处: 匹配, 验证; 替换, 截取, 分析<br> 要求:<br> 1&gt; 记住元字符</p><pre><code>基本元字符:    .               匹配任意的非换行字符, 常常表示通用元字符使用 [\s\S]    []              匹配一个出现在 [] 中的字符, [123456789123456789123456789], [a-z0-9A-Z]                    计算机只认识 数字, 所以我们写的字符串计算机其实不是以字符串的形式存储                    有一个编码系统: unicode                        &apos;0&apos;                 48                        &apos;1&apos;                 49                        ...                        &apos;9&apos;                 57                    写上:  &apos;012&apos; , 在内存中存储: 48 49 50                     需要记住的是:                        &apos;0&apos;                 48                        &apos;a&apos;                 97                        &apos;A&apos;                 65                        \u0030    ()              1&gt; 分组; 2&gt; 提升优先级    |               或者                    匹配 foot 或者 food                    foot|food                    注意: | 具有最低优先级                    ^(foot|food)$                    常见的用法                    例如要匹配jq的属性选择器:                         [name]                        [name=value]                    用正则: \[\w+=\w+\]|\[\w+\]                    jq 的写法: \[\w+(=\w+|)\]                    (foot|food)     匹配: &apos;foot&apos; 或者 &apos;food&apos;                    (foot|)         匹配: &apos;foot&apos; 或者 &apos;&apos;                    food(=food|)    匹配: &apos;food=food&apos; 或者 &apos;food&apos;                    \w+(=\w+|)      匹配: &apos;字符=字符&apos; 或 &apos;字符&apos;                    \[\w+(=\w+|)\]  匹配: &apos;[xxx]&apos; 或 &apos;[xxx=vvv]&apos;                    \[\s*(\w+)\s*(?:([|!^$~]?=)\s*(\w+)|)\s*\]                    =&gt;                    \[   \s*     (\w+)  \s*   (?:   ([|!^$~]?=)     \s*    (\w+)   |)   \s*   \]</code></pre></li></ol><pre><code>    限定元字符        +                   (abc)+              {1,}        *                                       {0,}        ?        {n}        {n,}        {n,m}    首尾元字符        ^                   必须以 xxx 开头                            表示否定:                                [abc]           用来匹配 一个 字符 a, 或 b, 或 c                                [^abc]          用来匹配一个字符, 要求不允许是 a, b, c        $                   必须以 xxx 结尾                            表示组引用                                a(b)c    简写元字符        \w                  word        \W        \s                  space        \S        \d                  digit        \D    其他:        (?: )        \12&gt; 基本的匹配案例    如何匹配    1) 匹配任意的自然数, 就是 0, 1, 2, 3, ...        [0-9]  等价于 \d        分类讨论            -&gt; 一位数字: \d            -&gt; 两位: [1-9]\d            -&gt; 任意位( 除了一位 ): [1-9]\d+        合并:             \d|[1-9]\d+        可以进行演变( 用不同的方法写同一个例子 )            [1-9]\d*|0            [1-9][0-9]*|0            ...    2) 匹配任意的整数, 0, +1, -1, +2, -2, ...        [+-]?[1-9][0-9]*|0        (+|-|)[1-9][0-9]*|0        ...    3) 匹配任意的实数, 0.01, 0.0000123, -0.1234567        整数 + 小数部分        分类( 划归 )            ((+|-|)[1-9][0-9]*|0)(\.\d+|)        无法匹配 -0.1        无非就是不允许匹配 -0.0+        使用正则的原则: 够用即可, 尽可能写成多步的判断, 要保证正则表达式的尽可能简洁        -0+(\.|)0*        if ( !... ) {            if ( ... )        }        \d{17}|[\dxX]        \d{11}    4) 匹配邮箱        [^@]+@[^@]+        如果想要严谨一点        邮箱分成用户名 和 域名        用户名: 可以有数字, 字母下划线组成( 还有一些特殊字符 )            [\w\-]+        域名: xxx.com.cn.xxxx            [\w\-]+(\.[\w\-]+)+    5) 匹配 ip 地址        采用数字点分的方法描述, 而且每一个数字的取值在 0-255 之间, 都可以取到        0.0.0.0        255.255.255.255        123.124.125.126        ...        \d{1,3}(\.\d{1,3}){3} 或者: \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}         利用正则实现匹配 0 到 255 的数字        分类:        一位: [0-9]        两位: 10-99              [1-9][0-9]        三位: 100-255              开始为 1 的: 100-199: 1[0-9][0-9]              开始为 2 的: 200-255:                 中间为 0-4 的: 2[0-4][0-9]                中间为 5 的: 25[0-5]        [0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]        IP:        [0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]\.[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]\.[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]\.[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]        练习: 如配匹配计算机中的一个文件路径全名        例如: C:\myMusics\list\myFavorite\rain.MP3            盘符: 一个字符: a-z, 简单的写 . 如果想要严格处理 [a-z]            冒号和斜线: :\\            路径(文件夹的名字): .+\\ 如果想要精确: ([^|:\?\*&gt;&lt;\\\/\&quot;]+\\)*            文件名: .+\..+ 如果想要精确一点: [^|:\?\*&gt;&lt;\\\/\&quot;]+\.[^|:\?\*&gt;&lt;\\\/\&quot;]+            组合起来:                .:.*\\.+\..+            注意: 正则表达式有贪婪模式                 C:\myMusics\list\myFavorite\rain.MP3                .:(.*)\\.+\..+                .:.*\\.+.+            如果一个正则表达式中有多个 .+ 或 .* 的结构, 如果造成了匹配的歧义, 满足一个规则. 即贪婪模式            从左往右 匹配个数的能力是左强又弱, 而且只有两个级别, 要么强, 要么弱                例如:                     var s = &apos;1234567890&apos;;                    //        1 2 3                    var r = /(.+)(.+)(.+)/;                    var res = r.exec( s );            例如匹配 div 标签                    var r = /&lt;div.*?&gt;.*&lt;\/div&gt;/;            如果不希望有贪婪模式在 限定元字符( +, * 等 )后写上 ?3&gt; 字符串提取( 解析 )    .exec 方法    利用正则表达式, 去处理字符串, 并将字符串中符合正则表达式的数据取出来     var s = &apos;1234567&apos;;    var r = /\d/;    var m = r.exec( s );   // m 是 match 的简写, 表示捕获    // 如果匹配上了, 就返回数组, 第 0 项 就是匹配到的结果, 如果正则表达式中有 分组    // 分组都是从 1 开始的编号, 那么对应的 第 n 组匹配到的结果就在这个数组的第 n 项    // 注意: 是真数组    // 如果没有匹配到 则返回 null    分组: 就是 ()    从左往右数 (, 第一个开始编号, 从 1 开始编号, 此时编号完成以后, 对应圆括号组成的就是对应的组    //         1   2  34       5    例如: r = /(\d)(\d((\d)\d))(\d)/;    做坏事:     想要做一个推广, 在论坛中发布我有XXX的视频, 如果想要的留下邮箱    如果有人留下的是 QQ 号, 将其拉到一个群里    注意: exec 匹配提取, 只能匹配提取第一个被捕获的数据    如果需要匹配字符串中所有符合要求的字符串    1) 开启全局模式, 在正则后面写上一个 g, 或在构造函数的 第二个参数中提供 &apos;g&apos;        创建正则:            -&gt; 字面量:   /.+\\.+/g            -&gt; 构造函数: new RegExp( &apos;.+\\\\.+&apos;, &apos;g&apos; )    2) 开启全局模式后, 使用 正则表达式对象 调用 exec 方法一次, 就会从 0 位置或上一次结束的位置开始        查找下一个匹配结果, 如果查找到结果则返回对应数组, 如果没有查找到( 即, 找完了 )就会返回 null.        如果还继续调用 exec, 那么就从头开始再查一次.    例如:        var s = &apos;123&apos;;        var r = /\d/g;        r.exec( s );   // [ &apos;1&apos; ]        r.exec( s );   // [ &apos;2&apos; ]        r.exec( s );   // [ &apos;3&apos; ]        r.exec( s );   // null        r.exec( s );   // [ &apos;1&apos; ]        ...        一般要取到所有的数据, 可以使用下面的代码结构        var m;        while ( ( m = r.exec( s ) ) != null ) {            // 此时 m 就是找到的结果        }    练习:        1) 将文章中所有的数字提取出来        2) 将文章中所有的邮箱提取出来        ...4&gt; 字符串替换    .replace( 正则表达式, 需要替换的字符串 )    1) 将一个字符串中所有的 - 换成一个连线        var s = &apos;a-----------------------------------b----------------------c----d&apos;;        // =&gt; a-b-c-d        var res = s.replace( /-+/g, &apos;-&apos; );        应用背景            /\*.*?([\r\n]+.*?)*\*/        换行: \r\n        因此 \r 是回车的意思             \n 是换行的意思        平时在处理换行的时候要注意: 在 有些时候是 \r\n, 有些时候是 \n        在 类 Unix 操作系统中( unix, linux, mac ) 换行都是 \n        在 windows 中是 换行是 \r\n    2) 在替换中还可以使用组        var s = &apos;2012-3-4&apos;;        // 在不同的系统中想要显示成        // 2012年3月4日        // 3月4日2012年        // 4/3/2012        // ...        var r = /(\d+)\-(\d+)\-(\d+)/;        var res = s.replace( r, &apos;$1年$2月$3日&apos; )    3) 替换的时候, 第二参数可以是函数, 函数的参数为, 匹配到的数组的散列值        利用函数的返回值替换匹配到的结果        var s = &apos;2012-3-4&apos;;        var r = /(\d+)\-(\d+)\-(\d+)/;        s.replace( r, function ( match, g1, g2, g3 ) {             return g1 + &apos;年&apos; + g2 + &apos;月&apos; + g3 + &apos;日&apos;;        });        电话号码的加密        var list = [            &apos;12345678901&apos;,            &apos;12345678912&apos;,            &apos;12345678923&apos;,            &apos;12345678934&apos;,            &apos;12345678945&apos;,            &apos;12345678956&apos;        ];        var res = list.map( function ( v ) {            //                 电话号码的前4位            //                              电话号码的后 2 位            return v.replace( /(\d{4})(\d+)(\d{2})/, function ( a, b, c, d ) {                // a 就是匹配到的 电话号码                // b 就是匹配到的 电话号码的前 4 位                // c 就是匹配到的电话号码的 中间 5 位                // d 就是匹配到的电话号码的 后 2 位                return b + &apos;***********&apos;.slice( 0, c.length ) + d;                // return b + &apos;*****&apos; + d;            });        });    (?:)    var s = &apos;1234567&apos;;    //        1   2       3     4    var r1 = /(\d)(\d\d\d)(\d\d)(\d)/;    r1.exec( s ); // =&gt; [ &apos;1234567&apos;, &apos;1&apos;, &apos;234&apos;, &apos;56&apos;, &apos;7&apos; ]    \    //        1             2     3    var r2 = /(\d)(?:\d\d\d)(\d\d)(\d)/;    r2.exec( s ); // =&gt; [ &apos;1234567&apos;, &apos;1&apos;, &apos;56&apos;, &apos;7&apos; ]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;每天坚持多看看&lt;/p&gt;
&lt;h6 id=&quot;今天主要内容：复习经常会遇到的问题&quot;&gt;&lt;a href=&quot;#今天主要内容：复习经常会遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;今天主要内容：复习经常会遇到的问题&quot;&gt;&lt;/a&gt;今天主要内容：复习经常
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS原生框架-2</title>
    <link href="https://heima0.github.io/2016/02/12/JS%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-2/"/>
    <id>https://heima0.github.io/2016/02/12/JS原生框架-2/</id>
    <published>2016-02-12T11:41:29.000Z</published>
    <updated>2022-11-12T14:02:35.947Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>迭代<br> 就是循环<br> 产品迭代, 将一个产品做出来, 做出一个 “稳定” 版本.<br> 在其基础上通过需求调整, 算法的调整等等一系列调整得到一个新的 “稳定” 版本.<br> 这个过程就是迭代过程.</p><p> 例如使用 DOM-Core 方法设置 div 的样式</p> <div style="width: 200px; height: 100p; border: 1px dashed red;"></div><p> 设置 div 的宽度为 300px</p><p> div.style.width = ‘300px’;</p><p> div.setAttribute( ‘style’, ‘width: 300px; height: 100p; border: 1px dashed red;’ )</p><p> var style = div.getAttribute( ‘style’ );<br> var styles = style.split( ‘;’ );<br> var styleObj = {};<br> styles.forEach(function ( v ) {</p><pre><code>var tmp = v.split( &apos;:&apos; );// 要修改样式只需要修改对象的属性即可styleObj[ tmp[ 0 ] ] = tmp[ 1 ];</code></pre><p> });</p><p> // …<br> // 要修改样式只需要修改对象的属性即可, 最后要修改标签的时候<br> var style2 = $.map( styleObj, function ( v, k ) {</p><pre><code>return k + &apos;:&apos; + v;</code></pre><p> }).join( ‘;’ );     //将返回的数组 join成字符串，之间用 ; 连接。<br> // …</p></li></ol><pre><code>在 jq 中 append 表示的是追加, 含义是将 后面参数中的 DOM 追加到 前面 对象的 子元素的结尾处. 与    appendChild 一致.$( &apos;body&apos; ).append( $( &apos;&lt;img src=&quot;....jpg&quot;/&gt;&apos; ) )与body.appendChild( img ) 是一样的appendTo 表示追加, 含义讲前面的元素 追加到 后面的元素的子元素的结尾处.$( &apos;&lt;img src=&quot;...jpg&quot;/&gt;&apos; ).appendTo( &apos;body&apos; )function each( arr, callback ) {} each( [ 1, 2, 3 ], function ( v, i ) {     // ...})1&gt; 函数中如果没有代码 数组的每一项就什么也不做2&gt; 函数中写什么代码 数组中的每一项就做什么事情3&gt; 也就是说函数在处理数组的每一项由于要处理每一项, 因此必须要遍历数组的每一个元素即有function each( arr, callback ) {    for ( var i= 0; i &lt; arr.length; i++ ) {        var item = arr[ i ];    }} 使用函数处理每一项就是用函数处理 item 就是说将 item 传入函数处理function each( arr, callback ) {    for ( var i= 0; i &lt; arr.length; i++ ) {        var item = arr[ i ];        callback( item );    }}// 按照 数组的 forEach 方法实现 自己的 each 方法// 要求 有两个参数, 一个是需要遍历的数组, 一个是回调函数, 要求回调函数有两个参数, 分别是 v, ifunction each( arr, callback ) {    for ( var i = 0; i &lt; arr.length; i++ ) {        callback( arr[ i ], i );    }}// 改良第一步, 添加 this 的引用, 参数向 jq 靠拢function each( arr, callback ) {    for ( var i = 0; i &lt; arr.length; i++ ) {        callback.call( arr[ i ], i, arr[ i ] );    }}// 第二次改良, 在返回 false 的时候跳出循环, 注意, 返回 undefined, 0, 等不会跳出// 所以这里一定有一个 完全等于 , 跳出循环就是跳出 each 函数内的 for 即需要 breakfunction each( arr, callback ) {    for ( var i = 0; i &lt; arr.length; i++ ) {        if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break;    }}// 第三个改良就是返回被遍历的对象function each( arr, callback ) {    for ( var i = 0; i &lt; arr.length; i++ ) {        if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break;    }    return arr;}遍历对象与遍历数组 有什么区别?-&gt; 遍历对象是将对象的所有键值对遍历出来( 包括自然数项, 如果有的话 )-&gt; 遍历数组就是在遍历自然数项让我们的 each 方法可以遍历对象要求, 不考虑数组, 只用 each 遍历对象 代码怎么写?function each( obj, callback ) {    for ( var k in obj ) {        if ( callback.call( obj[ k ], k, obj[ k ] ) === false ) break;    }    return obj;}判断是不是 数组或伪数组 的依据就是 length &gt;= 0对象没有length属性;function each( arr, callback ) {    if ( arr.length &gt;= 0 ) {        for ( var i = 0; i &lt; arr.length; i++ ) {            if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break;        }    } else {        for ( var k in arr ) {            if ( callback.call( arr[ k ], k, arr[ k ] ) === false ) break;        }    }    return arr;}</code></pre><ol start="3"><li><p>封装 map</p><p> 首先考虑, 只是处理 v 返回 结果( 实现一个 与 数组 的 map 一样的方法 )<br> function map( arr, callback ) {</p><pre><code>var rest = [];for ( var i = 0; i &lt; arr.length; i++ ) {    // 要返回的数据是 回调函数的 返回值    rest.push( callback( arr[ i ], i ) );}return rest;</code></pre><p> }<br> // 向 jq 靠拢<br> // 1&gt; 不返回则不加到数组中<br> // 2&gt; 遍历对象<br> function map( arr, callback ) {</p><pre><code>var rest = [], tmp;if ( arr.length &gt;= 0 ) {    for ( var i = 0; i &lt; arr.length; i++ ) {        //为什么是 null，如果 return undefined；jq中没有return 是【】。        tmp = callback( arr[ i ], i );        if ( tmp != null ) {            rest.push( tmp );        }    }} else {    for ( var k in arr ) {        tmp = callback( arr[ k ], k );        if ( tmp != null ) {            rest.push( tmp );        }    }}return rest;</code></pre><p> }</p></li></ol><ol start="4"><li><p>再回到原始的问题<br> 使用 jq 来实现, 应该怎么写<br> $( ‘div, p’ ).each( … )</p><p> 在 jq 中有两组遍历方法, 一个是静态的 each 和 map, 例如</p><pre><code>$.map( arr, callback )$.each( arr, callback )</code></pre><p> 静态的方法遍历的是传入的对象或数组<br> 除此之外 jq 还提供了一组实例方法</p><pre><code>$( ... ).each( function () { ... } )$( ... ).map( function () { ... } )</code></pre><p> 实例方法中遍历当前 jq 对象.</p><pre><code>$( &apos;div&apos; ) </code></pre><p> jq 的本质就是 伪数组<br> 利用 jq 判断页面中某一个元素是否存在: $( ‘…’ ).length &gt; 0</p></li><li><p>框架的核心结构<br> 需求:<br> 1&gt; 有一个函数, 可以实现元素的获取功能( select -&gt; Array )<br> 2&gt; 这个函数返回的对象具有 each 方法. 该方法只有一个 回调函数的 参数, 用于遍历每一个对象.</p><p> 先把函数写出来<br> function I( selector ) {</p><p> }<br> 该函数可以获取元素<br> function I( selector ) {</p><pre><code>var list = document.querySelectorAll( selector ); // 伪数组</code></pre><p> }<br> 返回的数据应该就是这个 list, 但是又需要有 each<br> 所以可以考虑直接让 list 带有 each 方法</p><p> //list.each = function(callback){</p><pre><code>//将其每一项传到回调函数中，each(this,callback);</code></pre><p> //};</p><p> function I( selector ) {</p><pre><code>var list = document.querySelectorAll( selector ); // 伪数组list.each = function ( callback ) {    // 调用 该方法就是在 遍历 list 并将每一个元素用 callback 进行处理    each( this, callback );}return list</code></pre><p> }</p></li><li><p>引入构造函数( init )<br> 知道 list 是一个有 qsa 方法返回的对象, 每次提供 each 方法不合理, 而且 jq 有很多方法<br> 所以借助 oop 的知识应该使用 继承. 利用构造函数来创建 “list 对象”, 但是继承自提供<br> each 等方法的原型对象.</p><p> function F( selector ) {</p><pre><code>// 给 this 加 伪数组项</code></pre><p> }<br> F.prototype.each = function () {</p><p> }</p><p> 考虑到 list 中每次都添加方法不合理, 而且冗余, 因此使用构造函数创建对象( 伪数组 ).<br> 让构造函数.prototype 提供各种方法, 那么实例对象( 伪数组 )就可以使用这些方法了.</p><p> function F( selector ) {</p><pre><code>// 给 this 加 伪数组项var list = document.querySelectorAll( selector );for( var i = 0; i &lt; list.length; i++ ) {    this[ i ] = list[ i ];}this.length = list.length;</code></pre><p> }<br> F.prototype.each = function ( callback ) {</p><pre><code>each( this, callback );</code></pre><p> };</p><p> 升级一下<br> function F( selector ) {</p><pre><code>// 给 this 加 伪数组项//这一步是给 新建对象初始化，将伪数组每一项附给 this。[].push.apply( this, document.querySelectorAll( selector ) );</code></pre><p> }<br> F.prototype.each = function ( callback ) {</p><pre><code>each( this, callback );</code></pre><p> };</p><p> 如何使用呢?<br> new F( ‘div, p’ ).each( … )</p></li></ol><ol start="7"><li><p>隐藏 new 关键字<br> 考虑引入函数<br> function iQuery( selector ) {</p><pre><code>return new F( selector );</code></pre><p> }<br> var I = iQuery;</p><p> 引入沙箱<br> 从沙箱中如果要暴露一些函数或对象采用方法有三种( 常用 )<br> 1&gt; 利用 window 参数</p><pre><code>(function ( window ) {    window.xxx = vvv;})( window );</code></pre><p> 2&gt; 利用 返回值( 例如 Sizzle )</p><pre><code>var Sizzle =(function () {    return xxx;})();</code></pre><p> 3&gt; 利用 this 映射</p><pre><code>(function () {    // 这里的this 代表window。    this.xxx = vvv;})();</code></pre></li></ol><p>  缺点:<br>     1&gt; 代码结构凌乱. 优化结构.<br>     2&gt; 无法实现扩展, 只有在该文件中实现代码结构.  // ?不是引入沙箱模式了吗？</p><ol start="8"><li><p>可扩展性<br> 1&gt; 可以将 iQuery 的一个属性指向构造函数</p><pre><code>var iQuery = function ( selector ) {    return new F( selector );};...iQuery.F = F;...此时对外的扩展iQuery.F.prototype.xxx = vvv;</code></pre><p> 2&gt; 在 jq 中采用是原型映射的办法, jq 中将 对外公开的 jquery 函数 与 构造函数 的原型用一个对象表示</p><pre><code>// 类比F.prototype = {};iQuery.prototype = F.prototype;//===============================================================var jQuery = function ( selector ) {    return ...( selector );};jQuery.prototype = {    // 对象    constructor: jQuery,    each: function () ....};  var init = function ( selector ) {    // ... 构造函数 ...    // [].push.apply( this, document.querySelectorAll( selector ) );};init.prototype = jQuery.prototype;//===============================================================// 在 jq 中又 进一步处理// 将 init 函数作为 jquery 的原型的一个方法// 将所有的方法挂载到 jQuery 上, 便于优化与更新//init应该指的是构造函数，目的是为了在外面能够直接修改方法。// jquery 1.7 以后的写法var jQuery = function ( selector ) {    return new init1( selector );    return new jQuery.fn.init( selector );};jQuery.fn = jQuery.prototype = {    // 对象    constructor: jQuery};  var init1 = jQuery.fn.init = function ( selector ) {    // ...};//静态成员？//这一步存在的意义？//答：因为在外界如果要改构造函数方法。需要jQuery.fn.init 才能访问到 构造函数，那么问题来了，因为外界不知道有这么一个 init方法。所以，可以让构造函数的原型和 jQuery 公用一个原型，这样就能通过修改jQuery的原型，进而对构造函数进行修改。init1.prototype = jQuery.fn;等价的写法// jquery 1.7 以前的写法var jQuery = function ( selector ) {    return new jQuery.fn.init( selector );};jQuery.fn = jQuery.prototype = {    // 对象    constructor: jQuery,    init: function ( selector ) {        // ...    }};  jQuery.fn.init.prototype = jQuery.fn;</code></pre></li></ol><ol start="9"><li>代码结构</li></ol><p> 1.为什么 forEach 中的回调函数会有第三个参数<br>    arr.forEach( function ( v, i, arr ){<br>        1) 代码要运行就会被解析，一解析就会创建对象<br>    }</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;迭代&lt;br&gt; 就是循环&lt;br&gt; 产品迭代, 将一个产品做出来, 做出一个 “稳定” 版本.&lt;br&gt; 在其基础上通过需求调整, 算法的调整等等一系列调整得到一个新的 “稳定” 版本.&lt;br&gt; 这个过程就是迭代过程.&lt;/p&gt;
&lt;p&gt; 例如使用 DOM-Core
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS原生框架-1</title>
    <link href="https://heima0.github.io/2016/02/08/JS%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6-1/"/>
    <id>https://heima0.github.io/2016/02/08/JS原生框架-1/</id>
    <published>2016-02-08T11:35:45.000Z</published>
    <updated>2022-11-12T14:02:35.946Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>原生框架<br> -&gt; 注意: 不是在重复造轮子. </p><pre><code>-&gt; 把学习到的 js 等知识用起来-&gt; 学习背后的思想( 提升, 面试 )</code></pre><p> -&gt; 准备工作</p><pre><code>-&gt; js 语言入门: 1) 所有关键字( delete, in ), 2) 学会字符串操作,               3) 数组操作, 4) 键值对的使用( 容易 )-&gt; 熟悉 jquery-&gt; 基本的 DOM 操作-&gt; OOP (面向对象编程 )</code></pre></li><li><p>内容分类<br> -&gt; 选择模块<br> -&gt; 框架的核心结构<br> -&gt; DOM 操作<br> -&gt; 事件与属性和样式<br> -&gt; 插件机制<br> -&gt; 工具</p></li><li><p>案例<br> 将下列 div 与 p 标签添加 1px solid red 样式<br> <div>div</div><br> <span>span</span></p> <p>P</p><br> <span>span</span><br> <div>div</div><br> <span>span</span><br> <p>P</p><br> <span>span</span><br> <div>div</div><br> <span>span</span><br> <p>P</p></li><li><p>DOM 操作的要求<br> -&gt; 学会分析 DOM 树</p><pre><code>绘制 DOM 树( 标准 代码需要与图对象 )</code></pre><p> -&gt; 增删改查的方法</p><pre><code>查:    document.getElementById()    document.getElementsByTagName()    document.getELementsByClassName()     document.getElementsByName()    document.querySelector()    document.querySelectorAll()</code></pre><p> -&gt; 访问亲属节点深度为 2 级</p><pre><code>如何访问父节点如果访问兄弟节点如何访问子节点</code></pre></li><li><p>DOM 常用属性<br> .nodeName       标签名, 都是大写<br> .nodeType       获得节点的类型: 1, 元素; 2, 属性; 3, 文本<br> .nodeValue      常常用于文本节点, 表示文本的内容</p></li><li><p>利用数据, 生成 table<br> var data = [</p><pre><code>{ name:&apos;jim1&apos;, age:19, gender: &apos;女&apos; },{ name:&apos;jim2&apos;, age:9, gender: &apos;男&apos; },{ name:&apos;jim3&apos;, age:29, gender: &apos;女&apos; },{ name:&apos;jim4&apos;, age:39, gender: &apos;女&apos; },{ name:&apos;jim5&apos;, age:49, gender: &apos;男&apos; },{ name:&apos;jim6&apos;, age:59, gender: &apos;男&apos; }</code></pre><p> ];<br> // 利用这个数据在 也没中 生成一个 table, 要求: 不用考虑 thead 等元素, 只考虑 tbody 即可<br> 假定页面为<br> <body></body></p><pre><code>&lt;input type=&quot;button&quot; value=&quot;点击生成表格&quot; id=&quot;btn&quot;/&gt;</code></pre><p> </p> <script>     select( '#btn' ).onclick = function () {         // ...     }; </script></li></ol><ol start="7"><li><p>答疑<br> -&gt; NodeList</p><pre><code>该数据就是一个伪数组的数据类型HTMLCollectionNodeList用于描述一个集合数据类型( 伪数组 )</code></pre><p> -&gt; slice.call</p><pre><code>问    [].slice.call    Array.prototype.slice.call    rest.slice.call    有什么区别?var o = {    method: function () {}};o.method();o.method.call( ... )var f = o.method;f.call( ... );</code></pre></li></ol><pre><code>-&gt; apply call 参数    -&gt; 概念        [].push.apply( rest, list );        相当于 rest.push( &quot;list&quot; )        [].push.call( rest, list );        相当于 rest.push( &quot;list&quot; )    -&gt; call 与 apply 的参数        -&gt; 第一个参数:            如果是基本类型( string, number, boolean ) 会转换成包装类型( String, Number, Boolean )            如果是引用类型( 非空 ), this 就是它( 相当于方法调用 )            如果是空( null 与 undefined ) 那么 this 就是 window        -&gt; 第二个+参数            apply 只有两个参数, 第二个参数一定是一个数组( 伪数组 )                func.apply( obj, [ a, b, c, ..., n ] )                等价于                func( a, b, c, ..., n )            call 将参数散列处理, 函数调用时怎么传参, call 就怎么传参                func.call( obj, a, b, c, ..., n )                等价于                func( a, b, c, ..., n )        -&gt; 既然有 call 为何还要有 apply            var arr = [ 1, 2 ];            arr.push( 3, 4, 5, 6, 7 );            var weiArray = { 0:1, 1:2, 2:3, length: 3 };            var zhenArray = [ 1, 2 ];            [].push.call( zhenArray, weiArray );            =&gt;            zhenArray.push( weiArray );            [].push.apply( zhenArray, weiArray );            =&gt;            zhenArray.push( ...weiArray )-&gt; 关联数组的用法    var o = { name:&apos;jim&apos;, age: 19, gender: &apos;男&apos; };    // 点语法访问( 硬编码 )    // o.name    // 如果想要提供一个功能, 用户输入什么就访问什么    if ( input === &apos;name&apos; ) {        o.name ....    }    else if ( input === &apos;age&apos; ) {        o.age ....    }    else if ( input === &apos;gender&apos; ) {        o.gender ....    }    ...    ...    // js 允许像使用数组一样使用对象, 只需要提供 属性的名字即可    // o[ 名字 ]    o[ input ]    =&gt;    o[ &apos;name&apos; ]    o[ &apos;age&apos; ]    o[ &apos;gender&apos; ]    ...    ...</code></pre><ol start="8"><li><p>DOM-Core 与 HTML DOM<br> 在 实际开发中, 有很多数据使用 XML 格式来进行表示的( win 新的技术( WPF ), 安卓界面, 苹果的界面, … )<br> 在处理这数据的时候 通用方法称为 核心 DOM 方法</p> <div>111</div><div>2<div>111</div>2<div>111</div>2</div><p> 在实际应用 HTML 飞速发展, 因此在处理 HTML 的时候给出了一些快速处理的 api, 这些 api 就称为 HTML-DOM</p><p> HTML-DOM, 首先是 DOM 方法, 适用于 HTML 文档</p><p> 给 body 标签增加一个 itcast 属性</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;原生框架&lt;br&gt; -&amp;gt; 注意: 不是在重复造轮子. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-&amp;gt; 把学习到的 js 等知识用起来
-&amp;gt; 学习背后的思想( 提升, 面试 )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; -&amp;gt; 准备工作&lt;/p&gt;
&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="js" scheme="https://heima0.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>通知</title>
    <link href="https://heima0.github.io/2016/01/02/%E9%80%9A%E7%9F%A5/"/>
    <id>https://heima0.github.io/2016/01/02/通知/</id>
    <published>2016-01-02T02:51:59.000Z</published>
    <updated>2022-11-12T14:02:35.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="callback-callback"><a href="#callback-callback" class="headerlink" title="callback callback"></a>callback callback</h1><h3 id="callback-callback-callback"><a href="#callback-callback-callback" class="headerlink" title="callback callback callback"></a>callback callback callback</h3><h6 id="callback-callback-callback-1"><a href="#callback-callback-callback-1" class="headerlink" title="callback callback callback"></a>callback callback callback</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback callback callback callback callback callback</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;callback-callback&quot;&gt;&lt;a href=&quot;#callback-callback&quot; class=&quot;headerlink&quot; title=&quot;callback callback&quot;&gt;&lt;/a&gt;callback callback&lt;/h1&gt;&lt;h3 id=&quot;callb
      
    
    </summary>
    
    
  </entry>
  
</feed>
